[
    {
        "page_index": 0,
        "chunk_index": 0,
        "text": "M8 Objectives\n\nAfter completing this week's work, you will be able to:\n\nCreate, read, write and update files. \nUse classes File and Directory to obtain information about files and directories on your computer. \nUse classes FileStream, StreamReader and StreamWriter to read text from and write text to files. \n\nUse classes FileStream and BinaryFormatter to read objects from and write objects to files - serialize and deserialize an object \n\nUse OpenFileDialog and SaveDialog controls to display standard Windows dialog boxes for opening and saving files\nUse \"Using\" statement to release resources\n\n \n\n M8 Activities  Watch Video Lectures\nRead Lecture Slides & Programming Guide,\nPractice with Sample Code\nComplete M8  Quiz and Assignment"
    },
    {
        "page_index": 1,
        "chunk_index": 0,
        "text": "Lecture Slides: FileStream.pdf\n Sample Code: Grader.zip\n Video Lectures :  \n- FileStream\n\n- Grader Project Walkthrough"
    },
    {
        "page_index": 2,
        "chunk_index": 0,
        "text": "Note: WPF .NET 7.0, follow How to open a common dialog box (WPF .NET)\nHow to: Open files with the OpenFileDialog\nThe System.Windows.Forms.OpenFileDialog component opens the Windows dialog box for browsing and selecting files. To open and read the selected files, you can use the OpenFileDialog.OpenFile method, or create an instance of the System.IO.StreamReader class. The following examples show both approaches.\nIn .NET Framework, to get or set the FileName property requires a privilege level granted by the System.Security.Permissions.FileIOPermission class. The examples run a FileIOPermission permission check, and can throw an exception due to insufficient privileges if run in a partial-trust context. For more information, see Code access security basics.\nYou can build and run these examples as .NET Framework apps from the C# or Visual Basic command line. For more information, see Command-line building with csc.exe or Build from the command line."
    },
    {
        "page_index": 2,
        "chunk_index": 1,
        "text": "Starting with .NET Core 3.0, you can also build and run the examples as Windows .NET Core apps from a folder that has a .NET Core Windows Forms <folder name>.csproj project file.\nExample: Read a file as a stream with StreamReade\nThe following example uses the Windows Forms Button control's Click event handler to open the OpenFileDialog with the ShowDialog method. After the user chooses a file and selects OK, an instance of the StreamReader class reads the file and displays its contents in the form's text box. For more information about reading from file streams, see FileStream.BeginRead and FileStream.Read.\nC#\nusing System;\nusing System.Drawing;\nusing System.IO;\nusing System.Security;\nusing System.Windows.Forms;"
    },
    {
        "page_index": 2,
        "chunk_index": 2,
        "text": "public class OpenFileDialogForm : Form\n{\n    [STAThread]\n    public static void Main()\n    {\n        Application.SetCompatibleTextRenderingDefault(false);\n        Application.EnableVisualStyles();\n        Application.Run(new OpenFileDialogForm());\n    }\n\n    private Button selectButton;\n    private OpenFileDialog openFileDialog1;\n    private TextBox textBox1;"
    },
    {
        "page_index": 2,
        "chunk_index": 3,
        "text": "public OpenFileDialogForm()\n    {\n        openFileDialog1 = new OpenFileDialog();\n        selectButton = new Button\n        {\n            Size = new Size(100, 20),\n            Location = new Point(15, 15),\n            Text = \"Select file\"\n        };\n        selectButton.Click += new EventHandler(SelectButton_Click);\n        textBox1 = new TextBox\n        {\n            Size = new Size(300, 300),\n            Location = new Point(15, 40),\n            Multiline = true,\n            ScrollBars = ScrollBars.Vertical\n        };\n        ClientSize = new Size(330, 360);\n        Controls.Add(selectButton);\n        Controls.Add(textBox1);\n    }\n    private void SetText(string text)\n    {\n        textBox1.Text = text;\n    }\n    private void SelectButton_Click(object sender, EventArgs e)\n    {\n        if (openFileDialog1.ShowDialog() == DialogResult.OK)\n        {\n            try\n            {\n                var sr = new StreamReader(openFileDialog1.FileName);"
    },
    {
        "page_index": 2,
        "chunk_index": 4,
        "text": "SetText(sr.ReadToEnd());\n            }\n            catch (SecurityException ex)\n            {\n                MessageBox.Show($\"Security error.\\n\\nError message: {ex.Message}\\n\\n\" +\n                $\"Details:\\n\\n{ex.StackTrace}\");\n            }\n        }\n    }\n}"
    },
    {
        "page_index": 2,
        "chunk_index": 5,
        "text": "Example: Open a file from a filtered selection with OpenFile\nThe following example uses the Button control's Click event handler to open the OpenFileDialog with a filter that shows only text files. After the user chooses a text file and selects OK, the OpenFile method is used to open the file in Notepad.\nC#\nusing System;\nusing System.ComponentModel;\nusing System.Diagnostics;\nusing System.Drawing;\nusing System.IO;\nusing System.Security;\nusing System.Windows.Forms;\n\npublic class OpenFileDialogForm : Form\n{\n    [STAThread]\n    public static void Main()\n    {\n        Application.SetCompatibleTextRenderingDefault(false);\n        Application.EnableVisualStyles();\n        Application.Run(new OpenFileDialogForm());\n    }\n\n    private Button selectButton;\n    private OpenFileDialog openFileDialog1;"
    },
    {
        "page_index": 2,
        "chunk_index": 6,
        "text": "public OpenFileDialogForm()\n    {\n        openFileDialog1 = new OpenFileDialog()\n        {\n            FileName = \"Select a text file\",\n            Filter = \"Text files (*.txt)|*.txt\",\n            Title = \"Open text file\"\n        };\n\n        selectButton = new Button()\n        {\n            Size = new Size(100, 20),\n            Location = new Point(15, 15),\n            Text = \"Select file\"\n        };\n        selectButton.Click += new EventHandler(selectButton_Click);\n        Controls.Add(selectButton);\n    }"
    },
    {
        "page_index": 2,
        "chunk_index": 7,
        "text": "private void selectButton_Click(object sender, EventArgs e)\n    {\n        if (openFileDialog1.ShowDialog() == DialogResult.OK)\n        {\n            try\n            {\n                var filePath = openFileDialog1.FileName;\n                using (Stream str = openFileDialog1.OpenFile())\n                {\n                    Process.Start(\"notepad.exe\", filePath);\n                }\n            }\n            catch (SecurityException ex)\n            {\n                MessageBox.Show($\"Security error.\\n\\nError message: {ex.Message}\\n\\n\" +\n                $\"Details:\\n\\n{ex.StackTrace}\");\n            }\n        }\n    }\n}"
    },
    {
        "page_index": 3,
        "chunk_index": 0,
        "text": "How to: Save Files Using the SaveFileDialog Component\nThe SaveFileDialog component allows users to browse the file system and select files to be saved. The dialog box returns the path and name of the file the user has selected in the dialog box. However, you must write the code to actually write the files to disk.\nTo save a file using the SaveFileDialog component Display the Save File dialog box and call a method to save the file selected by the user.\nUse the SaveFileDialog component's OpenFile method to save the file. This method gives you a Stream object you can write to.\nThe example below uses the DialogResult property to get the name of the file, and the OpenFile method to save the file. The OpenFile method gives you a stream to write the file to.\nIn the example below, there is a Button control with an image assigned to it. When you click the button, a SaveFileDialog component is instantiated with a filter that allows files of type .gif, .jpeg, and .bmp. If a file of this type is selected in the Save File dialog box, the button's image is saved.\n\n Important\nTo get or set the FileName property, your assembly requires a privilege level granted by the System.Security.Permissions.FileIOPermission class. If you are running in a partial-trust context, the process might throw an exception due to insufficient privileges. For more information, see Code Access Security Basics.\n\nThe example assumes your form has a Button control with its Image property set to a file of type .gif, .jpeg, or .bmp.\n\n Note\nThe FileDialog class's FilterIndex property (which, due to inheritance, is part of the SaveFileDialog class) uses a one-based index. This is important if you are writing code to save data in a specific format (for example, saving a file in plain text versus binary format). This property is featured in the example below.\n\nC#\nprivate void button2_Click(object sender, System.EventArgs e)\n{\n    // Displays a SaveFileDialog so the user can save the Image\n    // assigned to Button2.\n    SaveFileDialog saveFileDialog1 = new SaveFileDialog();\n    saveFileDialog1.Filter = \"JPeg Image|*.jpg|Bitmap Image|*.bmp|Gif Image|*.gif\";\n    saveFileDialog1.Title = \"Save an Image File\";\n    saveFileDialog1.ShowDialog();\n\n    // If the file name is not an empty string open it for saving.\n    if(saveFileDialog1.FileName != \"\")\n    {\n      // Saves the Image via a FileStream created by the OpenFile method.\n      System.IO.FileStream fs =\n          (System.IO.FileStream)saveFileDialog1.OpenFile();\n      // Saves the Image in the appropriate ImageFormat based upon the\n      // File type selected in the dialog box.\n      // NOTE that the FilterIndex property is one-based.\n      switch(saveFileDialog1.FilterIndex)\n      {\n          case 1 :\n          this.button2.Image.Save(fs,\n            System.Drawing.Imaging.ImageFormat.Jpeg);\n          break;\n\n          case 2 :\n          this.button2.Image.Save(fs,\n            System.Drawing.Imaging.ImageFormat.Bmp);\n          break;\n\n          case 3 :\n          this.button2.Image.Save(fs,\n            System.Drawing.Imaging.ImageFormat.Gif);\n          break;\n      }\n\n    fs.Close();\n    }\n}\n\n(Visual C#) Place the following code in the form's constructor to register the event handler.\nC#\nthis.button2.Click += new System.EventHandler(this.button2_Click);"
    },
    {
        "page_index": 4,
        "chunk_index": 0,
        "text": "Lecture Slides: Serialization.pdf\n Sample Code: SerialData.zip\n Video Lectures :"
    },
    {
        "page_index": 5,
        "chunk_index": 0,
        "text": "Basic serialization\nThe easiest way to make a class serializable is to mark it with the SerializableAttribute as follows.\n\nC#\n \n\n[Serializable]  \npublic class MyObject {  \n  public int n1 = 0;  \n  public int n2 = 0;  \n  public String str = null;  \n}  \n\nThe following code example shows how an instance of this class can be serialized to a file.\nC#\nMyObject obj = new MyObject();  \nobj.n1 = 1;  \nobj.n2 = 24;  \nobj.str = \"Some String\";  \nIFormatter formatter = new BinaryFormatter();  \nStream stream = new FileStream(\"MyFile.bin\", FileMode.Create, FileAccess.Write, FileShare.None);  \nformatter.Serialize(stream, obj);  \nstream.Close();  \n\nThis example uses a binary formatter to do the serialization. All you need to do is create an instance of the stream and the formatter you intend to use, and then call the Serialize method on the formatter. The stream and the object to serialize are provided as parameters to this call. Although it is not explicitly demonstrated in this example, all member variables of a class will be serialized—even variables marked as private. In this aspect, binary serialization differs from the XmlSerializer class, which only serializes public fields. For information on excluding member variables from binary serialization, see Selective Serialization.\nRestoring the object back to its former state is just as easy. First, create a stream for reading and a Formatter, and then instruct the formatter to deserialize the object. The code example below shows how this is done.\nC#\nIFormatter formatter = new BinaryFormatter();  \nStream stream = new FileStream(\"MyFile.bin\", FileMode.Open, FileAccess.Read, FileShare.Read);  \nMyObject obj = (MyObject) formatter.Deserialize(stream);  \nstream.Close();  \n  \n// Here's the proof.  \nConsole.WriteLine(\"n1: {0}\", obj.n1);  \nConsole.WriteLine(\"n2: {0}\", obj.n2);  \nConsole.WriteLine(\"str: {0}\", obj.str);  \n\nThe BinaryFormatter used above is very efficient and produces a compact byte stream. All objects serialized with this formatter can also be deserialized with it, which makes it an ideal tool for serializing objects that will be deserialized on the .NET Framework. It is important to note that constructors are not called when an object is deserialized. This constraint is placed on deserialization for performance reasons. However, this violates some of the usual contracts the runtime makes with the object writer, and developers should ensure that they understand the ramifications when marking an object as serializable."
    },
    {
        "page_index": 6,
        "chunk_index": 0,
        "text": "Sample Code: \n\nIntroUWP.zip\nFilePicker.zip\n\n Pick a single file: step-by-step: \nUsing a file picker involves creating and customizing a file picker object, and then showing the file picker so the user can pick one or more items. Create and customize a FileOpenPicker\nC#\nvar picker = new Windows.Storage.Pickers.FileOpenPicker();\npicker.ViewMode = Windows.Storage.Pickers.PickerViewMode.Thumbnail;\npicker.SuggestedStartLocation = Windows.Storage.Pickers.PickerLocationId.PicturesLibrary;\npicker.FileTypeFilter.Add(\".jpg\");\npicker.FileTypeFilter.Add(\".jpeg\");\npicker.FileTypeFilter.Add(\".png\");\n\nSet properties on the file picker object relevant to your users and app.\nThis example creates a rich, visual display of pictures in a convenient location that the user can pick from by setting three properties: ViewMode, SuggestedStartLocation, and FileTypeFilter. Setting ViewMode to the PickerViewMode Thumbnail enum value creates a rich, visual display by using picture thumbnails to represent files in the file picker. Do this for picking visual files such as pictures or videos. Otherwise, use PickerViewMode.List. A hypothetical email app with Attach Picture or Video and Attach Document features would set the ViewMode appropriate to the feature before showing the file picker. Setting SuggestedStartLocation to Pictures using PickerLocationId.PicturesLibrary starts the user in a location where they're likely to find pictures. Set SuggestedStartLocation to a location appropriate for the type of file being picked, for example Music, Pictures, Videos, or Documents. From the start location, the user can navigate to other locations. Using FileTypeFilter to specify file types keeps the user focused on picking files that are relevant. To replace previous file types in the FileTypeFilter with new entries, use ReplaceAll instead of Add. Show the FileOpenPicker To pick a single file\nC#\nWindows.Storage.StorageFile file = await picker.PickSingleFileAsync();\nif (file != null)\n{\n    // Application now has read/write access to the picked file\n    this.textBlock.Text = \"Picked photo: \" + file.Name;\n}\nelse\n{\n    this.textBlock.Text = \"Operation cancelled.\";\n} To pick multiple files\nC#\nvar files = await picker.PickMultipleFilesAsync();\nif (files.Count > 0)\n{\n    StringBuilder output = new StringBuilder(\"Picked files:\\n\");\n\n    // Application now has read/write access to the picked file(s)\n    foreach (Windows.Storage.StorageFile file in files)\n    {\n        output.Append(file.Name + \"\\n\");\n    }\n    this.textBlock.Text = output.ToString();\n}\nelse\n{\n    this.textBlock.Text = \"Operation cancelled.\";\n}"
    },
    {
        "page_index": 7,
        "chunk_index": 0,
        "text": "Recommended Online Resources:\n\nUWP: Work with files\n\nCreating a file\nHere's how to create a file in the app's local folder. If it already exists, we replace it.\nC#\n// Create sample file; replace if exists.\nWindows.Storage.StorageFolder storageFolder =\n    Windows.Storage.ApplicationData.Current.LocalFolder;\nWindows.Storage.StorageFile sampleFile =\n    await storageFolder.CreateFileAsync(\"sample.txt\",\n        Windows.Storage.CreationCollisionOption.ReplaceExisting);\n\nWriting to a file\nHere's how to write to a writable file on disk using the StorageFile class. The common first step for each of the ways of writing to a file (unless you're writing to the file immediately after creating it) is to get the file with StorageFolder.GetFileAsync.\nC#\nWindows.Storage.StorageFolder storageFolder =\n    Windows.Storage.ApplicationData.Current.LocalFolder;\nWindows.Storage.StorageFile sampleFile =\n    await storageFolder.GetFileAsync(\"sample.txt\");"
    },
    {
        "page_index": 7,
        "chunk_index": 1,
        "text": "Writing text to a file\nWrite text to your file by calling the FileIO.WriteTextAsync method.\nC#\nawait Windows.Storage.FileIO.WriteTextAsync(sampleFile, \"Swift as a shadow\");"
    },
    {
        "page_index": 7,
        "chunk_index": 2,
        "text": "Writing bytes to a file by using a buffer (2 steps) First, call CryptographicBuffer.ConvertStringToBinary to get a buffer of the bytes (based on a string) that you want to write to your file.\nC#\nvar buffer = Windows.Security.Cryptography.CryptographicBuffer.ConvertStringToBinary(\n    \"What fools these mortals be\", Windows.Security.Cryptography.BinaryStringEncoding.Utf8); Then write the bytes from your buffer to your file by calling the FileIO.WriteBufferAsync method.\nC#\nawait Windows.Storage.FileIO.WriteBufferAsync(sampleFile, buffer); Writing text to a file by using a stream (4 steps) First, open the file by calling the StorageFile.OpenAsync method. It returns a stream of the file's content when the open operation completes.\nC#"
    },
    {
        "page_index": 7,
        "chunk_index": 3,
        "text": "C#\nvar stream = await sampleFile.OpenAsync(Windows.Storage.FileAccessMode.ReadWrite); Next, get an output stream by calling the IRandomAccessStream.GetOutputStreamAt method from the stream. If you're using C#, then enclose this in a using statement to manage the output stream's lifetime. If you're using C++/WinRT, then you can control its lifetime by enclosing it in a block, or setting it to nullptr when you're done with it.\nC#\nusing (var outputStream = stream.GetOutputStreamAt(0))\n{\n    // We'll add more code here in the next step.\n}\nstream.Dispose(); // Or use the stream variable (see previous code snippet) with a using statement as well. Now add this code (if you're using C#, within the existing using statement) to write to the output stream by creating a new DataWriter object and calling the DataWriter.WriteString method.\nC#\nusing (var dataWriter = new Windows.Storage.Streams.DataWriter(outputStream))\n{"
    },
    {
        "page_index": 7,
        "chunk_index": 4,
        "text": "{\n    dataWriter.WriteString(\"DataWriter has methods to write to various types, such as DataTimeOffset.\");\n} Lastly, add this code (if you're using C#, within the inner using statement) to save the text to your file with DataWriter.StoreAsync and close the stream with IOutputStream.FlushAsync.\nC#\nawait dataWriter.StoreAsync();\nawait outputStream.FlushAsync(); Best practices for writing to a file\nFor additional details and best practice guidance, see Best practices for writing to files.\nReading from a file\nHere's how to read from a file on disk using the StorageFile class. The common first step for each of the ways of reading from a file is to get the file with StorageFolder.GetFileAsync.\nC#\nWindows.Storage.StorageFolder storageFolder =\n    Windows.Storage.ApplicationData.Current.LocalFolder;\nWindows.Storage.StorageFile sampleFile =\n    await storageFolder.GetFileAsync(\"sample.txt\");"
    },
    {
        "page_index": 7,
        "chunk_index": 5,
        "text": "Reading text from a file\nRead text from your file by calling the FileIO.ReadTextAsync method.\nC#\nstring text = await Windows.Storage.FileIO.ReadTextAsync(sampleFile);"
    },
    {
        "page_index": 7,
        "chunk_index": 6,
        "text": "Reading text from a file by using a buffer (2 steps) First, call the FileIO.ReadBufferAsync method.\nC#\nvar buffer = await Windows.Storage.FileIO.ReadBufferAsync(sampleFile); Then use a DataReader object to read first the length of the buffer and then its contents.\nC#\nusing (var dataReader = Windows.Storage.Streams.DataReader.FromBuffer(buffer))\n{\n    string text = dataReader.ReadString(buffer.Length);\n} Reading text from a file by using a stream (4 steps) Open a stream for your file by calling the StorageFile.OpenAsync method. It returns a stream of the file's content when the operation completes.\nC#\nvar stream = await sampleFile.OpenAsync(Windows.Storage.FileAccessMode.Read); Get the size of the stream to use later.\nC#\nulong size = stream.Size; Get an input stream by calling the IRandomAccessStream.GetInputStreamAt method. Put this in a using statement to manage the stream's lifetime. Specify 0 when you call GetInputStreamAt to set the position to the beginning of the stream.\nC#"
    },
    {
        "page_index": 7,
        "chunk_index": 7,
        "text": "C#\nusing (var inputStream = stream.GetInputStreamAt(0))\n{\n    // We'll add more code here in the next step.\n} Lastly, add this code within the existing using statement to get a DataReader object on the stream then read the text by calling DataReader.LoadAsync and DataReader.ReadString.\nC#\nusing (var dataReader = new Windows.Storage.Streams.DataReader(inputStream))\n{\n    uint numBytesLoaded = await dataReader.LoadAsync((uint)size);\n    string text = dataReader.ReadString(numBytesLoaded);\n}"
    },
    {
        "page_index": 8,
        "chunk_index": 0,
        "text": "M7 Objectives\n\nAfter completing this week's work, you will be able to:\n\nDeclare a delegate type to create an abstraction of a method signature. \nCreate an instance of a delegate to refer to a specific method. \nCall a method through a delegate. \nDefine a lambda expression to specify the code to be executed by a delegate. \nDeclare an event field. Handle an event by using a delegate. \nRaise an event.\n\n \n\n M7 Activities  Watch Video Lectures\nRead Lecture Slides & Programming Guide,\nPractice with Sample Code\nComplete M7  Quiz and Assignment"
    },
    {
        "page_index": 9,
        "chunk_index": 0,
        "text": "Lecture Slides: Delegates.pdf\n Sample Code: Delegate_Lamda.zip\n Video Lectures: \nIntroduction to Delegates\n\nLamda Expressions"
    },
    {
        "page_index": 10,
        "chunk_index": 0,
        "text": "Delegates \nA delegate is a type that safely encapsulates a method, similar to a function pointer in C and C++. Unlike C function pointers, delegates are object-oriented, type safe, and secure. The type of a delegate is defined by the name of the delegate. The following example declares a delegate named Del that can encapsulate a method that takes a string as an argument and returns void:\nC#\npublic delegate void Del(string message);"
    },
    {
        "page_index": 10,
        "chunk_index": 1,
        "text": "A delegate object is normally constructed by providing the name of the method the delegate will wrap, or with an anonymous function. Once a delegate is instantiated, a method call made to the delegate will be passed by the delegate to that method. The parameters passed to the delegate by the caller are passed to the method, and the return value, if any, from the method is returned to the caller by the delegate. This is known as invoking the delegate. An instantiated delegate can be invoked as if it were the wrapped method itself. For example:\nC#\n// Create a method for a delegate.\npublic static void DelegateMethod(string message)\n{\n    Console.WriteLine(message);\n}\n\nC#\n// Instantiate the delegate.\nDel handler = DelegateMethod;\n\n// Call the delegate.\nhandler(\"Hello World\");"
    },
    {
        "page_index": 10,
        "chunk_index": 2,
        "text": "Delegate types are derived from the Delegate class in the .NET Framework. Delegate types are sealed—they cannot be derived from— and it is not possible to derive custom classes from Delegate. Because the instantiated delegate is an object, it can be passed as a parameter, or assigned to a property. This allows a method to accept a delegate as a parameter, and call the delegate at some later time. This is known as an asynchronous callback, and is a common method of notifying a caller when a long process has completed. When a delegate is used in this fashion, the code using the delegate does not need any knowledge of the implementation of the method being used. The functionality is similar to the encapsulation interfaces provide.\nAnother common use of callbacks is defining a custom comparison method and passing that delegate to a sort method. It allows the caller's code to become part of the sort algorithm. The following example method uses the Del type as a parameter:\nC#"
    },
    {
        "page_index": 10,
        "chunk_index": 3,
        "text": "C#\npublic static void MethodWithCallback(int param1, int param2, Del callback)\n{\n    callback(\"The number is: \" + (param1 + param2).ToString());\n}"
    },
    {
        "page_index": 10,
        "chunk_index": 4,
        "text": "You can then pass the delegate created above to that method:\nC#\nMethodWithCallback(1, 2, handler);\n\nand receive the following output to the console:\nconsole\nThe number is: 3"
    },
    {
        "page_index": 10,
        "chunk_index": 5,
        "text": "Using the delegate as an abstraction, MethodWithCallback does not need to call the console directly—it does not have to be designed with a console in mind. What MethodWithCallback does is simply prepare a string and pass the string to another method. This is especially powerful since a delegated method can use any number of parameters.\nWhen a delegate is constructed to wrap an instance method, the delegate references both the instance and the method. A delegate has no knowledge of the instance type aside from the method it wraps, so a delegate can refer to any type of object as long as there is a method on that object that matches the delegate signature. When a delegate is constructed to wrap a static method, it only references the method. Consider the following declarations:\nC#\npublic class MethodClass\n{\n    public void Method1(string message) { }\n    public void Method2(string message) { }\n}"
    },
    {
        "page_index": 10,
        "chunk_index": 6,
        "text": "Along with the static DelegateMethod shown previously, we now have three methods that can be wrapped by a Del instance.\nA delegate can call more than one method when invoked. This is referred to as multicasting. To add an extra method to the delegate's list of methods—the invocation list—simply requires adding two delegates using the addition or addition assignment operators ('+' or '+='). For example:\nC#\nvar obj = new MethodClass();\nDel d1 = obj.Method1;\nDel d2 = obj.Method2;\nDel d3 = DelegateMethod;\n\n//Both types of assignment are valid.\nDel allMethodsDelegate = d1 + d2;\nallMethodsDelegate += d3;"
    },
    {
        "page_index": 10,
        "chunk_index": 7,
        "text": "At this point allMethodsDelegate contains three methods in its invocation list—Method1, Method2, and DelegateMethod. The original three delegates, d1, d2, and d3, remain unchanged. When allMethodsDelegate is invoked, all three methods are called in order. If the delegate uses reference parameters, the reference is passed sequentially to each of the three methods in turn, and any changes by one method are visible to the next method. When any of the methods throws an exception that is not caught within the method, that exception is passed to the caller of the delegate and no subsequent methods in the invocation list are called. If the delegate has a return value and/or out parameters, it returns the return value and parameters of the last method invoked. To remove a method from the invocation list, use the subtraction or subtraction assignment operators (- or -=). For example:\nC#\n//remove Method1\nallMethodsDelegate -= d1;"
    },
    {
        "page_index": 10,
        "chunk_index": 8,
        "text": "// copy AllMethodsDelegate while removing d2\nDel oneMethodDelegate = allMethodsDelegate - d2;\n\nBecause delegate types are derived from System.Delegate, the methods and properties defined by that class can be called on the delegate. For example, to find the number of methods in a delegate's invocation list, you may write:\nC#\nint invocationCount = d1.GetInvocationList().GetLength(0);"
    },
    {
        "page_index": 10,
        "chunk_index": 9,
        "text": "Delegates with more than one method in their invocation list derive from MulticastDelegate, which is a subclass of System.Delegate. The above code works in either case because both classes support GetInvocationList.\nMulticast delegates are used extensively in event handling. Event source objects send event notifications to recipient objects that have registered to receive that event. To register for an event, the recipient creates a method designed to handle the event, then creates a delegate for that method and passes the delegate to the event source. The source calls the delegate when the event occurs. The delegate then calls the event handling method on the recipient, delivering the event data. The delegate type for a given event is defined by the event source. For more, see Events."
    },
    {
        "page_index": 10,
        "chunk_index": 10,
        "text": "Comparing delegates of two different types assigned at compile-time will result in a compilation error. If the delegate instances are statically of the type System.Delegate, then the comparison is allowed, but will return false at run time. For example:\nC#\ndelegate void Delegate1();\ndelegate void Delegate2();"
    },
    {
        "page_index": 10,
        "chunk_index": 11,
        "text": "static void method(Delegate1 d, Delegate2 e, System.Delegate f)\n{\n    // Compile-time error.\n    //Console.WriteLine(d == e);\n\n    // OK at compile-time. False if the run-time type of f \n    // is not the same as that of d.\n    Console.WriteLine(d == f);\n}"
    },
    {
        "page_index": 11,
        "chunk_index": 0,
        "text": "Lecture Slides: Events.pdf\n Sample Code: \n\nStockEvent.zip\nStockEvent_standard.zip\n\n Video Lectures: \nIntroduction to Events\n\nStandard Events"
    },
    {
        "page_index": 12,
        "chunk_index": 0,
        "text": "Events \nEvents enable a class or object to notify other classes or objects when something of interest occurs. The class that sends (or raises) the event is called the publisher and the classes that receive (or handle) the event are called subscribers.\nIn a typical C# Windows Forms or Web application, you subscribe to events raised by controls such as buttons and list boxes. You can use the Visual C# integrated development environment (IDE) to browse the events that a control publishes and select the ones that you want to handle. The IDE provides an easy way to automatically add an empty event handler method and the code to subscribe to the event.\nEvents Overview\nEvents have the following properties: The publisher determines when an event is raised; the subscribers determine what action is taken in response to the event. An event can have multiple subscribers. A subscriber can handle multiple events from multiple publishers. Events that have no subscribers are never raised. Events are typically used to signal user actions such as button clicks or menu selections in graphical user interfaces. When an event has multiple subscribers, the event handlers are invoked synchronously when an event is raised. To invoke events asynchronously, see Calling Synchronous Methods Asynchronously. In the .NET Framework class library, events are based on the EventHandler delegate and the EventArgs base class."
    },
    {
        "page_index": 13,
        "chunk_index": 0,
        "text": "How to subscribe to and unsubscribe from events \nYou subscribe to an event that is published by another class when you want to write custom code that is called when that event is raised. For example, you might subscribe to a button's click event in order to make your application do something useful when the user clicks the button.\nTo subscribe to events by using the Visual Studio IDE If you cannot see the Properties window, in Design view, right-click the form or control for which you want to create an event handler, and select Properties. On top of the Properties window, click the Events icon. Double-click the event that you want to create, for example the Load event.\nVisual C# creates an empty event handler method and adds it to your code. Alternatively you can add the code manually in Code view. For example, the following lines of code declare an event handler method that will be called when the Form class raises the Load event.\nC#\nprivate void Form1_Load(object sender, System.EventArgs e)\n{\n    // Add your form load event handling code here.\n}\n\nThe line of code that is required to subscribe to the event is also automatically generated in the InitializeComponent method in the Form1.Designer.cs file in your project. It resembles this:\nC#\nthis.Load += new System.EventHandler(this.Form1_Load);   To subscribe to events programmatically Define an event handler method whose signature matches the delegate signature for the event. For example, if the event is based on the EventHandler delegate type, the following code represents the method stub:\nC#\nvoid HandleCustomEvent(object sender, CustomEventArgs a)  \n{  \n   // Do something useful here.  \n}   Use the addition assignment operator (+=) to attach an event handler to the event. In the following example, assume that an object named publisher has an event named RaiseCustomEvent. Note that the subscriber class needs a reference to the publisher class in order to subscribe to its events.\nC#\npublisher.RaiseCustomEvent += HandleCustomEvent;  \n\nNote that the previous syntax is new in C# 2.0. It is exactly equivalent to the C# 1.0 syntax in which the encapsulating delegate must be explicitly created by using the new keyword:\nC#\npublisher.RaiseCustomEvent += new CustomEventHandler(HandleCustomEvent);  \n\nYou also can use a lambda expression to specify an event handler:\nC#\npublic Form1()  \n{  \n    InitializeComponent();  \n    this.Click += (s,e) =>\n        {\n            MessageBox.Show(((MouseEventArgs)e).Location.ToString());\n        };\n}   To subscribe to events by using an anonymous method If you will not have to unsubscribe to an event later, you can use the addition assignment operator (+=) to attach an anonymous method to the event. In the following example, assume that an object named publisher has an event named RaiseCustomEvent and that a CustomEventArgs class has also been defined to carry some kind of specialized event information. Note that the subscriber class needs a reference to publisher in order to subscribe to its events.\nC#\npublisher.RaiseCustomEvent += delegate(object o, CustomEventArgs e)  \n{  \n  string s = o.ToString() + \" \" + e.ToString();  \n  Console.WriteLine(s);  \n};  \n\nIt is important to notice that you cannot easily unsubscribe from an event if you used an anonymous function to subscribe to it. To unsubscribe in this scenario, it is necessary to go back to the code where you subscribe to the event, store the anonymous method in a delegate variable, and then add the delegate to the event. In general, we recommend that you do not use anonymous functions to subscribe to events if you will have to unsubscribe from the event at some later point in your code. For more information about anonymous functions, see Anonymous Functions. Unsubscribing\nTo prevent your event handler from being invoked when the event is raised, unsubscribe from the event. In order to prevent resource leaks, you should unsubscribe from events before you dispose of a subscriber object. Until you unsubscribe from an event, the multicast delegate that underlies the event in the publishing object has a reference to the delegate that encapsulates the subscriber's event handler. As long as the publishing object holds that reference, garbage collection will not delete your subscriber object.\nTo unsubscribe from an event Use the subtraction assignment operator (-=) to unsubscribe from an event:\nC#\npublisher.RaiseCustomEvent -= HandleCustomEvent;  \n\nWhen all subscribers have unsubscribed from an event, the event instance in the publisher class is set to null."
    },
    {
        "page_index": 14,
        "chunk_index": 0,
        "text": "M6 Objectives\nAfter completing this week's work, you will be able to:\n\nReview Exception Handling in Module 4.\nUnderstand what exceptions are and how they’re handled.\nHandle exceptions by using the try, catch, and finally statements\nUnderstand the .NET exception class hierarchy.\nDesign and develop an interactive user interface with WPF with code behind\n\n \n M6 Activities \n\nWatch Video Lectures\nRead Lecture Slides & Programming Guide,\nPractice with Sample Code\nComplete M6  Quiz and Assignment"
    },
    {
        "page_index": 15,
        "chunk_index": 0,
        "text": "Lecture Slides: Class Library (use your University credential to access)\nSample Code: ClassLibraryProject\nTutorial : Create a .NET class library using Visual Studio"
    },
    {
        "page_index": 16,
        "chunk_index": 0,
        "text": "Lecture Slides: How to Document your Classes (use your University credential to access doc on Google Drive through MU)\nRef: Recommended XML tags for C# documentation comments"
    },
    {
        "page_index": 17,
        "chunk_index": 0,
        "text": "Sample Code:  MathsOperators.zip\n Video Lectures:"
    },
    {
        "page_index": 18,
        "chunk_index": 0,
        "text": "Video Lectures: \nA review of M5 Challenge:  Data & Time Picker"
    },
    {
        "page_index": 19,
        "chunk_index": 0,
        "text": "M5 Objectives\n\nAfter completing this week's work, you will be able to:\n\nIllustrate different WPF layout controls (size, position, transform, margin, padding)\nDescribe commonly used WPF user interface elements\nExplain the relationship between UI and code behind\nDesign and develop an interactive user interface with WPF with code behind\n\n \n\n M5 Activities  Watch Video Lectures\nRead Lecture Slides & Programming Guide,\nPractice with Sample Code\nComplete M5 Quiz and Assignment"
    },
    {
        "page_index": 20,
        "chunk_index": 0,
        "text": "Lecture Slides: IntroWPF.pdf"
    },
    {
        "page_index": 21,
        "chunk_index": 0,
        "text": "WPF overview\nWindows Presentation Foundation (WPF) lets you create desktop client applications for Windows with visually stunning user experiences.\nThe core of WPF is a resolution-independent and vector-based rendering engine that is built to take advantage of modern graphics hardware. WPF extends the core with a comprehensive set of application-development features that include Extensible Application Markup Language (XAML), controls, data binding, layout, 2D and 3D graphics, animation, styles, templates, documents, media, text, and typography. WPF is part of .NET, so you can build applications that incorporate other elements of the .NET API.\nThis overview is intended for newcomers and covers the key capabilities and concepts of WPF.\nProgram with WPF"
    },
    {
        "page_index": 21,
        "chunk_index": 1,
        "text": "Program with WPF\nWPF exists as a subset of .NET types that are (for the most part) located in the System.Windows namespace. If you have previously built applications with .NET using managed technologies like ASP.NET and Windows Forms, the fundamental WPF programming experience should be familiar; you instantiate classes, set properties, call methods, and handle events, using your favorite .NET programming language, such as C# or Visual Basic.\nWPF includes additional programming constructs that enhance properties and events: dependency properties and routed events.\nMarkup and code-behind"
    },
    {
        "page_index": 21,
        "chunk_index": 2,
        "text": "Markup and code-behind\nWPF lets you develop an application using both markup and code-behind, an experience with which ASP.NET developers should be familiar. You generally use XAML markup to implement the appearance of an application while using managed programming languages (code-behind) to implement its behavior. This separation of appearance and behavior has the following benefits: Development and maintenance costs are reduced because appearance-specific markup is not tightly coupled with behavior-specific code. Development is more efficient because designers can implement an application's appearance simultaneously with developers who are implementing the application's behavior. Globalization and localization for WPF applications is simplified. Markup\nXAML is an XML-based markup language that implements an application's appearance declaratively. You typically use it to create windows, dialog boxes, pages, and user controls, and to fill them with controls, shapes, and graphics."
    },
    {
        "page_index": 21,
        "chunk_index": 3,
        "text": "The following example uses XAML to implement the appearance of a window that contains a single button:\nXAML\n<Window\n    xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n    Title=\"Window with Button\"\n    Width=\"250\" Height=\"100\">"
    },
    {
        "page_index": 21,
        "chunk_index": 4,
        "text": "<!-- Add button to window -->\n  <Button Name=\"button\">Click Me!</Button>\n\n</Window>\n\nSpecifically, this XAML defines a window and a button by using the Window and Button elements, respectively. Each element is configured with attributes, such as the Window element's Title attribute to specify the window's title-bar text. At run time, WPF converts the elements and attributes that are defined in markup to instances of WPF classes. For example, the Window element is converted to an instance of the Window class whose Title property is the value of the Title attribute.\nThe following figure shows the user interface (UI) that is defined by the XAML in the previous example:"
    },
    {
        "page_index": 21,
        "chunk_index": 5,
        "text": "Since XAML is XML-based, the UI that you compose with it is assembled in a hierarchy of nested elements known as an element tree. The element tree provides a logical and intuitive way to create and manage UIs.\nCode-behind\nThe main behavior of an application is to implement the functionality that responds to user interactions, including handling events (for example, clicking a menu, tool bar, or button) and calling business logic and data access logic in response. In WPF, this behavior is implemented in code that is associated with markup. This type of code is known as code-behind. The following example shows the updated markup from the previous example and the code-behind:\nXAML\n<Window\n    xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n    xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n    x:Class=\"SDKSample.AWindow\"\n    Title=\"Window with Button\"\n    Width=\"250\" Height=\"100\">"
    },
    {
        "page_index": 21,
        "chunk_index": 6,
        "text": "<!-- Add button to window -->\n  <Button Name=\"button\" Click=\"button_Click\">Click Me!</Button>\n\n</Window>\n\nC#\nusing System.Windows; // Window, RoutedEventArgs, MessageBox \n\nnamespace SDKSample\n{\n    public partial class AWindow : Window\n    {\n        public AWindow()\n        {\n            // InitializeComponent call is required to merge the UI \n            // that is defined in markup with this class, including  \n            // setting properties and registering event handlers\n            InitializeComponent();\n        }\n\n        void button_Click(object sender, RoutedEventArgs e)\n        {\n            // Show message box when button is clicked.\n            MessageBox.Show(\"Hello, Windows Presentation Foundation!\");\n        }\n    }\n}"
    },
    {
        "page_index": 21,
        "chunk_index": 7,
        "text": "In this example, the code-behind implements a class that derives from the Window class. The x:Class attribute is used to associate the markup with the code-behind class. InitializeComponent is called from the code-behind class's constructor to merge the UI that is defined in markup with the code-behind class. (InitializeComponent is generated for you when your application is built, which is why you don't need to implement it manually.) The combination of x:Class and InitializeComponent ensure that your implementation is correctly initialized whenever it is created. The code-behind class also implements an event handler for the button's Click event. When the button is clicked, the event handler shows a message box by calling the System.Windows.MessageBox.Show method.\nThe following figure shows the result when the button is clicked:"
    },
    {
        "page_index": 22,
        "chunk_index": 0,
        "text": "Lecture Slides: LayoutChildren.pdf\n Video Lectures: \n\nWPF Layout Margin & Padding  \n    2. WPF Layout Alignment & Transform"
    },
    {
        "page_index": 23,
        "chunk_index": 0,
        "text": "Alignment, Margins, and Padding Overview\nThe FrameworkElement class exposes several properties that are used to precisely position child elements. This topic discusses four of the most important properties: HorizontalAlignment, Margin, Padding, and VerticalAlignment. The effects of these properties are important to understand, because they provide the basis for controlling the position of elements in Windows Presentation Foundation (WPF) applications.\nIntroduction to Element Positioning\nThere are numerous ways to position elements using WPF. However, achieving ideal layout goes beyond simply choosing the right Panel element. Fine control of positioning requires an understanding of the HorizontalAlignment, Margin, Padding, and VerticalAlignment properties.\nThe following illustration shows a layout scenario that utilizes several positioning properties."
    },
    {
        "page_index": 23,
        "chunk_index": 1,
        "text": "At first glance, the Button elements in this illustration may appear to be placed randomly. However, their positions are actually precisely controlled by using a combination of margins, alignments, and padding.\nThe following example describes how to create the layout in the preceding illustration. A Border element encapsulates a parent StackPanel, with a Padding value of 15 device independent pixels. This accounts for the narrow LightBlue band that surrounds the child StackPanel. Child elements of the StackPanel are used to illustrate each of the various positioning properties that are detailed in this topic. Three Button elements are used to demonstrate both the Margin and HorizontalAlignment properties.\nC#\n\n// Create the application's main Window.\nmainWindow = new Window ();\nmainWindow.Title = \"Margins, Padding and Alignment Sample\";"
    },
    {
        "page_index": 23,
        "chunk_index": 2,
        "text": "// Add a Border\nmyBorder = new Border();\nmyBorder.Background = Brushes.LightBlue;\nmyBorder.BorderBrush = Brushes.Black;\nmyBorder.Padding = new Thickness(15);\nmyBorder.BorderThickness = new Thickness(2);\n\nmyStackPanel = new StackPanel();\nmyStackPanel.Background = Brushes.White;\nmyStackPanel.HorizontalAlignment = HorizontalAlignment.Center;\nmyStackPanel.VerticalAlignment = VerticalAlignment.Top;"
    },
    {
        "page_index": 23,
        "chunk_index": 3,
        "text": "TextBlock myTextBlock = new TextBlock();\nmyTextBlock.Margin = new Thickness(5, 0, 5, 0);\nmyTextBlock.FontSize = 18;\nmyTextBlock.HorizontalAlignment = HorizontalAlignment.Center;\nmyTextBlock.Text = \"Alignment, Margin and Padding Sample\";\nButton myButton1 = new Button();\nmyButton1.HorizontalAlignment = HorizontalAlignment.Left;\nmyButton1.Margin = new Thickness(20);\nmyButton1.Content = \"Button 1\";\nButton myButton2 = new Button();\nmyButton2.HorizontalAlignment = HorizontalAlignment.Right;\nmyButton2.Margin = new Thickness(10);\nmyButton2.Content = \"Button 2\";\nButton myButton3 = new Button();\nmyButton3.HorizontalAlignment = HorizontalAlignment.Stretch;\nmyButton3.Margin = new Thickness(0);\nmyButton3.Content = \"Button 3\";\n\n// Add child elements to the parent StackPanel.\nmyStackPanel.Children.Add(myTextBlock);\nmyStackPanel.Children.Add(myButton1);\nmyStackPanel.Children.Add(myButton2);\nmyStackPanel.Children.Add(myButton3);"
    },
    {
        "page_index": 23,
        "chunk_index": 4,
        "text": "// Add the StackPanel as the lone Child of the Border.\nmyBorder.Child = myStackPanel;\n\n// Add the Border as the Content of the Parent Window Object.\nmainWindow.Content = myBorder;\nmainWindow.Show (); The following diagram provides a close-up view of the various positioning properties that are used in the preceding sample. Subsequent sections in this topic describe in greater detail how to use each positioning property.\n\n \nUnderstanding Alignment Properties\nThe HorizontalAlignment and VerticalAlignment properties describe how a child element should be positioned within a parent element's allocated layout space. By using these properties together, you can position child elements precisely. For example, child elements of a DockPanel can specify four different horizontal alignments: Left, Right, or Center, or to Stretch to fill available space. Similar values are available for vertical positioning."
    },
    {
        "page_index": 23,
        "chunk_index": 5,
        "text": "Note\nExplicitly-set Height and Width properties on an element take precedence over the Stretch property value. Attempting to set Height, Width, and a HorizontalAlignment value of Stretch results in the Stretch request being ignored."
    },
    {
        "page_index": 23,
        "chunk_index": 6,
        "text": "HorizontalAlignment Property\nThe HorizontalAlignment property declares the horizontal alignment characteristics to apply to child elements. The following table shows each of the possible values of the HorizontalAlignment property. Member\nDescription Left\nChild elements are aligned to the left of the parent element's allocated layout space. Center\nChild elements are aligned to the center of the parent element's allocated layout space. Right\nChild elements are aligned to the right of the parent element's allocated layout space. Stretch (Default)\nChild elements are stretched to fill the parent element's allocated layout space. Explicit Width and Height values take precedence. The following example shows how to apply the HorizontalAlignment property to Button elements. Each attribute value is shown, to better illustrate the various rendering behaviors.\nC#\nButton myButton1 = new Button();\nmyButton1.HorizontalAlignment = HorizontalAlignment.Left;\nmyButton1.Content = \"Button 1 (Left)\";"
    },
    {
        "page_index": 23,
        "chunk_index": 7,
        "text": "myButton1.Content = \"Button 1 (Left)\";\nButton myButton2 = new Button();\nmyButton2.HorizontalAlignment = HorizontalAlignment.Right;\nmyButton2.Content = \"Button 2 (Right)\";\nButton myButton3 = new Button();\nmyButton3.HorizontalAlignment = HorizontalAlignment.Center;\nmyButton3.Content = \"Button 3 (Center)\";\nButton myButton4 = new Button();\nmyButton4.HorizontalAlignment = HorizontalAlignment.Stretch;\nmyButton4.Content = \"Button 4 (Stretch)\";"
    },
    {
        "page_index": 23,
        "chunk_index": 8,
        "text": "The preceding code yields a layout similar to the following image. The positioning effects of each HorizontalAlignment value are visible in the illustration."
    },
    {
        "page_index": 23,
        "chunk_index": 9,
        "text": "VerticalAlignment Property\nThe VerticalAlignment property describes the vertical alignment characteristics to apply to child elements. The following table shows each of the possible values for the VerticalAlignment property. Member\nDescription Top\nChild elements are aligned to the top of the parent element's allocated layout space. Center\nChild elements are aligned to the center of the parent element's allocated layout space. Bottom\nChild elements are aligned to the bottom of the parent element's allocated layout space. Stretch (Default)"
    },
    {
        "page_index": 23,
        "chunk_index": 10,
        "text": "Child elements are stretched to fill the parent element's allocated layout space. Explicit Width and Height values take precedence. The following example shows how to apply the VerticalAlignment property to Button elements. Each attribute value is shown, to better illustrate the various rendering behaviors. For purposes of this sample, a Grid element with visible gridlines is used as the parent, to better illustrate the layout behavior of each property value.\nC#\nTextBlock myTextBlock = new TextBlock();\nmyTextBlock.FontSize = 18;\nmyTextBlock.HorizontalAlignment = HorizontalAlignment.Center;\nmyTextBlock.Text = \"VerticalAlignment Sample\";\nGrid.SetRow(myTextBlock, 0);\nButton myButton1 = new Button();\nmyButton1.VerticalAlignment = VerticalAlignment.Top;\nmyButton1.Content = \"Button 1 (Top)\";\nGrid.SetRow(myButton1, 1);\nButton myButton2 = new Button();\nmyButton2.VerticalAlignment = VerticalAlignment.Bottom;\nmyButton2.Content = \"Button 2 (Bottom)\";\nGrid.SetRow(myButton2, 2);"
    },
    {
        "page_index": 23,
        "chunk_index": 11,
        "text": "Grid.SetRow(myButton2, 2);\nButton myButton3 = new Button();\nmyButton3.VerticalAlignment = VerticalAlignment.Center;\nmyButton3.Content = \"Button 3 (Center)\";\nGrid.SetRow(myButton3, 3);\nButton myButton4 = new Button();\nmyButton4.VerticalAlignment = VerticalAlignment.Stretch;\nmyButton4.Content = \"Button 4 (Stretch)\";\nGrid.SetRow(myButton4, 4); XAMLCopy\n<Page xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" \n      xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n      WindowTitle=\"VerticalAlignment Sample\">\n  <Border Background=\"LightBlue\" BorderBrush=\"Black\" BorderThickness=\"2\" Padding=\"15\">\n    <Grid Background=\"White\" ShowGridLines=\"True\">\n      <Grid.RowDefinitions>\n        <RowDefinition Height=\"25\"/>\n        <RowDefinition Height=\"50\"/>\n        <RowDefinition Height=\"50\"/>\n        <RowDefinition Height=\"50\"/>\n        <RowDefinition Height=\"50\"/>\n      </Grid.RowDefinitions>"
    },
    {
        "page_index": 23,
        "chunk_index": 12,
        "text": "</Grid.RowDefinitions>\n            <TextBlock Grid.Row=\"0\" Grid.Column=\"0\" FontSize=\"18\" HorizontalAlignment=\"Center\">VerticalAlignment Sample</TextBlock>\n            <Button Grid.Row=\"1\" Grid.Column=\"0\" VerticalAlignment=\"Top\">Button 1 (Top)</Button>\n            <Button Grid.Row=\"2\" Grid.Column=\"0\" VerticalAlignment=\"Bottom\">Button 2 (Bottom)</Button>    \n            <Button Grid.Row=\"3\" Grid.Column=\"0\" VerticalAlignment=\"Center\">Button 3 (Center)</Button>\n            <Button Grid.Row=\"4\" Grid.Column=\"0\" VerticalAlignment=\"Stretch\">Button 4 (Stretch)</Button>          \n    </Grid>\n  </Border>    \n</Page>"
    },
    {
        "page_index": 23,
        "chunk_index": 13,
        "text": "The preceding code yields a layout similar to the following image. The positioning effects of each VerticalAlignment value are visible in the illustration. Understanding Margin Properties\nThe Margin property describes the distance between an element and its child or peers. Margin values can be uniform, by using syntax like Margin=\"20\". With this syntax, a uniform Margin of 20 device independent pixels would be applied to the element. Margin values can also take the form of four distinct values, each value describing a distinct margin to apply to the left, top, right, and bottom (in that order), like Margin=\"0,10,5,25\". Proper use of the Margin property enables very fine control of an element's rendering position and the rendering position of its neighbor elements and children.\n\n Note\nA non-zero margin applies space outside the element's ActualWidth and ActualHeight."
    },
    {
        "page_index": 23,
        "chunk_index": 14,
        "text": "The following example shows how to apply uniform margins around a group of Button elements. The Button elements are spaced evenly with a ten-pixel margin buffer in each direction.\nC#\nButton myButton7 = new Button();\nmyButton7.Margin = new Thickness(10);\nmyButton7.Content = \"Button 7\";\nButton myButton8 = new Button();\nmyButton8.Margin = new Thickness(10);\nmyButton8.Content = \"Button 8\";\nButton myButton9 = new Button();\nmyButton9.Margin = new Thickness(10);\nmyButton9.Content = \"Button 9\";\n\nXAML\n<Button Margin=\"10\">Button 7</Button>\n<Button Margin=\"10\">Button 8</Button>\n<Button Margin=\"10\">Button 9</Button>"
    },
    {
        "page_index": 23,
        "chunk_index": 15,
        "text": "In many instances, a uniform margin is not appropriate. In these cases, non-uniform spacing can be applied. The following example shows how to apply non-uniform margin spacing to child elements. Margins are described in this order: left, top, right, bottom.\nC#\nButton myButton1 = new Button();\nmyButton1.Margin = new Thickness(0, 10, 0, 10);\nmyButton1.Content = \"Button 1\";\nButton myButton2 = new Button();\nmyButton2.Margin = new Thickness(0, 10, 0, 10);\nmyButton2.Content = \"Button 2\";\nButton myButton3 = new Button();\nmyButton3.Margin = new Thickness(0, 10, 0, 10);\n\nXAML\n<Button Margin=\"0,10,0,10\">Button 1</Button>\n<Button Margin=\"0,10,0,10\">Button 2</Button>\n<Button Margin=\"0,10,0,10\">Button 3</Button>"
    },
    {
        "page_index": 23,
        "chunk_index": 16,
        "text": "Understanding the Padding Property\nPadding is similar to Margin in most respects. The Padding property is exposed on only on a few classes, primarily as a convenience: Block, Border, Control, and TextBlock are samples of classes that expose a Padding property. The Padding property enlarges the effective size of a child element by the specified Thickness value.\nThe following example shows how to apply Padding to a parent Border element.\nC#\nmyBorder = new Border();\nmyBorder.Background = Brushes.LightBlue;\nmyBorder.BorderBrush = Brushes.Black;\nmyBorder.BorderThickness = new Thickness(2);\nmyBorder.CornerRadius = new CornerRadius(45);\nmyBorder.Padding = new Thickness(25);\n\nXAML\n<Border Background=\"LightBlue\" \n        BorderBrush=\"Black\" \n        BorderThickness=\"2\" \n        CornerRadius=\"45\" \n        Padding=\"25\">"
    },
    {
        "page_index": 23,
        "chunk_index": 17,
        "text": "Using Alignment, Margins, and Padding in an Application\nHorizontalAlignment, Margin, Padding, and VerticalAlignment provide the positioning control necessary to create a complex user interface (UI). You can use the effects of each property to change child-element positioning, enabling flexibility in creating dynamic applications and user experiences.\nThe following example demonstrates each of the concepts that are detailed in this topic. Building on the infrastructure found in the first sample in this topic, this example adds a Grid element as a child of the Border in the first sample. Padding is applied to the parent Border element. The Grid is used to partition space between three child StackPanel elements. Button elements are again used to show the various effects of Margin and HorizontalAlignment. TextBlock elements are added to each ColumnDefinition to better define the various properties applied to the Button elements in each column.\nC#\nmainWindow = new Window();"
    },
    {
        "page_index": 23,
        "chunk_index": 18,
        "text": "myBorder = new Border();\nmyBorder.Background = Brushes.LightBlue;\nmyBorder.BorderBrush = Brushes.Black;\nmyBorder.BorderThickness = new Thickness(2);\nmyBorder.CornerRadius = new CornerRadius(45);\nmyBorder.Padding = new Thickness(25);\n\n// Define the Grid.\nmyGrid = new Grid();\nmyGrid.Background = Brushes.White;\nmyGrid.ShowGridLines = true;\n\n// Define the Columns.\nColumnDefinition myColDef1 = new ColumnDefinition();\nmyColDef1.Width = new GridLength(1, GridUnitType.Auto);\nColumnDefinition myColDef2 = new ColumnDefinition();\nmyColDef2.Width = new GridLength(1, GridUnitType.Star);\nColumnDefinition myColDef3 = new ColumnDefinition();\nmyColDef3.Width = new GridLength(1, GridUnitType.Auto);\n\n// Add the ColumnDefinitions to the Grid.\nmyGrid.ColumnDefinitions.Add(myColDef1);\nmyGrid.ColumnDefinitions.Add(myColDef2);\nmyGrid.ColumnDefinitions.Add(myColDef3);"
    },
    {
        "page_index": 23,
        "chunk_index": 19,
        "text": "// Add the first child StackPanel.\nStackPanel myStackPanel = new StackPanel();\nmyStackPanel.HorizontalAlignment = HorizontalAlignment.Left;\nmyStackPanel.VerticalAlignment = VerticalAlignment.Top;\nGrid.SetColumn(myStackPanel, 0);\nGrid.SetRow(myStackPanel, 0);\nTextBlock myTextBlock1 = new TextBlock();\nmyTextBlock1.FontSize = 18;\nmyTextBlock1.HorizontalAlignment = HorizontalAlignment.Center;\nmyTextBlock1.Margin = new Thickness(0, 0, 0, 15);\nmyTextBlock1.Text = \"StackPanel 1\";\nButton myButton1 = new Button();\nmyButton1.Margin = new Thickness(0, 10, 0, 10);\nmyButton1.Content = \"Button 1\";\nButton myButton2 = new Button();\nmyButton2.Margin = new Thickness(0, 10, 0, 10);\nmyButton2.Content = \"Button 2\";\nButton myButton3 = new Button();\nmyButton3.Margin = new Thickness(0, 10, 0, 10);\nTextBlock myTextBlock2 = new TextBlock();\nmyTextBlock2.Text = @\"ColumnDefinition.Width = \"\"Auto\"\"\";\nTextBlock myTextBlock3 = new TextBlock();\nmyTextBlock3.Text = @\"StackPanel.HorizontalAlignment = \"\"Left\"\"\";"
    },
    {
        "page_index": 23,
        "chunk_index": 20,
        "text": "TextBlock myTextBlock4 = new TextBlock();\nmyTextBlock4.Text = @\"StackPanel.VerticalAlignment = \"\"Top\"\"\";\nTextBlock myTextBlock5 = new TextBlock();\nmyTextBlock5.Text = @\"StackPanel.Orientation = \"\"Vertical\"\"\";\nTextBlock myTextBlock6 = new TextBlock();\nmyTextBlock6.Text = @\"Button.Margin = \"\"1,10,0,10\"\"\";\nmyStackPanel.Children.Add(myTextBlock1);\nmyStackPanel.Children.Add(myButton1);\nmyStackPanel.Children.Add(myButton2);\nmyStackPanel.Children.Add(myButton3);\nmyStackPanel.Children.Add(myTextBlock2);\nmyStackPanel.Children.Add(myTextBlock3);\nmyStackPanel.Children.Add(myTextBlock4);\nmyStackPanel.Children.Add(myTextBlock5);\nmyStackPanel.Children.Add(myTextBlock6);"
    },
    {
        "page_index": 23,
        "chunk_index": 21,
        "text": "// Add the second child StackPanel.\nStackPanel myStackPanel2 = new StackPanel();\nmyStackPanel2.HorizontalAlignment = HorizontalAlignment.Stretch;\nmyStackPanel2.VerticalAlignment = VerticalAlignment.Top;\nmyStackPanel2.Orientation = Orientation.Vertical;\nGrid.SetColumn(myStackPanel2, 1);\nGrid.SetRow(myStackPanel2, 0);\nTextBlock myTextBlock7 = new TextBlock();\nmyTextBlock7.FontSize = 18;\nmyTextBlock7.HorizontalAlignment = HorizontalAlignment.Center;\nmyTextBlock7.Margin = new Thickness(0, 0, 0, 15);\nmyTextBlock7.Text = \"StackPanel 2\";\nButton myButton4 = new Button();\nmyButton4.Margin = new Thickness(10, 0, 10, 0);\nmyButton4.Content = \"Button 4\";\nButton myButton5 = new Button();\nmyButton5.Margin = new Thickness(10, 0, 10, 0);\nmyButton5.Content = \"Button 5\";\nButton myButton6 = new Button();\nmyButton6.Margin = new Thickness(10, 0, 10, 0);\nmyButton6.Content = \"Button 6\";\nTextBlock myTextBlock8 = new TextBlock();\nmyTextBlock8.HorizontalAlignment = HorizontalAlignment.Center;"
    },
    {
        "page_index": 23,
        "chunk_index": 22,
        "text": "myTextBlock8.Text = @\"ColumnDefinition.Width = \"\"*\"\"\";\nTextBlock myTextBlock9 = new TextBlock();\nmyTextBlock9.HorizontalAlignment = HorizontalAlignment.Center;\nmyTextBlock9.Text = @\"StackPanel.HorizontalAlignment = \"\"Stretch\"\"\";\nTextBlock myTextBlock10 = new TextBlock();\nmyTextBlock10.HorizontalAlignment = HorizontalAlignment.Center;\nmyTextBlock10.Text = @\"StackPanel.VerticalAlignment = \"\"Top\"\"\";\nTextBlock myTextBlock11 = new TextBlock();\nmyTextBlock11.HorizontalAlignment = HorizontalAlignment.Center;\nmyTextBlock11.Text = @\"StackPanel.Orientation = \"\"Horizontal\"\"\";\nTextBlock myTextBlock12 = new TextBlock();\nmyTextBlock12.HorizontalAlignment = HorizontalAlignment.Center;\nmyTextBlock12.Text = @\"Button.Margin = \"\"10,0,10,0\"\"\";\nmyStackPanel2.Children.Add(myTextBlock7);\nmyStackPanel2.Children.Add(myButton4);\nmyStackPanel2.Children.Add(myButton5);\nmyStackPanel2.Children.Add(myButton6);\nmyStackPanel2.Children.Add(myTextBlock8);\nmyStackPanel2.Children.Add(myTextBlock9);"
    },
    {
        "page_index": 23,
        "chunk_index": 23,
        "text": "myStackPanel2.Children.Add(myTextBlock9);\nmyStackPanel2.Children.Add(myTextBlock10);\nmyStackPanel2.Children.Add(myTextBlock11);\nmyStackPanel2.Children.Add(myTextBlock12);"
    },
    {
        "page_index": 23,
        "chunk_index": 24,
        "text": "// Add the final child StackPanel.\nStackPanel myStackPanel3 = new StackPanel();\nmyStackPanel3.HorizontalAlignment = HorizontalAlignment.Left;\nmyStackPanel3.VerticalAlignment = VerticalAlignment.Top;\nGrid.SetColumn(myStackPanel3, 2);\nGrid.SetRow(myStackPanel3, 0);\nTextBlock myTextBlock13 = new TextBlock();\nmyTextBlock13.FontSize = 18;\nmyTextBlock13.HorizontalAlignment = HorizontalAlignment.Center;\nmyTextBlock13.Margin = new Thickness(0, 0, 0, 15);\nmyTextBlock13.Text = \"StackPanel 3\";\nButton myButton7 = new Button();\nmyButton7.Margin = new Thickness(10);\nmyButton7.Content = \"Button 7\";\nButton myButton8 = new Button();\nmyButton8.Margin = new Thickness(10);\nmyButton8.Content = \"Button 8\";\nButton myButton9 = new Button();\nmyButton9.Margin = new Thickness(10);\nmyButton9.Content = \"Button 9\";\nTextBlock myTextBlock14 = new TextBlock();\nmyTextBlock14.Text = @\"ColumnDefinition.Width = \"\"Auto\"\"\";\nTextBlock myTextBlock15 = new TextBlock();"
    },
    {
        "page_index": 23,
        "chunk_index": 25,
        "text": "TextBlock myTextBlock15 = new TextBlock();\nmyTextBlock15.Text = @\"StackPanel.HorizontalAlignment = \"\"Left\"\"\";\nTextBlock myTextBlock16 = new TextBlock();\nmyTextBlock16.Text = @\"StackPanel.VerticalAlignment = \"\"Top\"\"\";\nTextBlock myTextBlock17 = new TextBlock();\nmyTextBlock17.Text = @\"StackPanel.Orientation = \"\"Vertical\"\"\";\nTextBlock myTextBlock18 = new TextBlock();\nmyTextBlock18.Text = @\"Button.Margin = \"\"10\"\"\";\nmyStackPanel3.Children.Add(myTextBlock13);\nmyStackPanel3.Children.Add(myButton7);\nmyStackPanel3.Children.Add(myButton8);\nmyStackPanel3.Children.Add(myButton9);\nmyStackPanel3.Children.Add(myTextBlock14);\nmyStackPanel3.Children.Add(myTextBlock15);\nmyStackPanel3.Children.Add(myTextBlock16);\nmyStackPanel3.Children.Add(myTextBlock17);\nmyStackPanel3.Children.Add(myTextBlock18);"
    },
    {
        "page_index": 23,
        "chunk_index": 26,
        "text": "// Add child content to the parent Grid.\nmyGrid.Children.Add(myStackPanel);\nmyGrid.Children.Add(myStackPanel2);\nmyGrid.Children.Add(myStackPanel3);\n\n// Add the Grid as the lone child of the Border.\nmyBorder.Child = myGrid;\n\n// Add the Border to the Window as Content and show the Window.\nmainWindow.Content = myBorder;\nmainWindow.Title = \"Margin, Padding, and Alignment Sample\";\nmainWindow.Show();"
    },
    {
        "page_index": 23,
        "chunk_index": 27,
        "text": "XAML\n<Page xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" WindowTitle=\"Margins, Padding and Alignment Sample\">\n  <Border Background=\"LightBlue\" \n          BorderBrush=\"Black\" \n          BorderThickness=\"2\" \n          CornerRadius=\"45\" \n          Padding=\"25\">\n    <Grid Background=\"White\" ShowGridLines=\"True\">\n      <Grid.ColumnDefinitions>\n        <ColumnDefinition Width=\"Auto\"/>\n        <ColumnDefinition Width=\"*\"/>\n        <ColumnDefinition Width=\"Auto\"/>\n      </Grid.ColumnDefinitions>\n        \n    <StackPanel Grid.Column=\"0\" Grid.Row=\"0\" HorizontalAlignment=\"Left\" Name=\"StackPanel1\" VerticalAlignment=\"Top\">\n        <TextBlock FontSize=\"18\" HorizontalAlignment=\"Center\" Margin=\"0,0,0,15\">StackPanel1</TextBlock>\n        <Button Margin=\"0,10,0,10\">Button 1</Button>\n        <Button Margin=\"0,10,0,10\">Button 2</Button>\n        <Button Margin=\"0,10,0,10\">Button 3</Button>\n        <TextBlock>ColumnDefinition.Width=\"Auto\"</TextBlock>"
    },
    {
        "page_index": 23,
        "chunk_index": 28,
        "text": "<TextBlock>StackPanel.HorizontalAlignment=\"Left\"</TextBlock>\n        <TextBlock>StackPanel.VerticalAlignment=\"Top\"</TextBlock>\n        <TextBlock>StackPanel.Orientation=\"Vertical\"</TextBlock>\n        <TextBlock>Button.Margin=\"0,10,0,10\"</TextBlock>\n    </StackPanel>\n    \n    <StackPanel Grid.Column=\"1\" Grid.Row=\"0\" HorizontalAlignment=\"Stretch\" Name=\"StackPanel2\" VerticalAlignment=\"Top\" Orientation=\"Vertical\">\n        <TextBlock FontSize=\"18\" HorizontalAlignment=\"Center\" Margin=\"0,0,0,15\">StackPanel2</TextBlock>\n        <Button Margin=\"10,0,10,0\">Button 4</Button>\n        <Button Margin=\"10,0,10,0\">Button 5</Button>\n        <Button Margin=\"10,0,10,0\">Button 6</Button>\n        <TextBlock HorizontalAlignment=\"Center\">ColumnDefinition.Width=\"*\"</TextBlock>\n        <TextBlock HorizontalAlignment=\"Center\">StackPanel.HorizontalAlignment=\"Stretch\"</TextBlock>\n        <TextBlock HorizontalAlignment=\"Center\">StackPanel.VerticalAlignment=\"Top\"</TextBlock>"
    },
    {
        "page_index": 23,
        "chunk_index": 29,
        "text": "<TextBlock HorizontalAlignment=\"Center\">StackPanel.Orientation=\"Horizontal\"</TextBlock>\n        <TextBlock HorizontalAlignment=\"Center\">Button.Margin=\"10,0,10,0\"</TextBlock>\n    </StackPanel>        \n        \n    <StackPanel Grid.Column=\"2\" Grid.Row=\"0\" HorizontalAlignment=\"Left\" Name=\"StackPanel3\" VerticalAlignment=\"Top\">\n        <TextBlock FontSize=\"18\" HorizontalAlignment=\"Center\" Margin=\"0,0,0,15\">StackPanel3</TextBlock>\n        <Button Margin=\"10\">Button 7</Button>\n        <Button Margin=\"10\">Button 8</Button>\n        <Button Margin=\"10\">Button 9</Button>\n        <TextBlock>ColumnDefinition.Width=\"Auto\"</TextBlock>\n        <TextBlock>StackPanel.HorizontalAlignment=\"Left\"</TextBlock>\n        <TextBlock>StackPanel.VerticalAlignment=\"Top\"</TextBlock>\n        <TextBlock>StackPanel.Orientation=\"Vertical\"</TextBlock>\n        <TextBlock>Button.Margin=\"10\"</TextBlock>      \n    </StackPanel>\n  </Grid>\n  </Border>    \n</Page>"
    },
    {
        "page_index": 23,
        "chunk_index": 30,
        "text": "When compiled, the preceding application yields a UI that looks like the following illustration. The effects of the various property values are evident in the spacing between elements, and significant property values for elements in each column are shown within TextBlock elements."
    },
    {
        "page_index": 24,
        "chunk_index": 0,
        "text": "Lecture Slides: LayoutPanels.pdf\n Recommended Online Resources:\n*Note: these youtube videos are WPF with VB not C#. But XAML and WPF related information are still very useful.\nThe Grid\nStack Panel\nDock Panel"
    },
    {
        "page_index": 25,
        "chunk_index": 0,
        "text": "Panels Overview\nPanel elements are components that control the rendering of elements—their size and dimensions, their position, and the arrangement of their child content. The Windows Presentation Foundation (WPF) provides a number of predefined Panel elements as well as the ability to construct custom Panel elements.\nThe Panel Class\nPanel is the base class for all elements that provide layout support in Windows Presentation Foundation (WPF). Derived Panel elements are used to position and arrange elements in Extensible Application Markup Language (XAML) and code.\nThe WPF includes a comprehensive suite of derived panel implementations that enable many complex layouts. These derived classes expose properties and methods that enable most standard user interface (UI) scenarios. Developers who are unable to find a child arrangement behavior that meets their needs can create new layouts by overriding the ArrangeOverride and MeasureOverride methods. For more information on custom layout behaviors, see Custom Panel Elements.\n\nPanel Common Members\nAll Panel elements support the base sizing and positioning properties defined by FrameworkElement, including Height, Width, HorizontalAlignment, VerticalAlignment, Margin, and LayoutTransform. For additional information on positioning properties defined by FrameworkElement, see Alignment, Margins, and Padding Overview.\nPanel exposes additional properties that are of critical importance in understanding and using layout. The Background property is used to fill the area between the boundaries of a derived panel element with a Brush. Children represents the child collection of elements that the Panel is comprised of. InternalChildren represents the content of the Children collection plus those members generated by data binding. Both consist of a UIElementCollection of child elements hosted within the parent Panel.\nPanel also exposes a Panel.ZIndex attached property that can be used to achieve layered order in a derived Panel. Members of a panel's Children collection with a higher Panel.ZIndex value appear in front of those with a lower Panel.ZIndex value. This is particularly useful for panels such as Canvas and Grid which allow children to share the same coordinate space.\nPanel also defines the OnRender method, which can be used to override the default presentation behavior of a Panel.\n \nDerived Panel Elements\nMany objects derive from Panel, but not all of them are intended for use as root layout providers. There are six defined panel classes (Canvas, DockPanel, Grid, StackPanel, VirtualizingStackPanel, and WrapPanel) that are designed specifically for creating application UI.\nEach panel element encapsulates its own special functionality, as seen in the following table. Element Name\nUI Panel?\nDescription Canvas\nYes\nDefines an area within which you can explicitly position child elements by coordinates relative to the Canvas area. DockPanel\nYes\nDefines an area within which you can arrange child elements either horizontally or vertically, relative to each other. Grid\nYes\nDefines a flexible grid area consisting of columns and rows. Child elements of a Grid can be positioned precisely using the Margin property. StackPanel\nYes\nArranges child elements into a single line that can be oriented horizontally or vertically. TabPanel\nNo\nHandles the layout of tab buttons in a TabControl. ToolBarOverflowPanel\nNo\nArranges content within a ToolBar control. UniformGrid\nNo\n\nUniformGrid is used to arrange children in a grid with all equal cell sizes. VirtualizingPanel\nNo\nProvides a base class for panels that can \"virtualize\" their children collection. VirtualizingStackPanel\nYes\nArranges and virtualizes content on a single line oriented horizontally or vertically. WrapPanel\nYes\n\nWrapPanel positions child elements in sequential position from left to right, breaking content to the next line at the edge of the containing box. Subsequent ordering happens sequentially from top to bottom or right to left, depending on the value of the Orientation property."
    },
    {
        "page_index": 26,
        "chunk_index": 0,
        "text": "Grid\nThe Grid element merges the functionality of an absolute positioning and tabular data control. A Grid enables you to easily position and style elements. Grid allows you to define flexible row and column groupings, and even provides a mechanism to share sizing information between multiple Grid elements.\nHow is Grid Different from Table?"
    },
    {
        "page_index": 26,
        "chunk_index": 1,
        "text": "How is Grid Different from Table?\nTable and Grid share some common functionality, but each is best suited for different scenarios. A Table is designed for use within flow content (see Flow Document Overview for more information on flow content). Grids are best used inside of forms (basically anywhere outside of flow content). Within a FlowDocument, Table supports flow content behaviors like pagination, column reflow, and content selection while a Grid does not. A Grid on the other hand is best used outside of a FlowDocument for many reasons including Grid adds elements based on a row and column index, Table does not. The Grid element allows layering of child content, allowing more than one element to exist within a single \"cell.\" Table does not support layering. Child elements of a Grid can be absolutely positioned relative to the area of their \"cell\" boundaries. Table does not support this feature. Finally, a Grid is lighter weight than a Table.\nSizing Behavior of Columns and Rows"
    },
    {
        "page_index": 26,
        "chunk_index": 2,
        "text": "Sizing Behavior of Columns and Rows\nColumns and rows defined within a Grid can take advantage of Star sizing in order to distribute remaining space proportionally. When Star is selected as the Height or Width of a row or column, that column or row receives a weighted proportion of remaining available space. This is in contrast to Auto, which will distribute space evenly based on the size of the content within a column or row. This value is expressed as * or 2* when using Extensible Application Markup Language (XAML). In the first case, the row or column would receive one times the available space, in the second case, two times, and so on. By combining this technique to proportionally distribute space with a HorizontalAlignment and VerticalAlignment value of Stretch it is possible to partition layout space by percentage of screen space. Grid is the only layout panel that can distribute space in this manner.\nDefining and Using a Grid"
    },
    {
        "page_index": 26,
        "chunk_index": 3,
        "text": "Defining and Using a Grid\nThe following example demonstrates how to build a UI similar to that found on the Run dialog available on the Windows Start menu."
    },
    {
        "page_index": 26,
        "chunk_index": 4,
        "text": "C#Copy\n\n// Create the Grid.\ngrid1 = new Grid ();\ngrid1.Background = Brushes.Gainsboro;\ngrid1.HorizontalAlignment = HorizontalAlignment.Left;\ngrid1.VerticalAlignment = VerticalAlignment.Top;\ngrid1.ShowGridLines = true;\ngrid1.Width = 425;\ngrid1.Height = 165;\n\n// Define the Columns.\ncolDef1 = new ColumnDefinition();\ncolDef1.Width = new GridLength(1, GridUnitType.Auto);\ncolDef2 = new ColumnDefinition();\ncolDef2.Width = new GridLength(1, GridUnitType.Star);\ncolDef3 = new ColumnDefinition();\ncolDef3.Width = new GridLength(1, GridUnitType.Star);\ncolDef4 = new ColumnDefinition();\ncolDef4.Width = new GridLength(1, GridUnitType.Star);\ncolDef5 = new ColumnDefinition();\ncolDef5.Width = new GridLength(1, GridUnitType.Star);\ngrid1.ColumnDefinitions.Add(colDef1);\ngrid1.ColumnDefinitions.Add(colDef2);\ngrid1.ColumnDefinitions.Add(colDef3);\ngrid1.ColumnDefinitions.Add(colDef4);\ngrid1.ColumnDefinitions.Add(colDef5);"
    },
    {
        "page_index": 26,
        "chunk_index": 5,
        "text": "// Define the Rows.\nrowDef1 = new RowDefinition();\nrowDef1.Height = new GridLength(1, GridUnitType.Auto);\nrowDef2 = new RowDefinition();\nrowDef2.Height = new GridLength(1, GridUnitType.Auto);\nrowDef3 = new RowDefinition();\nrowDef3.Height = new GridLength(1, GridUnitType.Star);\nrowDef4 = new RowDefinition();\nrowDef4.Height = new GridLength(1, GridUnitType.Auto);\ngrid1.RowDefinitions.Add(rowDef1);\ngrid1.RowDefinitions.Add(rowDef2);\ngrid1.RowDefinitions.Add(rowDef3);\ngrid1.RowDefinitions.Add(rowDef4);\n\n// Add the Image.\nimg1 = new Image();\nimg1.Source = new System.Windows.Media.Imaging.BitmapImage(new Uri(\"runicon.png\", UriKind.Relative));\nGrid.SetRow(img1, 0);\nGrid.SetColumn(img1, 0);\n\n// Add the main application dialog.\ntxt1 = new TextBlock();\ntxt1.Text = \"Type the name of a program, folder, document, or Internet resource, and Windows will open it for you.\";\ntxt1.TextWrapping = TextWrapping.Wrap;\nGrid.SetColumnSpan(txt1, 4);\nGrid.SetRow(txt1, 0);\nGrid.SetColumn(txt1, 1);"
    },
    {
        "page_index": 26,
        "chunk_index": 6,
        "text": "// Add the second text cell to the Grid.\ntxt2 = new TextBlock();\ntxt2.Text = \"Open:\";\nGrid.SetRow(txt2, 1);\nGrid.SetColumn(txt2, 0);\n\n// Add the TextBox control.\ntb1 = new TextBox();\nGrid.SetRow(tb1, 1);\nGrid.SetColumn(tb1, 1);\nGrid.SetColumnSpan(tb1, 5);\n\n// Add the buttons.\nbutton1 = new Button();\nbutton2 = new Button();\nbutton3 = new Button();\nbutton1.Content = \"OK\";\nbutton2.Content = \"Cancel\";\nbutton3.Content = \"Browse ...\";\nGrid.SetRow(button1, 3);\nGrid.SetColumn(button1, 2);\nbutton1.Margin = new Thickness(10, 0, 10, 15);\nbutton2.Margin = new Thickness(10, 0, 10, 15);\nbutton3.Margin = new Thickness(10, 0, 10, 15);\nGrid.SetRow(button2, 3);\nGrid.SetColumn(button2, 3);\nGrid.SetRow(button3, 3);\nGrid.SetColumn(button3, 4);\n\ngrid1.Children.Add(img1);\ngrid1.Children.Add(txt1);\ngrid1.Children.Add(txt2);\ngrid1.Children.Add(tb1);\ngrid1.Children.Add(button1);\ngrid1.Children.Add(button2);\ngrid1.Children.Add(button3);\n\nmainWindow.Content = grid1;"
    },
    {
        "page_index": 26,
        "chunk_index": 7,
        "text": "mainWindow.Content = grid1;\n\nThe compiled application yields a new UI that looks like this."
    },
    {
        "page_index": 27,
        "chunk_index": 0,
        "text": "DockPanel\nThe DockPanel element uses the DockPanel.Dock attached property as set in child content elements to position content along the edges of a container. When DockPanel.Dock is set to Top or Bottom, it positions child elements above or below each other. When DockPanel.Dock is set to Left or Right, it positions child elements to the left or right of each other. The LastChildFill property determines the position of the final element added as a child of a DockPanel.\nYou can use DockPanel to position a group of related controls, such as a set of buttons. Alternately, you can use it to create a \"paned\" UI, similar to that found in Microsoft Outlook.\nSizing to Content"
    },
    {
        "page_index": 27,
        "chunk_index": 1,
        "text": "Sizing to Content\nIf its Height and Width properties are not specified, DockPanel sizes to its content. The size can increase or decrease to accommodate the size of its child elements. However, when these properties are specified and there is no longer room for the next specified child element, DockPanel does not display that child element or subsequent child elements and does not measure subsequent child elements.\nLastChildFill\nBy default, the last child of a DockPanel element will \"fill\" the remaining, unallocated space. If this behavior is not desired, set the LastChildFill property to false.\nDefining and Using a DockPanel\nThe following example demonstrates how to partition space using a DockPanel. Five Border elements are added as children of a parent DockPanel. Each uses a different positioning property of a DockPanel to partition space. The final element \"fills\" the remaining, unallocated space.\nC#"
    },
    {
        "page_index": 27,
        "chunk_index": 2,
        "text": "// Create the application's main window\nmainWindow = new Window ();\nmainWindow.Title = \"DockPanel Sample\";\n\n// Create the DockPanel\nDockPanel myDockPanel = new DockPanel();\nmyDockPanel.LastChildFill = true;\n\n// Define the child content\nBorder myBorder1 = new Border();\nmyBorder1.Height = 25;\nmyBorder1.Background = Brushes.SkyBlue;\nmyBorder1.BorderBrush = Brushes.Black;\nmyBorder1.BorderThickness = new Thickness(1);\nDockPanel.SetDock(myBorder1, Dock.Top);\nTextBlock myTextBlock1 = new TextBlock();\nmyTextBlock1.Foreground = Brushes.Black;\nmyTextBlock1.Text = \"Dock = Top\";\nmyBorder1.Child = myTextBlock1;\n\nBorder myBorder2 = new Border();\nmyBorder2.Height = 25;\nmyBorder2.Background = Brushes.SkyBlue;\nmyBorder2.BorderBrush = Brushes.Black;\nmyBorder2.BorderThickness = new Thickness(1);\nDockPanel.SetDock(myBorder2, Dock.Top);\nTextBlock myTextBlock2 = new TextBlock();\nmyTextBlock2.Foreground = Brushes.Black;\nmyTextBlock2.Text = \"Dock = Top\";\nmyBorder2.Child = myTextBlock2;"
    },
    {
        "page_index": 27,
        "chunk_index": 3,
        "text": "Border myBorder3 = new Border();\nmyBorder3.Height = 25;\nmyBorder3.Background = Brushes.LemonChiffon;\nmyBorder3.BorderBrush = Brushes.Black;\nmyBorder3.BorderThickness = new Thickness(1);\nDockPanel.SetDock(myBorder3, Dock.Bottom);\nTextBlock myTextBlock3 = new TextBlock();\nmyTextBlock3.Foreground = Brushes.Black;\nmyTextBlock3.Text = \"Dock = Bottom\";\nmyBorder3.Child = myTextBlock3;\n\nBorder myBorder4 = new Border();\nmyBorder4.Width = 200;\nmyBorder4.Background = Brushes.PaleGreen;\nmyBorder4.BorderBrush = Brushes.Black;\nmyBorder4.BorderThickness = new Thickness(1);\nDockPanel.SetDock(myBorder4, Dock.Left);\nTextBlock myTextBlock4 = new TextBlock();\nmyTextBlock4.Foreground = Brushes.Black;\nmyTextBlock4.Text = \"Dock = Left\";\nmyBorder4.Child = myTextBlock4;"
    },
    {
        "page_index": 27,
        "chunk_index": 4,
        "text": "Border myBorder5 = new Border();\nmyBorder5.Background = Brushes.White;\nmyBorder5.BorderBrush = Brushes.Black;\nmyBorder5.BorderThickness = new Thickness(1);\nTextBlock myTextBlock5 = new TextBlock();\nmyTextBlock5.Foreground = Brushes.Black;\nmyTextBlock5.Text = \"This content will Fill the remaining space\";\nmyBorder5.Child = myTextBlock5; // Add child elements to the DockPanel Children collection\nmyDockPanel.Children.Add(myBorder1);\nmyDockPanel.Children.Add(myBorder2);\nmyDockPanel.Children.Add(myBorder3);\nmyDockPanel.Children.Add(myBorder4);\nmyDockPanel.Children.Add(myBorder5);\n           \n// Add the parent Canvas as the Content of the Window Object\nmainWindow.Content = myDockPanel;\nmainWindow.Show (); XAML\n<Page xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" WindowTitle=\"DockPanel Sample\">\n  <DockPanel LastChildFill=\"True\">\n    <Border Height=\"25\" Background=\"SkyBlue\" BorderBrush=\"Black\" BorderThickness=\"1\" DockPanel.Dock=\"Top\">"
    },
    {
        "page_index": 27,
        "chunk_index": 5,
        "text": "<TextBlock Foreground=\"Black\">Dock = \"Top\"</TextBlock>\n    </Border>\n    <Border Height=\"25\" Background=\"SkyBlue\" BorderBrush=\"Black\" BorderThickness=\"1\" DockPanel.Dock=\"Top\">\n      <TextBlock Foreground=\"Black\">Dock = \"Top\"</TextBlock>\n    </Border>\n    <Border Height=\"25\" Background=\"LemonChiffon\" BorderBrush=\"Black\" BorderThickness=\"1\" DockPanel.Dock=\"Bottom\">\n      <TextBlock Foreground=\"Black\">Dock = \"Bottom\"</TextBlock>\n    </Border>\n    <Border Width=\"200\" Background=\"PaleGreen\" BorderBrush=\"Black\" BorderThickness=\"1\" DockPanel.Dock=\"Left\">\n      <TextBlock Foreground=\"Black\">Dock = \"Left\"</TextBlock>\n    </Border>\n    <Border Background=\"White\" BorderBrush=\"Black\" BorderThickness=\"1\">\n      <TextBlock Foreground=\"Black\">This content will \"Fill\" the remaining space</TextBlock>\n    </Border>\n  </DockPanel>\n</Page>"
    },
    {
        "page_index": 27,
        "chunk_index": 6,
        "text": "The compiled application yields a new UI that looks like this."
    },
    {
        "page_index": 28,
        "chunk_index": 0,
        "text": "StackPanel\nA StackPanel enables you to \"stack\" elements in an assigned direction. The default stack direction is vertical. The Orientation property can be used to control content flow.\nStackPanel vs. DockPanel\nAlthough DockPanel can also \"stack\" child elements, DockPanel and StackPanel do not produce analogous results in some usage scenarios. For example, the order of child elements can affect their size in a DockPanel but not in a StackPanel. This is because StackPanel measures in the direction of stacking at PositiveInfinity, whereas DockPanel measures only the available size.\nThe following example demonstrates this key difference.\n\nC#Copy\n\n// Create the application's main window\nmainWindow = new Window ();\nmainWindow.Title = \"StackPanel vs. DockPanel\";"
    },
    {
        "page_index": 28,
        "chunk_index": 1,
        "text": "// Add root Grid\nmyGrid = new Grid();\nmyGrid.Width = 175;\nmyGrid.Height = 150;\nRowDefinition myRowDef1 = new RowDefinition();\nRowDefinition myRowDef2 = new RowDefinition();\nmyGrid.RowDefinitions.Add(myRowDef1);\nmyGrid.RowDefinitions.Add(myRowDef2);\n\n// Define the DockPanel\nmyDockPanel = new DockPanel();\nGrid.SetRow(myDockPanel, 0);\n\n//Define an Image and Source\nImage myImage = new Image();\nBitmapImage bi = new BitmapImage();\nbi.BeginInit();\nbi.UriSource = new Uri(\"smiley_stackpanel.png\", UriKind.Relative);\nbi.EndInit();\nmyImage.Source = bi;\n\nImage myImage2 = new Image();\nBitmapImage bi2 = new BitmapImage();\nbi2.BeginInit();\nbi2.UriSource = new Uri(\"smiley_stackpanel.png\", UriKind.Relative);\nbi2.EndInit();\nmyImage2.Source = bi2;\n\nImage myImage3 = new Image();\nBitmapImage bi3 = new BitmapImage();\nbi3.BeginInit();\nbi3.UriSource = new Uri(\"smiley_stackpanel.PNG\", UriKind.Relative);\nbi3.EndInit();\nmyImage3.Stretch = Stretch.Fill;\nmyImage3.Source = bi3;"
    },
    {
        "page_index": 28,
        "chunk_index": 2,
        "text": "// Add the images to the parent DockPanel\nmyDockPanel.Children.Add(myImage);\nmyDockPanel.Children.Add(myImage2);\nmyDockPanel.Children.Add(myImage3);\n\n//Define a StackPanel\nmyStackPanel = new StackPanel();\nmyStackPanel.Orientation = Orientation.Horizontal;\nGrid.SetRow(myStackPanel, 1);\n\nImage myImage4 = new Image();\nBitmapImage bi4 = new BitmapImage();\nbi4.BeginInit();\nbi4.UriSource = new Uri(\"smiley_stackpanel.png\", UriKind.Relative);\nbi4.EndInit();\nmyImage4.Source = bi4;\n\nImage myImage5 = new Image();\nBitmapImage bi5 = new BitmapImage();\nbi5.BeginInit();\nbi5.UriSource = new Uri(\"smiley_stackpanel.png\", UriKind.Relative);\nbi5.EndInit();\nmyImage5.Source = bi5;\n\nImage myImage6 = new Image();\nBitmapImage bi6 = new BitmapImage();\nbi6.BeginInit();\nbi6.UriSource = new Uri(\"smiley_stackpanel.PNG\", UriKind.Relative);\nbi6.EndInit();\nmyImage6.Stretch = Stretch.Fill;\nmyImage6.Source = bi6;"
    },
    {
        "page_index": 28,
        "chunk_index": 3,
        "text": "// Add the images to the parent StackPanel\nmyStackPanel.Children.Add(myImage4);\nmyStackPanel.Children.Add(myImage5);\nmyStackPanel.Children.Add(myImage6);\n\n// Add the layout panels as children of the Grid\nmyGrid.Children.Add(myDockPanel);\nmyGrid.Children.Add(myStackPanel);\n\n// Add the Grid as the Content of the Parent Window Object\nmainWindow.Content = myGrid;\nmainWindow.Show (); XAMLCopy\n<Page xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n      WindowTitle=\"StackPanel vs. DockPanel\">\n  <Grid Width=\"175\" Height=\"150\">\n    <Grid.ColumnDefinitions>\n      <ColumnDefinition />\n    </Grid.ColumnDefinitions>\n    <Grid.RowDefinitions>\n      <RowDefinition />\n      <RowDefinition />\n    </Grid.RowDefinitions>\n    \n    <DockPanel Grid.Column=\"0\" Grid.Row=\"0\">\n      <Image Source=\"smiley_stackpanel.png\" />\n      <Image Source=\"smiley_stackpanel.png\" />\n      <Image Source=\"smiley_stackpanel.png\" Stretch=\"Fill\"/>\n    </DockPanel>"
    },
    {
        "page_index": 28,
        "chunk_index": 4,
        "text": "<StackPanel Grid.Column=\"0\" Grid.Row=\"1\"  Orientation=\"Horizontal\">\n      <Image Source=\"smiley_stackpanel.png\" />\n      <Image Source=\"smiley_stackpanel.png\" />\n      <Image Source=\"smiley_stackpanel.png\" Stretch=\"Fill\"/>\n    </StackPanel>\n    </Grid>\n</Page>\n\nThe difference in rendering behavior can be seen in this image.\n\nDefining and Using a StackPanel\nThe following example demonstrates how to use a StackPanel to create a set of vertically-positioned buttons. For horizontal positioning, set the Orientation property to Horizontal.\n\nC#Copy\n\n  // Create the application's main window\n  mainWindow = new Window ();\n  mainWindow.Title = \"StackPanel Sample\";\n\n  // Define the StackPanel\n  myStackPanel = new StackPanel();\n  myStackPanel.HorizontalAlignment = HorizontalAlignment.Left;\n  myStackPanel.VerticalAlignment = VerticalAlignment.Top;"
    },
    {
        "page_index": 28,
        "chunk_index": 5,
        "text": "// Define child content\n  Button myButton1 = new Button();\n  myButton1.Content = \"Button 1\";\n  Button myButton2 = new Button();\n  myButton2.Content = \"Button 2\";\n  Button myButton3 = new Button();\n  myButton3.Content = \"Button 3\";\n\n  // Add child elements to the parent StackPanel\n  myStackPanel.Children.Add(myButton1);\n  myStackPanel.Children.Add(myButton2);\n  myStackPanel.Children.Add(myButton3);           \n\n  // Add the StackPanel as the Content of the Parent Window Object\n  mainWindow.Content = myStackPanel;\n  mainWindow.Show (); The compiled application yields a new UI that looks like this."
    },
    {
        "page_index": 29,
        "chunk_index": 0,
        "text": "Lecture Slides: Controls.pdf\n Sample Code: Example Set 1.zip\n Video Lectures:"
    },
    {
        "page_index": 30,
        "chunk_index": 0,
        "text": "M4 Objectives\n\nAfter completing this week's work, you will be able to:\n\nDeclare an enumeration type.\nCreate and use an enumeration type.\nDeclare a structure type.\nCreate and use a structure type.\nExplain the differences in behavior between a structure and a class.\nCreate and modify strings\nExplain the difference between a value type and a reference type\nModify the way in which arguments are passed as method parameters by using the ref and out keywords \n\n \n\n M4 Activities  Watch Video Lectures\nRead Lecture Slides & Programming Guide,\nPractice with Sample Code\nComplete M4 Quiz and Assignment"
    },
    {
        "page_index": 31,
        "chunk_index": 0,
        "text": "Lecture Slides: Enum_Struct.pdf\n Sample Code: : StructsAndEnums.zip\nRecommended Online Resources:\n\nChannel 9 -  Enumerations and the Switch Decision Statement\n\n When do you use structs vs classes? (starts at around 4')"
    },
    {
        "page_index": 32,
        "chunk_index": 0,
        "text": "struct \nA struct type is a value type that is typically used to encapsulate small groups of related variables, such as the coordinates of a rectangle or the characteristics of an item in an inventory. The following example shows a simple struct declaration:\nC#\npublic struct Book\n{\n    public decimal price;\n    public string title;\n    public string author;\n}"
    },
    {
        "page_index": 32,
        "chunk_index": 1,
        "text": "Structs can also contain constructors, constants, fields, methods, properties, indexers, operators, events, and nested types, although if several such members are required, you should consider making your type a class instead.\nstruct vs. class\nThe struct type is suitable for representing lightweight objects such as Point, Rectangle, and Color. Although it is just as convenient to represent a point as a class with Auto-Implemented Properties, a struct might be more efficient in some scenarios. For example, if you declare an array of 1000 Point objects, you will allocate additional memory for referencing each object; in this case, a struct would be less expensive. Because .NET already contains an object called Point, the struct in this example is named Coords instead.\nC#\npublic struct Coords\n{\n    public int x, y;\n\n    public Coords(int p1, int p2)\n    {\n        x = p1;\n        y = p2;\n    }\n}"
    },
    {
        "page_index": 32,
        "chunk_index": 2,
        "text": "It is an error to define a parameterless constructor for a struct. It is also an error to initialize an instance field in a struct body. You can initialize externally accessible struct members only by using a parameterized constructor, the implicit, parameterless constructor, an object initializer, or by accessing the members individually after the struct is declared. Any private or otherwise inaccessible members require the use of constructors exclusively.\nWhen you create a struct object using the new operator, it gets created and the appropriate constructor is called according to the constructor's signature. Unlike classes, structs can be instantiated without using the new operator. In such a case, there is no constructor call, which makes the allocation more efficient. However, the fields will remain unassigned and the object cannot be used until all of the fields are initialized. This includes the inability to get or set values through properties."
    },
    {
        "page_index": 32,
        "chunk_index": 3,
        "text": "If you instantiate a struct object using the parameterless constructor, all members are assigned according to their default values.\nWhen writing a constructor with parameters for a struct, you must explicitly initialize all members; otherwise one or more members remain unassigned and the struct cannot be used, producing compiler error CS0171.\nThere is no inheritance for structs as there is for classes. A struct cannot inherit from another struct or class, and it cannot be the base of a class. Structs, however, inherit from the base class Object. A struct can implement interfaces, and it does that exactly as classes do.\nYou cannot declare a class using the keyword struct. In C#, classes and structs are semantically different. A struct is a value type, while a class is a reference type. For more information, see Value types and Reference types.\nUnless you need reference-type semantics, a small class may be more efficiently handled by the system if you declare it as a struct instead."
    },
    {
        "page_index": 32,
        "chunk_index": 4,
        "text": "Example 1\nThis example demonstrates struct initialization using both parameterless and parameterized constructors.\nC#\npublic struct Coords\n{\n    public int x, y;"
    },
    {
        "page_index": 32,
        "chunk_index": 5,
        "text": "public Coords(int p1, int p2)\n    {\n        x = p1;\n        y = p2;\n    }\n} C#Copy\n// Declare and initialize struct objects.\nclass TestCoords\n{\n    static void Main()\n    {\n        // Initialize.\n        var coords1 = new Coords();\n        var coords2 = new Coords(10, 10);\n\n        // Display results.\n        Console.Write(\"Coords 1: \");\n        Console.WriteLine($\"x = {coords1.x}, y = {coords1.y}\");\n\n        Console.Write(\"Coords 2: \");\n        Console.WriteLine($\"x = {coords2.x}, y = {coords2.y}\");\n\n        // Keep the console window open in debug mode.\n        Console.WriteLine(\"Press any key to exit.\");\n        Console.ReadKey();\n    }\n}\n/* Output:\n    Coords 1: x = 0, y = 0\n    Coords 2: x = 10, y = 10\n*/\n\nExample 2\nThis example demonstrates a feature that is unique to structs. It creates a Coords object without using the new operator. If you replace the word struct with the word class, the program will not compile.\nC#\npublic struct Coords\n{\n    public int x, y;"
    },
    {
        "page_index": 32,
        "chunk_index": 6,
        "text": "public Coords(int p1, int p2)\n    {\n        x = p1;\n        y = p2;\n    }\n} C#Copy\n// Declare a struct object without \"new\".\nclass TestCoordsNoNew\n{\n    static void Main()\n    {\n        // Declare an object.\n        Coords coords1;\n\n        // Initialize.\n        coords1.x = 10;\n        coords1.y = 20;\n\n        // Display results.\n        Console.Write(\"Coords 1: \");\n        Console.WriteLine($\"x = {coords1.x}, y = {coords1.y}\");\n\n        // Keep the console window open in debug mode.\n        Console.WriteLine(\"Press any key to exit.\");\n        Console.ReadKey();\n    }\n}\n// Output: Coords 1: x = 10, y = 20"
    },
    {
        "page_index": 33,
        "chunk_index": 0,
        "text": "enum \nThe enum keyword is used to declare an enumeration, a distinct type that consists of a set of named constants called the enumerator list.\nUsually it is best to define an enum directly within a namespace so that all classes in the namespace can access it with equal convenience. However, an enum can also be nested within a class or struct.\nBy default, the first enumerator has the value 0, and the value of each successive enumerator is increased by 1. For example, in the following enumeration, Sat is 0, Sun is 1, Mon is 2, and so forth.\nC#\nenum Day {Sat, Sun, Mon, Tue, Wed, Thu, Fri};\n\nEnumerators can use initializers to override the default values, as shown in the following example.\nC#\nenum Day {Sat=1, Sun, Mon, Tue, Wed, Thu, Fri};"
    },
    {
        "page_index": 33,
        "chunk_index": 1,
        "text": "In this enumeration, the sequence of elements is forced to start from 1 instead of 0. However, including a constant that has the value of 0 is recommended. For more information, see Enumeration Types.\nEvery enumeration type has an underlying type, which can be any integral numeric type. The  char type cannot be an underlying type of an enum. The default underlying type of enumeration elements is int. To declare an enum of another integral type, such as byte, use a colon after the identifier followed by the type, as shown in the following example.\n\nC#Copy\nenum Day : byte {Sat=1, Sun, Mon, Tue, Wed, Thu, Fri};\n\nA variable of an enumeration type can be assigned any value in the range of the underlying type; the values are not limited to the named constants.\nThe default value of an enum E is the value produced by the expression (E)0.\n\n Note\nAn enumerator cannot contain white space in its name."
    },
    {
        "page_index": 33,
        "chunk_index": 2,
        "text": "The underlying type specifies how much storage is allocated for each enumerator. However, an explicit cast is necessary to convert from enum type to an integral type. For example, the following statement assigns the enumerator Sun to a variable of the type int by using a cast to convert from enum to int.\n\nC#Copy\nint x = (int)Day.Sun;"
    },
    {
        "page_index": 33,
        "chunk_index": 3,
        "text": "When you apply System.FlagsAttribute to an enumeration that contains elements that can be combined with a bitwise OR operation, the attribute affects the behavior of the enum when it is used with some tools. You can notice these changes when you use tools such as the Console class methods and the Expression Evaluator. (See the third example.)\nRobust programming\nJust as with any constant, all references to the individual values of an enum are converted to numeric literals at compile time. This can create potential versioning issues as described in Constants.\nAssigning additional values to new versions of enums, or changing the values of the enum members in a new version, can cause problems for dependent source code. Enum values often are used in switch statements. If additional elements have been added to the enum type, the default section of the switch statement can be selected unexpectedly."
    },
    {
        "page_index": 33,
        "chunk_index": 4,
        "text": "If other developers use your code, you should provide guidelines about how their code should react if new elements are added to any enum types.\nExample\nIn the following example, an enumeration, Day, is declared. Two enumerators are explicitly converted to integer and assigned to integer variables.\nC#\npublic class EnumTest\n{\n    enum Day { Sun, Mon, Tue, Wed, Thu, Fri, Sat };"
    },
    {
        "page_index": 33,
        "chunk_index": 5,
        "text": "static void Main()\n    {\n        int x = (int)Day.Sun;\n        int y = (int)Day.Fri;\n        Console.WriteLine(\"Sun = {0}\", x);\n        Console.WriteLine(\"Fri = {0}\", y);\n    }\n}\n/* Output:\n   Sun = 0\n   Fri = 5\n*/\n\nExample\n\nIn the following example, the base-type option is used to declare an enum whose members are of type long. Notice that even though the underlying type of the enumeration is long, the enumeration members still must be explicitly converted to type long by using a cast.\nC#\npublic class EnumTest2\n{\n    enum Range : long { Max = 2147483648L, Min = 255L };\n    static void Main()\n    {\n        long x = (long)Range.Max;\n        long y = (long)Range.Min;\n        Console.WriteLine(\"Max = {0}\", x);\n        Console.WriteLine(\"Min = {0}\", y);\n    }\n}\n/* Output:\n   Max = 2147483648\n   Min = 255\n*/\n\nExample"
    },
    {
        "page_index": 33,
        "chunk_index": 6,
        "text": "Example\n\nThe following code example illustrates the use and effect of the System.FlagsAttribute attribute on an enum declaration.\nC#\n// Add the attribute Flags or FlagsAttribute.\n[Flags]\npublic enum CarOptions\n{\n    // The flag for SunRoof is 0001.\n    SunRoof = 0x01,\n    // The flag for Spoiler is 0010.\n    Spoiler = 0x02,\n    // The flag for FogLights is 0100.\n    FogLights = 0x04,\n    // The flag for TintedWindows is 1000.\n    TintedWindows = 0x08,\n}\n\nclass FlagTest\n{\n    static void Main()\n    {\n        // The bitwise OR of 0001 and 0100 is 0101.\n        CarOptions options = CarOptions.SunRoof | CarOptions.FogLights;"
    },
    {
        "page_index": 33,
        "chunk_index": 7,
        "text": "// Because the Flags attribute is specified, Console.WriteLine displays\n        // the name of each enum element that corresponds to a flag that has\n        // the value 1 in variable options.\n        Console.WriteLine(options);\n        // The integer value of 0101 is 5.\n        Console.WriteLine((int)options);\n    }\n}\n/* Output:\n   SunRoof, FogLights\n   5\n*/\n\nComments\n\nIf you remove Flags, the example displays the following values:\n5\n5"
    },
    {
        "page_index": 34,
        "chunk_index": 0,
        "text": "Lecture Slides: ValueRefType.pdf\n Video Lectures:"
    },
    {
        "page_index": 35,
        "chunk_index": 0,
        "text": "Value types \nThere are two kinds of value types: Structs Enumerations Main features of value types\nA variable of a value type contains a value of the type. For example, a variable of the int type might contain the value 42. This differs from a variable of a reference type, which contains a reference to an instance of the type, also known as an object. When you assign a new value to a variable of a value type, that value is copied. When you assign a new value to a variable of a reference type, the reference is copied, not the object itself.\nAll value types are derived implicitly from the System.ValueType.\nUnlike with reference types, you cannot derive a new type from a value type. However, like reference types, structs can implement interfaces.\nValue type variables cannot be null by default. However, variables of the corresponding nullable value types can be null.\nEach value type has an implicit parameterless constructor that initializes the default value of that type. For information about default values of value types, see Default values table.\nSimple types\nThe simple types are a set of predefined struct types provided by C# and comprise the following types: Integral types: integer numeric types and the char type\nFloating-point types\nbool\n\nThe simple types are identified through keywords, but these keywords are simply aliases for predefined struct types in the System namespace. For example, int is an alias of System.Int32. For a complete list of aliases, see Built-in types table.\nThe simple types differ from other struct types in that they permit certain additional operations: Simple types can be initialized by using literals. For example, 'A' is a literal of the type char and 2001 is a literal of the type int. You can declare constants of the simple types with the const keyword. It's not possible to have constants of other struct types. Constant expressions, whose operands are all simple type constants, are evaluated at compile time. For more information, see the Simple types section of the C# language specification.\nInitializing value types\nLocal variables in C# must be initialized before they are used. For example, you might declare a local variable without initialization as in the following example:\nC#\nint myInt;\n\nYou cannot use it before you initialize it. You can initialize it using the following statement:\nC#\nmyInt = new int();  // Invoke parameterless constructor for int type.\n\nThis statement is equivalent to the following statement:\nC#\nmyInt = 0;         // Assign an initial value, 0 in this example.\n\nYou can, of course, have the declaration and the initialization in the same statement as in the following examples:\nC#\nint myInt = new int();\n\n–or–\nC#\nint myInt = 0;\n\nUsing the new operator calls the parameterless constructor of the specific type and assigns the default value to the variable. In the preceding example, the parameterless constructor assigned the value 0 to myInt. For more information about values assigned by calling parameterless constructors, see Default values table.\nWith user-defined types, use new to invoke the parameterless constructor. For example, the following statement invokes the parameterless constructor of the Point struct:\nC#\nvar p = new Point(); // Invoke parameterless constructor for the struct.\n\nAfter this call, the struct is considered to be definitely assigned; that is, all its members are initialized to their default values.\nFor more information about the new operator, see new."
    },
    {
        "page_index": 36,
        "chunk_index": 0,
        "text": "Reference types \nThere are two kinds of types in C#: reference types and value types. Variables of reference types store references to their data (objects), while variables of value types directly contain their data. With reference types, two variables can reference the same object; therefore, operations on one variable can affect the object referenced by the other variable. With value types, each variable has its own copy of the data, and it is not possible for operations on one variable to affect the other (except in the case of in, ref and out parameter variables; see in, ref and out parameter modifier).\nThe following keywords are used to declare reference types: class interface delegate C# also provides the following built-in reference types: dynamic object string"
    },
    {
        "page_index": 37,
        "chunk_index": 0,
        "text": "Lecture Slides: String.pdf\n Sample Code: ILoveDatesandTimes.zip\nRecommended Online Resources:\n1. Channel 9 -  Working with Strings\n2. Channel 9 -  Working with Dates and Times"
    },
    {
        "page_index": 38,
        "chunk_index": 0,
        "text": "Strings \nA string is an object of type  whose value is text. Internally, the text is stored as a sequential read-only collection of Char objects. There is no null-terminating character at the end of a C# string; therefore a C# string can contain any number of embedded null characters ('\\0'). The Length property of a string represents the number of Char objects it contains, not the number of Unicode characters. To access the individual Unicode code points in a string, use the StringInfo object.\nstring vs. System.String\nIn C#, the string keyword is an alias for String. Therefore, String and string are equivalent, and you can use whichever naming convention you prefer. The String class provides many methods for safely creating, manipulating, and comparing strings. In addition, the C# language overloads some operators to simplify common string operations. For more information about the keyword, see string. For more information about the type and its methods, see String."
    },
    {
        "page_index": 38,
        "chunk_index": 1,
        "text": "Declaring and Initializing Strings\nYou can declare and initialize strings in various ways, as shown in the following example:\nC#\n// Declare without initializing.\nstring message1;"
    },
    {
        "page_index": 38,
        "chunk_index": 2,
        "text": "// Initialize to null.\nstring message2 = null;\n\n// Initialize as an empty string.\n// Use the Empty constant instead of the literal \"\".\nstring message3 = System.String.Empty;\n\n// Initialize with a regular string literal.\nstring oldPath = \"c:\\\\Program Files\\\\Microsoft Visual Studio 8.0\";\n\n// Initialize with a verbatim string literal.\nstring newPath = @\"c:\\Program Files\\Microsoft Visual Studio 9.0\";\n\n// Use System.String if you prefer.\nSystem.String greeting = \"Hello World!\";\n\n// In local variables (i.e. within a method body)\n// you can use implicit typing.\nvar temp = \"I'm still a strongly-typed System.String!\";\n\n// Use a const string to prevent 'message4' from\n// being used to store another string value.\nconst string message4 = \"You can't get rid of me!\";\n\n// Use the String constructor only when creating\n// a string from a char*, char[], or sbyte*. See\n// System.String documentation for details.\nchar[] letters = { 'A', 'B', 'C' };\nstring alphabet = new string(letters);"
    },
    {
        "page_index": 38,
        "chunk_index": 3,
        "text": "Note that you do not use the new operator to create a string object except when initializing the string with an array of chars.\nInitialize a string with the Empty constant value to create a new String object whose string is of zero length. The string literal representation of a zero-length string is \"\". By initializing strings with the Empty value instead of null, you can reduce the chances of a NullReferenceException occurring. Use the static IsNullOrEmpty(String) method to verify the value of a string before you try to access it.\nImmutability of String Objects"
    },
    {
        "page_index": 38,
        "chunk_index": 4,
        "text": "Immutability of String Objects\nString objects are immutable: they cannot be changed after they have been created. All of the String methods and C# operators that appear to modify a string actually return the results in a new string object. In the following example, when the contents of s1 and s2 are concatenated to form a single string, the two original strings are unmodified. The += operator creates a new string that contains the combined contents. That new object is assigned to the variable s1, and the original object that was assigned to s1 is released for garbage collection because no other variable holds a reference to it.\nC#\nstring s1 = \"A string is more \";\nstring s2 = \"than the sum of its chars.\";"
    },
    {
        "page_index": 38,
        "chunk_index": 5,
        "text": "// Concatenate s1 and s2. This actually creates a new\n// string object and stores it in s1, releasing the\n// reference to the original object.\ns1 += s2;\n\nSystem.Console.WriteLine(s1);\n// Output: A string is more than the sum of its chars.\n\nBecause a string \"modification\" is actually a new string creation, you must use caution when you create references to strings. If you create a reference to a string, and then \"modify\" the original string, the reference will continue to point to the original object instead of the new object that was created when the string was modified. The following code illustrates this behavior:\nC#\nstring s1 = \"Hello \";\nstring s2 = s1;\ns1 += \"World\";\n\nSystem.Console.WriteLine(s2);\n//Output: Hello"
    },
    {
        "page_index": 38,
        "chunk_index": 6,
        "text": "System.Console.WriteLine(s2);\n//Output: Hello\n\nFor more information about how to create new strings that are based on modifications such as search and replace operations on the original string, see How to modify string contents.\nRegular and Verbatim String Literals\nUse regular string literals when you must embed escape characters provided by C#, as shown in the following example:\nC#\nstring columns = \"Column 1\\tColumn 2\\tColumn 3\";\n//Output: Column 1        Column 2        Column 3\n\nstring rows = \"Row 1\\r\\nRow 2\\r\\nRow 3\";\n/* Output:\n  Row 1\n  Row 2\n  Row 3\n*/\n\nstring title = \"\\\"The \\u00C6olean Harp\\\", by Samuel Taylor Coleridge\";\n//Output: \"The Æolean Harp\", by Samuel Taylor Coleridge"
    },
    {
        "page_index": 38,
        "chunk_index": 7,
        "text": "Use verbatim strings for convenience and better readability when the string text contains backslash characters, for example in file paths. Because verbatim strings preserve new line characters as part of the string text, they can be used to initialize multiline strings. Use double quotation marks to embed a quotation mark inside a verbatim string. The following example shows some common uses for verbatim strings:\nC#\nstring filePath = @\"C:\\Users\\scoleridge\\Documents\\\";\n//Output: C:\\Users\\scoleridge\\Documents\\\n\nstring text = @\"My pensive SARA ! thy soft cheek reclined\n    Thus on mine arm, most soothing sweet it is\n    To sit beside our Cot,...\";\n/* Output:\nMy pensive SARA ! thy soft cheek reclined\n   Thus on mine arm, most soothing sweet it is\n   To sit beside our Cot,... \n*/\n\nstring quote = @\"Her name was \"\"Sara.\"\"\";\n//Output: Her name was \"Sara.\""
    },
    {
        "page_index": 38,
        "chunk_index": 8,
        "text": "String Escape Sequences Escape sequence\nCharacter name\nUnicode encoding \\'\nSingle quote\n0x0027 \\\"\nDouble quote\n0x0022 \\\\\nBackslash\n0x005C \\0\nNull\n0x0000 \\a\nAlert\n0x0007 \\b\nBackspace\n0x0008 \\f\nForm feed\n0x000C \\n\nNew line\n0x000A \\r\nCarriage return\n0x000D \\t\nHorizontal tab\n0x0009 \\v\nVertical tab\n0x000B \\u\nUnicode escape sequence (UTF-16)\n\n\\uHHHH (range: 0000 - FFFF; example: \\u00E7 = \"ç\") \\U\nUnicode escape sequence (UTF-32)\n\n\\U00HHHHHH (range: 000000 - 10FFFF; example: \\U0001F47D = \"👽\") \\x\nUnicode escape sequence similar to \"\\u\" except with variable length"
    },
    {
        "page_index": 38,
        "chunk_index": 9,
        "text": "\\xH[H][H][H] (range: 0 - FFFF; example: \\x00E7 or \\x0E7 or \\xE7 = \"ç\")  Note At compile time, verbatim strings are converted to ordinary strings with all the same escape sequences. Therefore, if you view a verbatim string in the debugger watch window, you will see the escape characters that were added by the compiler, not the verbatim version from your source code. For example, the verbatim string @\"C:\\files.txt\" will appear in the watch window as \"C:\\\\files.txt\".\n\nFormat Strings\nA format string is a string whose contents are determined dynamically at runtime. Format strings are created by embedding interpolated expressions or placeholders inside of braces within a string. Everything inside the braces ({...}) will be resolved to a value and output as a formatted string at runtime. There are two methods to create format strings: string interpolation and composite formatting.\nString Interpolation"
    },
    {
        "page_index": 38,
        "chunk_index": 10,
        "text": "Available in C# 6.0 and later, interpolated strings are identified by the $ special character and include interpolated expressions in braces. If you are new to string interpolation, see the String interpolation - C# interactive tutorial for a quick overview.\nUse string interpolation to improve the readability and maintainability of your code. String interpolation achieves the same results as the String.Format method, but improves ease of use and inline clarity.\nC#\nvar jh = (firstName: \"Jupiter\", lastName: \"Hammon\", born: 1711, published: 1761);\nConsole.WriteLine($\"{jh.firstName} {jh.lastName} was an African American poet born in {jh.born}.\");\nConsole.WriteLine($\"He was first published in {jh.published} at the age of {jh.published - jh.born}.\");\nConsole.WriteLine($\"He'd be over {Math.Round((2018d - jh.born) / 100d) * 100d} years old today.\");"
    },
    {
        "page_index": 38,
        "chunk_index": 11,
        "text": "// Output:\n// Jupiter Hammon was an African American poet born in 1711.\n// He was first published in 1761 at the age of 50.\n// He'd be over 300 years old today. \n\nComposite Formatting\n\nThe String.Format utilizes placeholders in braces to create a format string. This example results in similar output to the string interpolation method used above.\nC#\nvar pw = (firstName: \"Phillis\", lastName: \"Wheatley\", born: 1753, published: 1773);\nConsole.WriteLine(\"{0} {1} was an African American poet born in {2}.\", pw.firstName, pw.lastName, pw.born);\nConsole.WriteLine(\"She was first published in {0} at the age of {1}.\", pw.published, pw.published - pw.born);\nConsole.WriteLine(\"She'd be over {0} years old today.\", Math.Round((2018d - pw.born) / 100d) * 100d);\n\n// Output:\n// Phillis Wheatley was an African American poet born in 1753.\n// She was first published in 1773 at the age of 20.\n// She'd be over 300 years old today."
    },
    {
        "page_index": 38,
        "chunk_index": 12,
        "text": "For more information on formatting .NET types see Formatting Types in .NET.\nSubstrings\nA substring is any sequence of characters that is contained in a string. Use the Substring method to create a new string from a part of the original string. You can search for one or more occurrences of a substring by using the IndexOf method. Use the Replace method to replace all occurrences of a specified substring with a new string. Like the Substring method, Replace actually returns a new string and does not modify the original string. For more information, see How to search strings and How to modify string contents.\nC#\nstring s3 = \"Visual C# Express\";\nSystem.Console.WriteLine(s3.Substring(7, 2));\n// Output: \"C#\"\n\nSystem.Console.WriteLine(s3.Replace(\"C#\", \"Basic\"));\n// Output: \"Visual Basic Express\"\n\n// Index values are zero-based\nint index = s3.IndexOf(\"C\");\n// index = 7"
    },
    {
        "page_index": 38,
        "chunk_index": 13,
        "text": "Accessing Individual Characters\nYou can use array notation with an index value to acquire read-only access to individual characters, as in the following example:\nC#\nstring s5 = \"Printing backwards\";\n\nfor (int i = 0; i < s5.Length; i++)\n{\n    System.Console.Write(s5[s5.Length - i - 1]);\n}\n// Output: \"sdrawkcab gnitnirP\"\n\nIf the String methods do not provide the functionality that you must have to modify individual characters in a string, you can use a StringBuilder object to modify the individual chars \"in-place\", and then create a new string to store the results by using the StringBuilder methods. In the following example, assume that you must modify the original string in a particular way and then store the results for future use:\nC#\nstring question = \"hOW DOES mICROSOFT wORD DEAL WITH THE cAPS lOCK KEY?\";\nSystem.Text.StringBuilder sb = new System.Text.StringBuilder(question);"
    },
    {
        "page_index": 38,
        "chunk_index": 14,
        "text": "for (int j = 0; j < sb.Length; j++)\n{\n    if (System.Char.IsLower(sb[j]) == true)\n        sb[j] = System.Char.ToUpper(sb[j]);\n    else if (System.Char.IsUpper(sb[j]) == true)\n        sb[j] = System.Char.ToLower(sb[j]);\n}\n// Store the new string.\nstring corrected = sb.ToString();\nSystem.Console.WriteLine(corrected);\n// Output: How does Microsoft Word deal with the Caps Lock key?            \n\nNull Strings and Empty Strings\nAn empty string is an instance of a System.String object that contains zero characters. Empty strings are used often in various programming scenarios to represent a blank text field. You can call methods on empty strings because they are valid System.String objects. Empty strings are initialized as follows:\nC#\nstring s = String.Empty;"
    },
    {
        "page_index": 38,
        "chunk_index": 15,
        "text": "By contrast, a null string does not refer to an instance of a System.String object and any attempt to call a method on a null string causes a NullReferenceException. However, you can use null strings in concatenation and comparison operations with other strings. The following examples illustrate some cases in which a reference to a null string does and does not cause an exception to be thrown:\nC#\nstatic void Main()\n{\n    string str = \"hello\";\n    string nullStr = null;\n    string emptyStr = String.Empty;\n\n    string tempStr = str + nullStr;\n    // Output of the following line: hello\n    Console.WriteLine(tempStr);\n\n    bool b = (emptyStr == nullStr);\n    // Output of the following line: False\n    Console.WriteLine(b);\n\n    // The following line creates a new empty string.\n    string newStr = emptyStr + nullStr;"
    },
    {
        "page_index": 38,
        "chunk_index": 16,
        "text": "// Null strings and empty strings behave differently. The following\n    // two lines display 0.\n    Console.WriteLine(emptyStr.Length);\n    Console.WriteLine(newStr.Length);\n    // The following line raises a NullReferenceException.\n    //Console.WriteLine(nullStr.Length);\n\n    // The null character can be displayed and counted, like other chars.\n    string s1 = \"\\x0\" + \"abc\";\n    string s2 = \"abc\" + \"\\x0\";\n    // Output of the following line: * abc*\n    Console.WriteLine(\"*\" + s1 + \"*\");\n    // Output of the following line: *abc *\n    Console.WriteLine(\"*\" + s2 + \"*\");\n    // Output of the following line: 4\n    Console.WriteLine(s2.Length);\n}"
    },
    {
        "page_index": 38,
        "chunk_index": 17,
        "text": "Using StringBuilder for Fast String Creation\nString operations in .NET are highly optimized and in most cases do not significantly impact performance. However, in some scenarios such as tight loops that are executing many hundreds or thousands of times, string operations can affect performance. The StringBuilder class creates a string buffer that offers better performance if your program performs many string manipulations. The StringBuilder string also enables you to reassign individual characters, something the built-in string data type does not support. This code, for example, changes the content of a string without creating a new string:\nC#\nSystem.Text.StringBuilder sb = new System.Text.StringBuilder(\"Rat: the ideal pet\");\nsb[0] = 'C';\nSystem.Console.WriteLine(sb.ToString());\nSystem.Console.ReadLine();\n\n//Outputs Cat: the ideal pet\n\nIn this example, a StringBuilder object is used to create a string from a set of numeric types:\nC#\nusing System;\nusing System.Text;"
    },
    {
        "page_index": 38,
        "chunk_index": 18,
        "text": "namespace CSRefStrings\n{\n    class TestStringBuilder\n    {\n        static void Main()\n        {\n            var sb = new StringBuilder();\n\n            // Create a string composed of numbers 0 - 9\n            for (int i = 0; i < 10; i++)\n            {\n                sb.Append(i.ToString());\n            }\n            Console.WriteLine(sb);  // displays 0123456789\n\n            // Copy one character of the string (not possible with a System.String)\n            sb[0] = sb[9];\n\n            Console.WriteLine(sb);  // displays 9123456789\n            Console.WriteLine();\n        }\n    }\n}"
    },
    {
        "page_index": 39,
        "chunk_index": 0,
        "text": "Lecture Slides: Exceptions.pdf\n Video Lectures:"
    },
    {
        "page_index": 40,
        "chunk_index": 0,
        "text": "Using Exceptions \nIn C#, errors in the program at run time are propagated through the program by using a mechanism called exceptions. Exceptions are thrown by code that encounters an error and caught by code that can correct the error. Exceptions can be thrown by the .NET Framework common language runtime (CLR) or by code in a program. Once an exception is thrown, it propagates up the call stack until a catch statement for the exception is found. Uncaught exceptions are handled by a generic exception handler provided by the system that displays a dialog box.\nExceptions are represented by classes derived from Exception. This class identifies the type of exception and contains properties that have details about the exception. Throwing an exception involves creating an instance of an exception-derived class, optionally configuring properties of the exception, and then throwing the object by using the throw keyword. For example:"
    },
    {
        "page_index": 40,
        "chunk_index": 1,
        "text": "C#\n         class CustomException : Exception\n       {\n           public CustomException(string message)\n           {\n              \n           }\n\n       }\n       private static void TestThrow()\n       {\n           CustomException ex =\n               new CustomException(\"Custom exception in TestThrow()\");\n\n           throw ex;\n       }\n\nAfter an exception is thrown, the runtime checks the current statement to see whether it is within a try block. If it is, any catch blocks associated with the try block are checked to see whether they can catch the exception. Catch blocks typically specify exception types; if the type of the catch block is the same type as the exception, or a base class of the exception, the catch block can handle the method. For example:\nC#\nstatic void TestCatch()\n{\n    try\n    {\n        TestThrow();\n    }\n    catch (CustomException ex)\n    {\n        System.Console.WriteLine(ex.ToString());\n    }\n}"
    },
    {
        "page_index": 40,
        "chunk_index": 2,
        "text": "If the statement that throws an exception is not within a try block or if the try block that encloses it has no matching catch block, the runtime checks the calling method for a try statement and catch blocks. The runtime continues up the calling stack, searching for a compatible catch block. After the catch block is found and executed, control is passed to the next statement after that catch block.\nA try statement can contain more than one catch block. The first catch statement that can handle the exception is executed; any following catch statements, even if they are compatible, are ignored. Therefore, catch blocks should always be ordered from most specific (or most-derived) to least specific. For example:\n\nC#\n \n\nusing System;\nusing System.IO;"
    },
    {
        "page_index": 40,
        "chunk_index": 3,
        "text": "C#\n \n\nusing System;\nusing System.IO;\n\npublic class ExceptionExample\n{\n    static void Main()\n    {\n        try\n        {\n            using (var sw = new StreamWriter(@\"C:\\test\\test.txt\"))\n            {\n                sw.WriteLine(\"Hello\");\n            }   \n        }\n        // Put the more specific exceptions first.\n        catch (DirectoryNotFoundException ex)\n        {\n            Console.WriteLine(ex);  \n        }\n        catch (FileNotFoundException ex)\n        {\n            Console.WriteLine(ex);  \n        }\n        // Put the least specific exception last.\n        catch (IOException ex)\n        {\n            Console.WriteLine(ex);  \n        }\n\n        Console.WriteLine(\"Done\"); \n    }\n}"
    },
    {
        "page_index": 40,
        "chunk_index": 4,
        "text": "Console.WriteLine(\"Done\"); \n    }\n}\n\nBefore the catch block is executed, the runtime checks for finally blocks. Finally blocks enable the programmer to clean up any ambiguous state that could be left over from an aborted try block, or to release any external resources (such as graphics handles, database connections or file streams) without waiting for the garbage collector in the runtime to finalize the objects. For example:\n\nC#\n \n\nstatic void TestFinally()\n{\n    System.IO.FileStream file = null;\n    //Change the path to something that works on your machine.\n    System.IO.FileInfo fileInfo = new System.IO.FileInfo(@\"C:\\file.txt\");\n\n    try\n    {\n        file = fileInfo.OpenWrite();\n        file.WriteByte(0xF);\n    }\n    finally\n    {\n        // Closing the file allows you to reopen it immediately - otherwise IOException is thrown.\n        if (file != null)\n        {\n            file.Close();\n        }\n    }"
    },
    {
        "page_index": 40,
        "chunk_index": 5,
        "text": "try\n    {\n        file = fileInfo.OpenWrite();\n        System.Console.WriteLine(\"OpenWrite() succeeded\");\n    }\n    catch (System.IO.IOException)\n    {\n        System.Console.WriteLine(\"OpenWrite() failed\");\n    }\n}"
    },
    {
        "page_index": 40,
        "chunk_index": 6,
        "text": "If WriteByte() threw an exception, the code in the second try block that tries to reopen the file would fail if file.Close() is not called, and the file would remain locked. Because finally blocks are executed even if an exception is thrown, the finally block in the previous example allows for the file to be closed correctly and helps avoid an error.\nIf no compatible catch block is found on the call stack after an exception is thrown, one of three things occurs: If the exception is within a finalizer, the finalizer is aborted and the base finalizer, if any, is called. If the call stack contains a static constructor, or a static field initializer, a TypeInitializationException is thrown, with the original exception assigned to the InnerException property of the new exception. If the start of the thread is reached, the thread is terminated."
    },
    {
        "page_index": 41,
        "chunk_index": 0,
        "text": "Try Blocks\nA try block is used by C# programmers to partition code that might be affected by an exception. Associated catch blocks are used to handle any resulting exceptions. A finally block contains code that is run regardless of whether or not an exception is thrown in the try block, such as releasing resources that are allocated in the try block. A try block requires one or more associated catch blocks, or a finally block, or both.\nThe following examples show a try-catch statement, a try-finally statement, and a try-catch-finally statement.\n\nC#\n \n\ntry\n{\n    // Code to try goes here.\n}\ncatch (SomeSpecificException ex)\n{\n    // Code to handle the exception goes here.\n    // Only catch exceptions that you know how to handle.\n    // Never catch base class System.Exception without\n    // rethrowing it at the end of the catch block.\n} C#\n \n\ntry\n{\n    // Code to try goes here.\n}\nfinally\n{\n    // Code to execute after the try block goes here.\n} C#"
    },
    {
        "page_index": 41,
        "chunk_index": 1,
        "text": "try\n{\n    // Code to try goes here.\n}\ncatch (SomeSpecificException ex)\n{\n    // Code to handle the exception goes here.\n}\nfinally\n{\n    // Code to execute after the try (and possibly catch) blocks \n    // goes here.\n}"
    },
    {
        "page_index": 41,
        "chunk_index": 2,
        "text": "A try block without a catch or finally block causes a compiler error.\nCatch Blocks\nA catch block can specify the type of exception to catch. The type specification is called an exception filter. The exception type should be derived from Exception. In general, do not specify Exception as the exception filter unless either you know how to handle all exceptions that might be thrown in the try block, or you have included a throw statement at the end of your catch block."
    },
    {
        "page_index": 41,
        "chunk_index": 3,
        "text": "Multiple catch blocks with different exception filters can be chained together. The catch blocks are evaluated from top to bottom in your code, but only one catch block is executed for each exception that is thrown. The first catch block that specifies the exact type or a base class of the thrown exception is executed. If no catch block specifies a matching exception filter, a catch block that does not have a filter is selected, if one is present in the statement. It is important to position catch blocks with the most specific (that is, the most derived) exception types first.\nYou should catch exceptions when the following conditions are true: You have a good understanding of why the exception might be thrown, and you can implement a specific recovery, such as prompting the user to enter a new file name when you catch a FileNotFoundException object. You can create and throw a new, more specific exception."
    },
    {
        "page_index": 41,
        "chunk_index": 4,
        "text": "C#\n \n\nint GetInt(int[] array, int index)\n{\n    try\n    {\n        return array[index];\n    }\n    catch(System.IndexOutOfRangeException e)\n    {\n        throw new System.ArgumentOutOfRangeException(\n            \"Parameter index is out of range.\", e);\n    }\n} You want to partially handle an exception before passing it on for additional handling. In the following example, a catch block is used to add an entry to an error log before re-throwing the exception.\n\nC#"
    },
    {
        "page_index": 41,
        "chunk_index": 5,
        "text": "try\n{\n    // Try to access a resource.\n}\ncatch (System.UnauthorizedAccessException e)\n{\n    // Call a custom error logging procedure.\n    LogError(e);\n    // Re-throw the error.\n    throw;     \n} Finally Blocks\nA finally block enables you to clean up actions that are performed in a try block. If present, the finally block executes last, after the try block and any matched catch block. A finally block always runs, regardless of whether an exception is thrown or a catch block matching the exception type is found.\nThe finally block can be used to release resources such as file streams, database connections, and graphics handles without waiting for the garbage collector in the runtime to finalize the objects. See using Statement for more information."
    },
    {
        "page_index": 41,
        "chunk_index": 6,
        "text": "In the following example, the finally block is used to close a file that is opened in the try block. Notice that the state of the file handle is checked before the file is closed. If the try block cannot open the file, the file handle still has the value null and the finally block does not try to close it. Alternatively, if the file is opened successfully in the try block, the finally block closes the open file."
    },
    {
        "page_index": 41,
        "chunk_index": 7,
        "text": "C#\n \n\nSystem.IO.FileStream file = null;\nSystem.IO.FileInfo fileinfo = new System.IO.FileInfo(\"C:\\\\file.txt\");\ntry\n{\n    file = fileinfo.OpenWrite();\n    file.WriteByte(0xF);\n}\nfinally\n{\n    // Check for null because OpenWrite might have failed.\n    if (file != null)\n    {\n        file.Close();\n    }\n}"
    },
    {
        "page_index": 42,
        "chunk_index": 0,
        "text": "Our readings, materials, and discussion this week are aimed at helping us get started with Object Oriented Programming concept - Class & Object.\n\n Objectives\n\nAfter completing this week's work, you will be able to:\n\nDefine a class containing a related set of methods and data items.\nControl the accessibility of members by using the public and private keywords.\nCreate objects by using the new keyword to invoke a constructor.\nWrite and call your own constructors.\nCreate methods and data that can be shared by all instances of the same class by using the static keyword.\n\n \n\n M3 Activities  Watch Video Lectures\nRead Lecture Slides & Programming Guide,\nPractice with Sample Code\nComplete M3 Quiz and Assignment"
    },
    {
        "page_index": 43,
        "chunk_index": 0,
        "text": "Lecture Slides: Classes.pdf\nRecommended Online Resources:\n1. Microsoft Learn -  Understanding Classes\n2. Microsoft Learn -  More About Classes and Methods\n3. Microsoft Learn - Tutorial: Explore object oriented programming with classes and objects  with video: Object Oriented Programming: Objects and Classes"
    },
    {
        "page_index": 44,
        "chunk_index": 0,
        "text": "Classes\nClasses  is essentially a data structure that encapsulates a set of data and behaviors that belong together as a logical unit. The data and behaviors are the members of the class , and they include its methods, properties, and events, and so on.\nA class declaration is like a blueprint that is used to create instances or objects at run time. If you define a class called Person, Person is the name of the type. If you declare and initialize a variable p of type Person, p is said to be an object or instance of Person. Multiple instances of the same Person type can be created, and each instance can have different values in its properties and fields.\nA class is a reference type. When an object of the class is created, the variable to which the object is assigned holds only a reference to that memory. When the object reference is assigned to a new variable, the new variable refers to the original object. Changes made through one variable are reflected in the other variable because they both refer to the same data.\nIn general, classes are used to model more complex behavior, or data that is intended to be modified after a class object is created. \nExample\nIn the following example, CustomClass in the ProgrammingGuide namespace has three members: an instance constructor, a property named Number, and a method named Multiply. The Main method in the Program class creates an instance (object) of CustomClass, and the object’s method and property are accessed by using dot notation.\nC#\nusing System;\n\nnamespace ProgrammingGuide\n{\n   // Class definition.\n   public class CustomClass\n   {\n      // Class members.\n      //\n      // Property.\n      public int Number { get; set; }\n\n      // Method.\n      public int Multiply(int num)\n      {\n          return num * Number;\n      }\n\n      // Instance Constructor.\n      public CustomClass()\n      {\n          Number = 0;\n      }\n   }\n\n   // Another class definition that contains Main, the program entry point.\n   class Program\n   {\n      static void Main(string[] args)\n      {\n         // Create an object of type CustomClass.\n         CustomClass custClass = new CustomClass();\n\n         // Set the value of the public property.\n         custClass.Number = 27;\n\n         // Call the public method.\n         int result = custClass.Multiply(4);\n         Console.WriteLine($\"The result is {result}.\");\n      }\n   }\n}\n// The example displays the following output:\n//      The result is 108. \n\n \nEncapsulation is sometimes referred to as the first pillar or principle of object-oriented programming. According to the principle of encapsulation, a class  can specify how accessible each of its members is to code outside of the class. Methods and variables that are not intended to be used from outside of the class or assembly can be hidden to limit the potential for coding errors or malicious exploits.\nFor more information about classes, see Classes and Objects.\nMembers\nAll methods, fields, constants, properties, and events must be declared within a type; these are called the members of the type. In C#, there are no global variables or methods as there are in some other languages. Even a program's entry point, the Main method, must be declared within a class. The following list includes all the various kinds of members that may be declared in a class . Fields Constants Properties Methods Constructors Events Finalizers Indexers Operators Nested Types"
    },
    {
        "page_index": 45,
        "chunk_index": 0,
        "text": "Sample Code: Management - Starting Point.zip\n Video Lectures: \n\nRecommended Online Resources:\n 1. Microsoft Doc: Constructors"
    },
    {
        "page_index": 46,
        "chunk_index": 0,
        "text": "Sample Code: Management - Starting Point.zip\n Video Lectures: \n\nRecommended Online Resources:\n 1. Microsoft Doc: Fields\n2.  Microsoft Doc: Properties"
    },
    {
        "page_index": 47,
        "chunk_index": 0,
        "text": "Sample Code: Management - Starting Point.zip\n Video Lectures: \n\nRecommended Online Resources:\n 1. Microsoft Doc: Methods\n 2. Microsoft Doc: Static Classes and Static Class Members"
    },
    {
        "page_index": 48,
        "chunk_index": 0,
        "text": "Our readings, materials, and discussion this week are aimed at helping us learn the C# programming basics.\n\n Objectives\n\nAfter completing this week's work, you will be able to:\n\nDefine the concepts of loops. \nWrite for, foreach, while, and do iteration statements\nRecognize  declare and call methods.\nPass information and return information from a method\nExplain the functionality provided in the different collection classes (array, list) available with the  .NET Framework.\nCreate type-safe collections, and populate a collection with data.\nManipulate and access the data items held in a collection.\nApply loops, methods, array and list operations in programming.\n\n \n\n M2 Activities  Watch video lectures\nRead programming guide\nWork on assessment and read rubric"
    },
    {
        "page_index": 49,
        "chunk_index": 0,
        "text": "Lecture Slides:  Loops.pdf\n Recommended Online Resources:\n1. Channel 9 -  for Iteration Statement\n2. Channel 9 -  While Iteration Statement"
    },
    {
        "page_index": 50,
        "chunk_index": 0,
        "text": "For loop:\nThe for statement executes a statement or a block of statements while a specified Boolean expression evaluates to true.\nAt any point within the for statement block, you can break out of the loop by using the break statement, or step to the next iteration in the loop by using the continue statement. You also can exit a for loop by the goto, return, or throw statements.\nStructure of the for statement\n\nThe for statement defines initializer, condition, and iterator sections:\nC#\nfor (initializer; condition; iterator)\n    body\n\nAll three sections are optional. The body of the loop is either a statement or a block of statements.\nThe following example shows the for statement with all of the sections defined:\nC#\nfor (int i = 0; i < 5; i++)\n{\n    Console.WriteLine(i);\n}\n\nThe initializer section\nThe statements in the initializer section are executed only once, before entering the loop. The initializer section is either of the following: The declaration and initialization of a local loop variable, which can't be accessed from outside the loop. Zero or more statement expressions from the following list, separated by commas: assignment statement invocation of a method prefix or postfix increment expression, such as ++i or i++ prefix or postfix decrement expression, such as --i or i-- creation of an object by using the new operator await expression The initializer section in the example above declares and initializes the local loop variable i:\nC#\nint i = 0\n\nThe condition section\nThe condition section, if present, must be a boolean expression. That expression is evaluated before every loop iteration. If the condition section is not present or the boolean expression evaluates to true, the next loop iteration is executed; otherwise, the loop is exited.\nThe condition section in the example above determines if the loop terminates based on the value of the local loop variable:\nC#\ni < 5\n\nThe iterator section\nThe iterator section defines what happens after each iteration of the body of the loop. The iterator section contains zero or more of the following statement expressions, separated by commas: assignment statement invocation of a method prefix or postfix increment expression, such as ++i or i++ prefix or postfix decrement expression, such as --i or i-- creation of an object by using the new operator await expression The iterator section in the example above increments the local loop variable:\nC#\ni++"
    },
    {
        "page_index": 51,
        "chunk_index": 0,
        "text": "foreach\nThe foreach statement executes a statement or a block of statements for each element in an instance of the type that implements the System.Collections.IEnumerable or System.Collections.Generic.IEnumerable<T> interface. The foreach statement is not limited to those types and can be applied to an instance of any type that satisfies the following conditions:\n\nhas the public parameterless GetEnumerator method whose return type is either class, struct, or interface type,\nthe return type of the GetEnumerator method has the public Current property and the public parameterless MoveNext method whose return type is Boolean.\n\nBeginning with C# 7.3, if the enumerator's Current property returns a reference return value (ref T where T is the type of the collection element), you can declare the iteration variable with the ref or ref readonly modifier.\nAt any point within the foreach statement block, you can break out of the loop by using the break statement, or step to the next iteration in the loop by using the continue statement. You also can exit a foreach loop by the goto, return, or throw statements.\nIf the foreach statement is applied to null, a NullReferenceException is thrown. If the source collection of the foreach statement is empty, the body of the foreach loop is not executed and skipped.\nExamples\nThe following example shows usage of the foreach statement with an instance of the List<T> type that implements the IEnumerable<T> interface:\nC#\nvar fibNumbers = new List<int> { 0, 1, 1, 2, 3, 5, 8, 13 };\nint count = 0;\nforeach (int element in fibNumbers)\n{\n    count++;\n    Console.WriteLine($\"Element #{count}: {element}\");\n}\nConsole.WriteLine($\"Number of elements: {count}\");// Output:\n//Element #1: 0//Element #2: 1//Element #3: 1//Element #4: 2//Element #5: 3//Element #6: 5//Element #7: 8//Element #8: 13//Number of elements: 8"
    },
    {
        "page_index": 52,
        "chunk_index": 0,
        "text": "while \nThe while statement executes a statement or a block of statements while a specified Boolean expression evaluates to true. Because that expression is evaluated before each execution of the loop, a while loop executes zero or more times. This differs from the do loop, which executes one or more times.\nAt any point within the while statement block, you can break out of the loop by using the break statement.\nYou can step directly to the evaluation of the while expression by using the continue statement. If the expression evaluates to true, execution continues at the first statement in the loop. Otherwise, execution continues at the first statement after the loop.\nYou also can exit a while loop by the goto, return, or throw statements.\nExample\nThe following example shows the usage of the while statement. Select Run to run the example code. After that you can modify the code and run it again.\nC#\nint n = 0;\nwhile (n < 5)\n{\n    Console.WriteLine(n);\n    n++;\n}"
    },
    {
        "page_index": 53,
        "chunk_index": 0,
        "text": "do-while\nThe do statement executes a statement or a block of statements while a specified Boolean expression evaluates to true. Because that expression is evaluated after each execution of the loop, a do-while loop executes one or more times. This differs from the while loop, which executes zero or more times.\nAt any point within the do statement block, you can break out of the loop by using the break statement.\nYou can step directly to the evaluation of the while expression by using the continue statement. If the expression evaluates to true, execution continues at the first statement in the loop. Otherwise, execution continues at the first statement after the loop.\nYou also can exit a do-while loop by the goto, return, or throw statements.\nExample\nThe following example shows the usage of the do statement.\nC#\nint n = 0;\ndo \n{\n    Console.WriteLine(n);\n    n++;\n} while (n < 5);"
    },
    {
        "page_index": 54,
        "chunk_index": 0,
        "text": "Lecture Slides:  Method.pdf\n Sample Code: Overload1.zip \n Video Lectures: \n\n Recommended Online Resources:\n1. Channel 9 -  Defining and Calling Methods"
    },
    {
        "page_index": 55,
        "chunk_index": 0,
        "text": "Methods \nA method is a code block that contains a series of statements. A program causes the statements to be executed by calling the method and specifying any required method arguments. In C#, every executed instruction is performed in the context of a method. The Main method is the entry point for every C# application and it's called by the common language runtime (CLR) when the program is started. There are named methods, and anonymous methods. We discuss named methods here. Anonymous methods will be covered in later modules.\nMethods are declared in a class or struct by specifying:\n\nAn optional access level, such as public or private. The default is private.\nOptional modifiers such as abstract or sealed.\nThe return value, or void if the method has none.\nThe method name.\nAny method parameters. Method parameters are enclosed in parentheses and are separated by commas. Empty parentheses indicate that the method requires no parameters.\n\nThese parts together form the method signature."
    },
    {
        "page_index": 55,
        "chunk_index": 1,
        "text": "These parts together form the method signature.\n\n Note\nA return type of a method is not part of the signature of the method for the purposes of method overloading. However, it is part of the signature of the method when determining the compatibility between a delegate and the method that it points to.\n\nThe following example defines a class named Motorcycle that contains five methods:\nC#\nusing System;\n\nabstract class Motorcycle\n{\n   // Anyone can call this.\n   public void StartEngine() {/* Method statements here */ }\n\n   // Only derived classes can call this.\n   protected void AddGas(int gallons) { /* Method statements here */ }\n\n   // Derived classes can override the base class implementation.\n   public virtual int Drive(int miles, int speed) { /* Method statements here */ return 1; }\n\n   // Derived classes can override the base class implementation.\n   public virtual int Drive(TimeSpan time, int speed) { /* Method statements here */ return 0; }"
    },
    {
        "page_index": 55,
        "chunk_index": 2,
        "text": "// Derived classes must implement this.\n   public abstract double GetTopSpeed(); \n}\n\nNote that the Motorcycle class includes an overloaded method, Drive. Two methods have the same name, but must be differentiated by their parameter types."
    },
    {
        "page_index": 55,
        "chunk_index": 3,
        "text": "Method invocation\nMethods can be either instance or static. Invoking an instance method requires that you instantiate an object and call the method on that object; an instance method operates on that instance and its data. You invoke a static method by referencing the name of the type to which the method belongs; static methods do not operate on instance data. Attempting to call a static method through an object instance generates a compiler error.\nCalling a method is like accessing a field. After the object name (if you are calling an instance method) or the type name (if you are calling a static method), add a period, the name of the method, and parentheses. Arguments are listed within the parentheses, and are separated by commas."
    },
    {
        "page_index": 55,
        "chunk_index": 4,
        "text": "The method definition specifies the names and types of any parameters that are required. When a caller invokes the method, it provides concrete values, called arguments, for each parameter. The arguments must be compatible with the parameter type, but the argument name, if one is used in the calling code, does not have to be the same as the parameter named defined in the method. In the following example, the Square method includes a single parameter of type int named i. The first method call passes the Square method a variable of type int named num; the second, a numeric constant; and the third, an expression."
    },
    {
        "page_index": 55,
        "chunk_index": 5,
        "text": "C#\npublic class Example\n{\n   public static void Main()\n   {\n      // Call with an int variable.\n      int num = 4;\n      int productA = Square(num);\n\n      // Call with an integer literal.\n      int productB = Square(12);\n\n      // Call with an expression that evaluates to int.\n      int productC = Square(productA * 3);\n   }\n   \n   static int Square(int i)\n   {\n      // Store input argument in a local variable.\n      int input = i;\n      return input * input;\n   }\n}\n\nThe most common form of method invocation used positional arguments; it supplies arguments in the same order as method parameters. The methods of the Motorcycle class can therefore be called as in the following example. The call to the Drive method, for example, includes two arguments that correspond to the two parameters in the method's syntax. The first becomes the value of the miles parameter, the second the value of the speed parameter."
    },
    {
        "page_index": 55,
        "chunk_index": 6,
        "text": "C#\nclass TestMotorcycle : Motorcycle\n{\n   public override double GetTopSpeed()\n   {\n      return 108.4;\n   }\n\n   static void Main()\n   {\n      \n      TestMotorcycle moto = new TestMotorcycle();\n\n      moto.StartEngine();\n      moto.AddGas(15);\n      moto.Drive(5, 20);\n      double speed = moto.GetTopSpeed();\n      Console.WriteLine(\"My top speed is {0}\", speed);            \n   }\n}\n\nYou can also used named arguments instead of positional arguments when invoking a method. When using named arguments, you specify the parameter name followed by a colon (\":\") and the argument. Arguments to the method can appear in any order, as long as all required arguments are present. The following example uses named arguments to invoke the TestMotorcycle.Drive method. In this example, the named arguments are passed in the opposite order from the method's parameter list.\nC#\nusing System;"
    },
    {
        "page_index": 55,
        "chunk_index": 7,
        "text": "class TestMotorcycle : Motorcycle\n{\n   public override int Drive(int miles, int speed)\n   {\n      return (int) Math.Round( ((double)miles) / speed, 0);\n   }\n\n   public override double GetTopSpeed()\n   {\n      return 108.4;\n   }\n\n   static void Main()\n   {\n      \n      TestMotorcycle moto = new TestMotorcycle();\n      moto.StartEngine();\n      moto.AddGas(15);\n      var travelTime = moto.Drive(speed: 60, miles: 170);\n      Console.WriteLine(\"Travel time: approx. {0} hours\", travelTime);            \n   }\n}\n// The example displays the following output:\n//      Travel time: approx. 3 hours\n\nYou can invoke a method using both positional arguments and named arguments. However, a positional argument cannot follow a named argument. The following example invokes the TestMotorcycle.Drive method from the previous example using one positional argument and one named argument.\nC#\nvar travelTime = moto.Drive(170, speed: 55);"
    },
    {
        "page_index": 56,
        "chunk_index": 0,
        "text": "Lecture Slides:  ArrayList.pdf\n Recommended Online Resources:\n1. Channel 9 -  Understanding Arrays\n2. Channel 9 -    Working with Collections (this video touches topics related to Classes/Objects that we will cover later. Focus on how list works)"
    },
    {
        "page_index": 57,
        "chunk_index": 0,
        "text": "Arrays \nYou can store multiple variables of the same type in an array data structure. You declare an array by specifying the type of its elements. If you want the array to store elements of any type, you can specify object as its type. In the unified type system of C#, all types, predefined and user-defined, reference types and value types, inherit directly or indirectly from Object.\nC#\ntype[] arrayName;\n\nExample\nThe following example creates single-dimensional, multidimensional, and jagged arrays:\nC#\nclass TestArraysClass\n{\n    static void Main()\n    {\n        // Declare a single-dimensional array. \n        int[] array1 = new int[5];\n\n        // Declare and set array element values.\n        int[] array2 = new int[] { 1, 3, 5, 7, 9 };\n\n        // Alternative syntax.\n        int[] array3 = { 1, 2, 3, 4, 5, 6 };\n\n        // Declare a two dimensional array.\n        int[,] multiDimensionalArray1 = new int[2, 3];\n\n        // Declare and set array element values.\n        int[,] multiDimensionalArray2 = { { 1, 2, 3 }, { 4, 5, 6 } };\n\n        // Declare a jagged array.\n        int[][] jaggedArray = new int[6][];\n\n        // Set the values of the first array in the jagged array structure.\n        jaggedArray[0] = new int[4] { 1, 2, 3, 4 };\n    }\n}\n\nArray overview\nAn array has the following properties:\n\nAn array can be Single-Dimensional, Multidimensional or Jagged.\nThe number of dimensions and the length of each dimension are established when the array instance is created. These values can't be changed during the lifetime of the instance.\nThe default values of numeric array elements are set to zero, and reference elements are set to null.\nA jagged array is an array of arrays, and therefore its elements are reference types and are initialized to null.\nArrays are zero indexed: an array with n elements is indexed from 0 to n-1.\nArray elements can be of any type, including an array type.\nArray types are reference types derived from the abstract base type Array. Since this type implements IEnumerable and IEnumerable<T>, you can use foreach iteration on all arrays in C#."
    },
    {
        "page_index": 58,
        "chunk_index": 0,
        "text": "Lists and Collections \nFor many applications, you want to create and manage groups of related objects. There are two ways to group objects: by creating arrays of objects, and by creating collections of objects.\nArrays are most useful for creating and working with a fixed number of strongly-typed objects. \nCollections provide a more flexible way to work with groups of objects. Unlike arrays, the group of objects you work with can grow and shrink dynamically as the needs of the application change. For some collections, you can assign a key to any object that you put into the collection so that you can quickly retrieve the object by using the key.\nA collection is a class, so you must declare an instance of the class before you can add elements to that collection."
    },
    {
        "page_index": 58,
        "chunk_index": 1,
        "text": "If your collection contains elements of only one data type, you can use one of the classes in the System.Collections.Generic namespace. A generic collection enforces type safety so that no other data type can be added to it. When you retrieve an element from a generic collection, you do not have to determine its data type or convert it.\n \nUsing a Simple Collection\nThe examples in this section use the generic List<T> class, which enables you to work with a strongly typed list of objects.\nThe following example creates a list of strings and then iterates through the strings by using a foreach statement.\nC#\n// Create a list of strings.\nvar salmons = new List<string>();\nsalmons.Add(\"chinook\");\nsalmons.Add(\"coho\");\nsalmons.Add(\"pink\");\nsalmons.Add(\"sockeye\");"
    },
    {
        "page_index": 58,
        "chunk_index": 2,
        "text": "// Iterate through the list.\nforeach (var salmon in salmons)\n{\n    Console.Write(salmon + \" \");\n}\n// Output: chinook coho pink sockeye\n\nIf the contents of a collection are known in advance, you can use a collection initializer to initialize the collection. For more information, see Object and Collection Initializers.\nThe following example is the same as the previous example, except a collection initializer is used to add elements to the collection.\nC#\n// Create a list of strings by using a\n// collection initializer.\nvar salmons = new List<string> { \"chinook\", \"coho\", \"pink\", \"sockeye\" };\n\n// Iterate through the list.\nforeach (var salmon in salmons)\n{\n    Console.Write(salmon + \" \");\n}\n// Output: chinook coho pink sockeye"
    },
    {
        "page_index": 58,
        "chunk_index": 3,
        "text": "You can use a for statement instead of a foreach statement to iterate through a collection. You accomplish this by accessing the collection elements by the index position. The index of the elements starts at 0 and ends at the element count minus 1.\nThe following example iterates through the elements of a collection by using for instead of foreach.\nC#\n// Create a list of strings by using a\n// collection initializer.\nvar salmons = new List<string> { \"chinook\", \"coho\", \"pink\", \"sockeye\" };\n\nfor (var index = 0; index < salmons.Count; index++)\n{\n    Console.Write(salmons[index] + \" \");\n}\n// Output: chinook coho pink sockeye\n\nThe following example removes an element from the collection by specifying the object to remove.\nC#\n// Create a list of strings by using a\n// collection initializer.\nvar salmons = new List<string> { \"chinook\", \"coho\", \"pink\", \"sockeye\" };\n\n// Remove an element from the list by specifying\n// the object.\nsalmons.Remove(\"coho\");"
    },
    {
        "page_index": 58,
        "chunk_index": 4,
        "text": "// Iterate through the list.\nforeach (var salmon in salmons)\n{\n    Console.Write(salmon + \" \");\n}\n// Output: chinook pink sockeye\n\nThe following example removes elements from a generic list. Instead of a foreach statement, a for statement that iterates in descending order is used. This is because the RemoveAt method causes elements after a removed element to have a lower index value.\nC#\nvar numbers = new List<int> { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n\n// Remove odd numbers.\nfor (var index = numbers.Count - 1; index >= 0; index--)\n{\n    if (numbers[index] % 2 == 1)\n    {\n        // Remove the element by specifying\n        // the zero-based index in the list.\n        numbers.RemoveAt(index);\n    }\n}\n\n// Iterate through the list.\n// A lambda expression is placed in the ForEach method\n// of the List(T) object.\nnumbers.ForEach(\n    number => Console.Write(number + \" \"));\n// Output: 0 2 4 6 8"
    },
    {
        "page_index": 58,
        "chunk_index": 5,
        "text": "For the type of elements in the List<T>, you can also define your own class. In the following example, the Galaxy class that is used by the List<T> is defined in the code.\nC#\nprivate static void IterateThroughList()\n{\n    var theGalaxies = new List<Galaxy>\n        {\n            new Galaxy() { Name=\"Tadpole\", MegaLightYears=400},\n            new Galaxy() { Name=\"Pinwheel\", MegaLightYears=25},\n            new Galaxy() { Name=\"Milky Way\", MegaLightYears=0},\n            new Galaxy() { Name=\"Andromeda\", MegaLightYears=3}\n        };\n\n    foreach (Galaxy theGalaxy in theGalaxies)\n    {\n        Console.WriteLine(theGalaxy.Name + \"  \" + theGalaxy.MegaLightYears);\n    }\n\n    // Output:\n    //  Tadpole  400\n    //  Pinwheel  25\n    //  Milky Way  0\n    //  Andromeda  3\n}\n\npublic class Galaxy\n{\n    public string Name { get; set; }\n    public int MegaLightYears { get; set; }\n}"
    },
    {
        "page_index": 59,
        "chunk_index": 0,
        "text": "Before C# 9,  there was a lot of code just to output Hello, World! In C# 9 there is a simpler way and it is known as top-level programs. Let's compare the traditional minimum console app, as shown in the following code: \nusing System;\nclass Program\n{ static void Main(string[] args)\n      { \n           Console.WriteLine(\"Hello World!\"); \n      }\n}\n\nTo the new top-level program minimum console app, as shown in the following code: \nusing System;\nConsole.WriteLine(\"Hello World!\");\nThat is a lot simpler, right? If you had to start with a blank file and write all the statements yourself, this is better. During compilation, all the boilerplate code to define the Program class and its Main method is generated and wrapped around the statements you write. Any using statements still have to go at the top of the file. There can be only one file like this in a project. Personally, especially when teaching and learning C#, I plan to continue to use the traditional project template since it is true to reality.  For example, arguments can be passed into a console app. With a top-level program, you would need to know that the args parameter exists even though you cannot see it. \nFor more info, see https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-9.0/top-level-statements\nRead .NET 6 Template Changes: C# console app template generates top-level statements\nTutorial: Explore ideas using top-level statements to build code as you learn"
    },
    {
        "page_index": 60,
        "chunk_index": 0,
        "text": ".NET is a free, cross-platform, open-source developer platform for building many kinds of applications. It can run programs written in multiple languages, with C# being the most popular. It relies on a high-performance runtime that is used in production by many high-scale apps.\n\n.NET ecosystem\n\nThere are multiple variants of .NET, each supporting a different type of app. The reason for multiple variants is part historical, part technical.\n.NET implementations:\n\n.NET Framework -- The original .NET. It provides access to the broad capabilities of Windows and Windows Server. It is actively supported, in maintenance.\nMono -- The original community and open source .NET. A cross-platform implementation of .NET Framework. Actively supported for Android, iOS, and WebAssembly.\n.NET (Core) -- Modern .NET. A cross-platform and open source implementation of .NET, rethought for the cloud age while remaining significantly compatible with .NET Framework. Actively supported for Linux, macOS, and Windows.\n\nThe .NET Framework and .NET Core\n.NET Core works similarly to the .NET Framework. In fact, many of the code and techniques that are presented in this course the same regardless of whether you use the .NET Framework or .NET Core. The main difference between these platforms is that the .NET Framework is older and only supports Windows. On the other hand, .NET Core is newer and cross-platform. As a result, .NET Core can run on Windows, macOS, and Linux. Because Microsoft ended development of the .NET Framework at version 4.8, .NET Core is the future of .NET development.\nIn fact, starting with version 5, .NET Core is now just called .NET (no Core in the name). Because .NET combines the best features of the .NET Framework and previous versions of .NET Core, it provides an easy migration path for .NET Framework applications, and it provides a foundation for future development of the .NET platform.\nBoth the .NET Framework and .NET provide a set of class libraries. These class libraries consist of segments of pre-written code called classes that provide many of the functions that you need for developing .NET applications. For instance, the WPF classes are used for developing WPF apps. The ASP.NET and ASP.NET Core classes are used for developing Web Forms apps. The EF and EF Core classes are used for developing apps that access databases. And other classes let you manage security, access files, and perform many other functions.\nThe .NET Framework and .NET also provide a common infrastructure that applications written in a .NET language such as C# can use to run on various operating systems and hardware platforms. This infrastructure includes the Common Language Runtime, the .NET languages, and the compilers for those languages.\nThe Common Language Runtime (CLR) provides the services that are needed for executing any application that’s developed with one of the .NET languages. This is possible because all the .NET languages compile to a common intermediate language. The CLR also provides the Common Type System that defines the data types that are used by all .NET languages. Because all the .NET applications are managed by the CLR, they are sometimes referred to as managed applications. \nBuild apps with .NET\n.NET has support for building many kinds of apps, including client, cloud, and gaming.\n\nClient apps Desktop apps\nMobile\nGames Cloud apps .NET Aspire\nServerless functions\nWeb and microservices Other app types Console apps\nInternet of Things (IoT)\nMachine learning\nWindows services"
    },
    {
        "page_index": 61,
        "chunk_index": 0,
        "text": "A Warm Welcome!\nI'm glad to see you've enrolled in the InfoTC 4400 - C#/.NET Development this semester. Before you jump into the course content, I'd like to take you through a short orientation. It will help you acclimate to course organization, learn about the topics covered in this course, and understand (and set) your course expectations.\n\nCourse Description\nThis course focuses on developing Windows applications using C# programming language.  The following topics are covered:\n\nIntroduction to C#, Microsoft Visual Studio, and the .NET platform\nObject-Oriented Programming with C#\nAdvanced C# Programming\nDesktop application for Windows"
    },
    {
        "page_index": 61,
        "chunk_index": 1,
        "text": "Course Schedules\nThe course officially starts on Tue Jan. 21, when your access to Canvas and the first week's modules are available.  Each week you are provided with new modules on Sunday and the work needs to be completed by the following Friday.  In general, there is  one coding assignment and one quiz for each module.\nThere is no time limit in taking the quiz before the deadline. You can ask questions, look things up, then come back to continue. Your work should be auto-saved. You can only submit once though. So submit only after you are completely done. If you need help, please ask. Students are encouraged to start working on the module early in the week, and utilize the TA office hours during the week. Assistance during weekend is extremely limited."
    },
    {
        "page_index": 61,
        "chunk_index": 2,
        "text": "Late assignments will receive a 10% deduction of the assignment total score for the first day of being, and 20% per day for the 2nd and 3rd day.  After 3 full days until Stop Day, you will see a total of 50% reduction of points on the late work, plus any lost points from the rubric. This late policy is only for coding challenges and assignments. Quizzes, exams, and/or any other assignment must be completed by the due date/time to be considered for credit.\n \nContacts\nInstructor: Dr. Fang Wang  Office: 2437H Lafferre Hall    Phone: 884-8747    Email: wangfan@missouri.edu   \nTA: \nAmith Nalmas (anr79@missouri.edu)Office hour: Mon/Wed/Fri 2-4pmZoom meeting: https://umsystem.zoom.us/j/91603648117?pwd=MFpnbWpFTlN1dVg5NysvUlIrZ0pDQT09Links to an external site.\n \nCaden Hicks (cjhbv4@missouri.edu)Office hour: Tuesday, Thursday at 10 am - 12 pm and Friday at 11 am - 1 pmZoom meeting: https://umsystem.zoom.us/j/5240824097?pwd=bys0VHRWTGlnTDV2UC96OUhZMVNWUT09Links to an external site."
    },
    {
        "page_index": 61,
        "chunk_index": 3,
        "text": "Course Discord Server:  https://discord.gg/9UZMuGKxMd\n \nQuestion and Answers\nQ: Do I have to be on campus for anything?\nA: No. This course is entirely online.\n \nQ: Are there any tests I actually have to be on campus for?\nA: No. Everything you need to do will be posted on Canvas. Work for all assignments and exams will be submitted on Canvas.\n \nQ: Where to get software used for the course?\nA: There are multiple ways to do that."
    },
    {
        "page_index": 61,
        "chunk_index": 4,
        "text": "Visual Studio Downloads\nLafferre Hall C1206 & C1205 computers have VS installed.\nCollege of Engineering RemoteApps servers allow students, faculty, and staff to utilize software remotely without installing the software physically on their machines. http://remoteapps.missouri.edu/ (you need to VPN to campus network if you are off campus)\nEngineering students and faculty are eligible to download free Microsoft software. For Microsoft software login to MS Azure Dev Tools for Teaching. \nRider: Cross-Platform .NET IDE from JetBrains with Free Educational Licenses"
    },
    {
        "page_index": 61,
        "chunk_index": 5,
        "text": "Q: How do I get help if I need it?\nA: Zoom video conference during office hours. Email or use Discord to get in touch with instructor and TA anytime.\n \nQ: Is it OK to take code from online resources or other people and submit as my own work? \nYou are encouraged to look for resources online and work together in an effort to comprehend the course material. For instance, you may discuss generalities with classmates or someone outside the class when trying to understand the assignments. However, you should work individually when working out the solutions. Never copy solutions of others or any solutions you find anywhere, including online. Moreover, on assignments, quizzes and exams, any person found to be cheating will receive a 0, and the full extent of the MU rules on academic dishonesty will be followed. No other warnings will be given or should be necessary."
    },
    {
        "page_index": 61,
        "chunk_index": 6,
        "text": "If you have feedback that could help us improve the course or the course experience while you are taking the course, please let us know.\nI hope you have a great semester!"
    },
    {
        "page_index": 62,
        "chunk_index": 0,
        "text": "Our readings, materials, and discussion this week are aimed at helping us get started with Visual Studio IDE.\n Objectives\nAfter completing this week's work, you will be able to:\n\nLocate different components in Visual Studio IDE.\nDevelop computer programs using VS IDE.\nDefine the concepts of variables.\nDefine different Boolean operations.\nApply variables and Boolean operations in programming\n\n \n M1 Activities\n\nWatch Video Lectures\nRead Programming Guide,\nRead Assessment and Rubrics\nComplete M1 Quiz and Assignments"
    },
    {
        "page_index": 63,
        "chunk_index": 0,
        "text": "For more information about installing the latest version of Visual Studio, see Install Visual Studio (Links to an external site.).\n \n Video lectures:"
    },
    {
        "page_index": 64,
        "chunk_index": 0,
        "text": "Microsoft Developer Software & Visual Studio\nChoose one of the ways that fits your need best.\n1. For free Visual Studio Community version, go to Visual Studio 2022 Download. Visual Studio Community version is sufficient for this course.\n2. College of Engineering RemoteApps servers allow students, faculty, and staff to utilize software remotely without installing the software physically on their machines. http://remoteapps.missouri.edu/\nTutorials on how to use RemoteApps: https://mailmissouri.sharepoint.com/sites/COEIT/SitePages/CENGR-IT-Support---Public.aspx?csf=1&web=1&e=OreXRN&cid=3a83ad74-d79b-4402-ba7b-c9ba4352f802\n \n3. Lafferre Hall C1206 C1205 computers have VS2022 installed\n \n4. For Visual Studio Enterprise version, follow the steps below.\nMicrosoft software is available through the Microsoft Azure Dev Tools for Teaching.\nAccording to the page at https://azureforeducation.microsoft.com/devtools:\n\nStudents—you’re almost there! The developer tools and learning resources that were previously part of your Imagine account are now available with Azure Dev Tools for Teaching. Sign in using the button below—you’ll be taken to a page requesting you to sign in using a Microsoft Account. Learn about Microsoft Accounts here.\nNote: Please use the email you provided for your previous Imagine subscription access when creating a new Microsoft Account.\n\nWhen you click the Sign In button you sign in using an existing Microsoft account or create a new account. The important thing is that you use your MU email address. Since your student email account is a Microsoft account, you may be able to directly log in. Or, if not, you will need to create an account using your email address.\nOnce you log in, a page like the following should be displayed.  \nOnce you leave the Education - Overview page by clicking on links in the menu in the Azure portal, I am not sure how to navigate back to it. If you leave the page and need to get back to it, just go to the URL to login again https://azureforeducation.microsoft.com/devtools.\nClick the Software link to view the Microsoft Software that is available. Visual Studio Enterprise is the first one in the list."
    },
    {
        "page_index": 65,
        "chunk_index": 0,
        "text": "Welcome to the Visual Studio IDE\nAn integrated development environment (IDE) is a feature-rich program that supports many aspects of software development. The Visual Studio IDE is a creative launching pad that you can use to edit, debug, and build code, and then publish an app. Over and above the standard editor and debugger that most IDEs provide, Visual Studio includes compilers, code completion tools, graphical designers, and many more features to enhance the software development process. The preceding image shows Visual Studio with an open project that shows key windows and their functionality: In Solution Explorer, at upper right, you can view, navigate, and manage your code files. Solution Explorer can help organize your code by grouping the files into solutions and projects. The central editor window, where you'll probably spend most of your time, displays file contents. In the editor window, you can edit code or design a user interface such as a window with buttons and text boxes. In Git Changes at lower right, you can track work items and share code with others by using version control technologies like Git and GitHub.  \nIntelliSense in Visual Studio\nIntelliSense is a code-completion aid that includes a number of features: List Members, Parameter Info, Quick Info, and Complete Word. These features help you to learn more about the code you're using, keep track of the parameters you're typing, and add calls to properties and methods with only a few keystrokes.\n \nVisual Studio Tutorial | C#"
    },
    {
        "page_index": 66,
        "chunk_index": 0,
        "text": "Visual Studio and GitHub\nVisual Studio version control docs\n\nCreate a Git repository from Visual Studio\nClone a Git repository in Visual Studio"
    },
    {
        "page_index": 67,
        "chunk_index": 0,
        "text": "Lecture Slides: M1_Variables.pdf\n Video Lectures: \nPart 1\n\n \nPart 2"
    },
    {
        "page_index": 68,
        "chunk_index": 0,
        "text": "Types and variables\nThere are two kinds of types in C#: value types and reference types. Variables of value types directly contain their data whereas variables of reference types store references to their data, the latter being known as objects. With reference types, it is possible for two variables to reference the same object and thus possible for operations on one variable to affect the object referenced by the other variable. With value types, the variables each have their own copy of the data, and it is not possible for operations on one to affect the other (except in the case of ref and out parameter variables).\nC#’s value types are further divided into simple types, enum types, struct types, and nullable value types. C#’s reference types are further divided into class types, interface types, array types, and delegate types.\nThe following provides an overview of C#’s type system.\n\nValue types (Links to an external site.)\n\nSimple types (Links to an external site.)\n\nSigned integral: sbyte, short, int, long\nUnsigned integral: byte, ushort, uint, ulong\nUnicode characters: char\nIEEE binary floating-point: float, double\nHigh-precision decimal floating-point: decimal\nBoolean: bool Enum types (Links to an external site.)\n\nUser-defined types of the form enum E {...} Struct types (Links to an external site.)\n\nUser-defined types of the form struct S {...} Nullable value types (Links to an external site.)\n\nExtensions of all other value types with a null value Reference types (Links to an external site.)\n\nClass types (Links to an external site.)\n\nUltimate base class of all other types: object\nUnicode strings: string\nUser-defined types of the form class C {...} Interface types (Links to an external site.)\n\nUser-defined types of the form interface I {...} Array types (Links to an external site.)\n\nSingle- and multi-dimensional, for example, int[] and int[,] Delegate types (Links to an external site.)\n\nUser-defined types of the form delegate int D(...) For more information about numeric types, see Integral types (Links to an external site.) and Floating-point types table (Links to an external site.).\nC#’s bool type is used to represent Boolean values—values that are either true or false.\nCharacter and string processing in C# uses Unicode encoding. The char type represents a UTF-16 code unit, and the string type represents a sequence of UTF-16 code units.\nC# programs use type declarations to create new types. A type declaration specifies the name and the members of the new type. Five of C#’s categories of types are user-definable: class types, struct types, interface types, enum types, and delegate types.\n \nIdentifier names\nAn identifier is the name you assign to a type (class, interface, struct, delegate, or enum), member, variable, or namespace. Valid identifiers must follow these rules:\n\nIdentifiers must start with a letter, or _.\nIdentifiers may contain Unicode letter characters, decimal digit characters, Unicode connecting characters, Unicode combining characters, or Unicode formatting characters. For more information on Unicode categories, see the Unicode Category Database (Links to an external site.). You can declare identifiers that match C# keywords by using the @ prefix on the identifier. The @ is not part of the identifier name. For example, @if declares an identifier named if. These verbatim identifiers (Links to an external site.) are primarily for interoperability with identifiers declared in other languages.\n\nFor a complete definition of valid identifiers, see the Identifiers topic in the C# Language Specification (Links to an external site.).\n \nNaming conventions \nIn addition to the rules, there are a number of identifier naming conventions (Links to an external site.) used throughout the .NET APIs. By convention, C# programs use PascalCase for type names, namespaces, and all public members. In addition, the following conventions are common:\n\nInterface names start with a capital I.\nAttribute types end with the word Attribute.\nEnum types use a singular noun for non-flags, and a plural noun for flags.\nIdentifiers should not contain two consecutive _ characters. Those names are reserved for compiler generated identifiers."
    },
    {
        "page_index": 69,
        "chunk_index": 0,
        "text": "Lecture Slides: M1_Boolean.pdf\n Video Lectures: \nBoonlean Operations and Comparison Operators\n\n \nConditional Statements\n\n \n Recommended Online Resources:\n1. Channel 9 - The if Decision Statement\n2. Channel 9 -  Operators, Expressions, and Statements"
    },
    {
        "page_index": 70,
        "chunk_index": 0,
        "text": "Boolean logical operators \nThe following operators perform logical operations with bool operands:\n\nUnary ! (logical negation) operator.\nBinary & (logical AND), | (logical OR), and ^ (logical exclusive OR) operators. Those operators always evaluate both operands.\nBinary && (conditional logical AND) and || (conditional logical OR) operators. Those operators evaluate the right-hand operand only if it's necessary.\n\nFor operands of the integral numeric types, the &, |, and ^ operators perform bitwise logical operations. For more information, see Bitwise and shift operators.\nLogical negation operator !\nThe unary prefix ! operator computes logical negation of its operand. That is, it produces true, if the operand evaluates to false, and false, if the operand evaluates to true:\nC#\nbool passed = false;\nConsole.WriteLine(!passed);  // output: True\nConsole.WriteLine(!true);    // output: False"
    },
    {
        "page_index": 70,
        "chunk_index": 1,
        "text": "Beginning with C# 8.0, the unary postfix ! operator is the null-forgiving operator.\nLogical AND operator &\nThe & operator computes the logical AND of its operands. The result of x & y is true if both x and y evaluate to true. Otherwise, the result is false.\nThe & operator evaluates both operands even if the left-hand operand evaluates to false, so that the operation result is false regardless of the value of the right-hand operand.\nIn the following example, the right-hand operand of the & operator is a method call, which is performed regardless of the value of the left-hand operand:\nC#\nbool SecondOperand() \n{\n    Console.WriteLine(\"Second operand is evaluated.\");\n    return true;\n}\n\nbool a = false & SecondOperand();\nConsole.WriteLine(a);\n// Output:\n// Second operand is evaluated.\n// False\n\nbool b = true & SecondOperand();\nConsole.WriteLine(b);\n// Output:\n// Second operand is evaluated.\n// True"
    },
    {
        "page_index": 70,
        "chunk_index": 2,
        "text": "The conditional logical AND operator && also computes the logical AND of its operands, but doesn't evaluate the right-hand operand if the left-hand operand evaluates to false.\nFor operands of the integral numeric types, the & operator computes the bitwise logical AND of its operands. The unary & operator is the address-of operator.\nLogical exclusive OR operator ^\nThe ^ operator computes the logical exclusive OR, also known as the logical XOR, of its operands. The result of x ^ y is true if x evaluates to true and y evaluates to false, or x evaluates to false and y evaluates to true. Otherwise, the result is false. That is, for the bool operands, the ^ operator computes the same result as the inequality operator !=.\nC#\nConsole.WriteLine(true ^ true);    // output: False\nConsole.WriteLine(true ^ false);   // output: True\nConsole.WriteLine(false ^ true);   // output: True\nConsole.WriteLine(false ^ false);  // output: False"
    },
    {
        "page_index": 70,
        "chunk_index": 3,
        "text": "For operands of the integral numeric types, the ^ operator computes the bitwise logical exclusive OR of its operands.\nLogical OR operator |\nThe | operator computes the logical OR of its operands. The result of x | y is true if either x or y evaluates to true. Otherwise, the result is false.\nThe | operator evaluates both operands even if the left-hand operand evaluates to true, so that the operation result is true regardless of the value of the right-hand operand.\nIn the following example, the right-hand operand of the | operator is a method call, which is performed regardless of the value of the left-hand operand:\nC#\nbool SecondOperand() \n{\n    Console.WriteLine(\"Second operand is evaluated.\");\n    return true;\n}\n\nbool a = true | SecondOperand();\nConsole.WriteLine(a);\n// Output:\n// Second operand is evaluated.\n// True\n\nbool b = false | SecondOperand();\nConsole.WriteLine(b);\n// Output:\n// Second operand is evaluated.\n// True"
    },
    {
        "page_index": 70,
        "chunk_index": 4,
        "text": "The conditional logical OR operator || also computes the logical OR of its operands, but doesn't evaluate the right-hand operand if the left-hand operand evaluates to true.\nFor operands of the integral numeric types, the | operator computes the bitwise logical OR of its operands.\nConditional logical AND operator &&\nThe conditional logical AND operator &&, also known as the \"short-circuiting\" logical AND operator, computes the logical AND of its operands. The result of x && y is true if both x and y evaluate to true. Otherwise, the result is false. If x evaluates to false, y is not evaluated.\nIn the following example, the right-hand operand of the && operator is a method call, which isn't performed if the left-hand operand evaluates to false:\nC#\nbool SecondOperand()\n{\n    Console.WriteLine(\"Second operand is evaluated.\");\n    return true;\n}\n\nbool a = false && SecondOperand();\nConsole.WriteLine(a);\n// Output:\n// False"
    },
    {
        "page_index": 70,
        "chunk_index": 5,
        "text": "bool b = true && SecondOperand();\nConsole.WriteLine(b);\n// Output:\n// Second operand is evaluated.\n// True\n\nThe logical AND operator & also computes the logical AND of its operands, but always evaluates both operands.\nConditional logical OR operator ||\nThe conditional logical OR operator ||, also known as the \"short-circuiting\" logical OR operator, computes the logical OR of its operands. The result of x || y is true if either x or y evaluates to true. Otherwise, the result is false. If x evaluates to true, y is not evaluated.\nIn the following example, the right-hand operand of the || operator is a method call, which isn't performed if the left-hand operand evaluates to true:\n\nbool SecondOperand()\n{\n    Console.WriteLine(\"Second operand is evaluated.\");\n    return true;\n}\n\nbool a = true || SecondOperand();\nConsole.WriteLine(a);\n// Output:\n// True\n\nbool b = false || SecondOperand();\nConsole.WriteLine(b);\n// Output:\n// Second operand is evaluated.\n// True"
    },
    {
        "page_index": 70,
        "chunk_index": 6,
        "text": "The logical OR operator | also computes the logical OR of its operands, but always evaluates both operands.\nNullable Boolean logical operators\nFor bool? operands, the & and | operators support the three-valued logic. The semantics of these operators is defined by the following table: x\ny\nx&y\nx|y true\ntrue\ntrue\ntrue true\nfalse\nfalse\ntrue true\nnull\nnull\ntrue false\ntrue\nfalse\ntrue false\nfalse\nfalse\nfalse false\nnull\nfalse\nnull null\ntrue\nnull\ntrue null\nfalse\nfalse\nnull null\nnull\nnull"
    },
    {
        "page_index": 70,
        "chunk_index": 7,
        "text": "null\ntrue null\nfalse\nfalse\nnull null\nnull\nnull\nnull The behavior of those operators differs from the typical operator behavior with nullable value types. Typically, an operator which is defined for operands of a value type can be also used with operands of the corresponding nullable value type. Such an operator produces null if any of its operands evaluates to null. However, the & and | operators can produce non-null even if one of the operands evaluates to null. For more information about the operator behavior with nullable value types, see the Lifted operators section of the Nullable value types article.\nYou can also use the ! and ^ operators with bool? operands, as the following example shows:\nC#\nbool? test = null;\nDisplay(!test);         // output: null\nDisplay(test ^ false);  // output: null\nDisplay(test ^ null);   // output: null\nDisplay(true ^ null);   // output: null"
    },
    {
        "page_index": 70,
        "chunk_index": 8,
        "text": "void Display(bool? b) => Console.WriteLine(b is null ? \"null\" : b.Value.ToString());\n\nThe conditional logical operators && and || don't support bool? operands.\nCompound assignment<\nFor a binary operator op, a compound assignment expression of the form\nC#\nx op= y\n\nis equivalent to\nC#\nx = x op y\n\nexcept that x is only evaluated once.\nThe &, |, and ^ operators support compound assignment, as the following example shows:\nC#\nbool test = true;\ntest &= false;\nConsole.WriteLine(test);  // output: False\n\ntest |= true;\nConsole.WriteLine(test);  // output: True\n\ntest ^= false;\nConsole.WriteLine(test);  // output: True\n\nThe conditional logical operators && and || don't support compound assignment.\nOperator precedence\nThe following list orders logical operators starting from the highest precedence to the lowest:\n\nLogical negation operator !\nLogical AND operator &\nLogical exclusive OR operator ^\nLogical OR operator |\nConditional logical AND operator &&\nConditional logical OR operator ||"
    },
    {
        "page_index": 70,
        "chunk_index": 9,
        "text": "Use parentheses, (), to change the order of evaluation imposed by operator precedence:\nC#\nConsole.WriteLine(true | true & false);   // output: True\nConsole.WriteLine((true | true) & false); // output: False\n\nbool Operand(string name, bool value)\n{\n    Console.WriteLine($\"Operand {name} is evaluated.\");\n    return value;\n}\n\nvar byDefaultPrecedence = Operand(\"A\", true) || Operand(\"B\", true) && Operand(\"C\", false);\nConsole.WriteLine(byDefaultPrecedence);\n// Output:\n// Operand A is evaluated.\n// True\n\nvar changedOrder = (Operand(\"A\", true) || Operand(\"B\", true)) && Operand(\"C\", false);\nConsole.WriteLine(changedOrder);\n// Output:\n// Operand A is evaluated.\n// Operand C is evaluated.\n// False\n\nFor the complete list of C# operators ordered by precedence level, see the Operator precedence section of the C# operators article."
    },
    {
        "page_index": 71,
        "chunk_index": 0,
        "text": "Lecture Slides: FirstWPF.pdf\n Video Lectures: \n\nRecommended Online Resources:\n 1. WinUI 3 app, WPF, UWP, Windows Forms, or Cross-platform options: Get started with Windows: Selecting a development technology\n2. Channel 9 -  Creating Your First C# Program \n3. Channel 9 -  Understanding Your First C# Program"
    },
    {
        "page_index": 72,
        "chunk_index": 0,
        "text": "Tutorial: Create a simple C# console app in Visual Studio"
    },
    {
        "page_index": 73,
        "chunk_index": 0,
        "text": "What is Windows Presentation Foundation - WPF .NET\nTutorial: Create a new WPF app with .NET"
    },
    {
        "page_index": 74,
        "chunk_index": 0,
        "text": "What's a Universal Windows Platform (UWP) app?\nTutorial: Create your first Universal Windows Platform application in Visual Studio with XAML and C#"
    },
    {
        "page_index": 75,
        "chunk_index": 0,
        "text": "Developing for Windows with the Windows App SDK\nCreate your first WinUI 3 (Windows App SDK) project\nTutorial: Create a simple photo viewer with WinUI 3 (C#)"
    }
]