[
    {
        "title": "M8 Roadmap & Objectives",
        "created_at": "2025-01-21T04:54:42Z",
        "url": "m8-roadmap-and-objectives",
        "editing_roles": "teachers",
        "page_id": 4602850,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/m8-roadmap-and-objectives",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:42Z",
        "locked_for_user": false,
        "body": "M8\u00a0Objectives\n\nAfter completing this week's work, you will be able to:\n\nCreate, read, write and update files. \nUse classes File and Directory to obtain information about files and directories on your computer. \nUse classes FileStream, StreamReader and StreamWriter to read text from and write text to files. \n\nUse classes FileStream and BinaryFormatter to read objects from and write objects to files -\u00a0serialize and deserialize an object\u00a0\n\nUse\u00a0OpenFileDialog and SaveDialog controls to display standard Windows dialog boxes for opening and saving files\nUse \"Using\" statement to release resources\n\n\u00a0\n\n\u00a0M8 Activities\u00a0 Watch Video Lectures\nRead Lecture Slides & Programming Guide,\nPractice with Sample Code\nComplete M8\u00a0 Quiz and Assignment"
    },
    {
        "title": "8.1 File Streams",
        "created_at": "2025-01-21T04:54:32Z",
        "url": "8-dot-1-file-streams",
        "editing_roles": "teachers",
        "page_id": 4602777,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/8-dot-1-file-streams",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:32Z",
        "locked_for_user": false,
        "body": "Lecture Slides: FileStream.pdf\n\u00a0Sample Code: Grader.zip\n\u00a0Video Lectures :\u00a0\u00a0\n- FileStream\n\n- Grader Project Walkthrough"
    },
    {
        "title": "OpenFileDialog Programming Guide",
        "created_at": "2025-01-21T04:54:43Z",
        "url": "openfiledialog-programming-guide",
        "editing_roles": "teachers",
        "page_id": 4602860,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/openfiledialog-programming-guide",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:43Z",
        "locked_for_user": false,
        "body": "Note: WPF .NET 7.0, follow How to open a common dialog box (WPF .NET)\nHow to: Open files with the OpenFileDialog\nThe\u00a0System.Windows.Forms.OpenFileDialog\u00a0component opens the Windows dialog box for browsing and selecting files. To open and read the selected files, you can use the\u00a0OpenFileDialog.OpenFile\u00a0method, or create an instance of the\u00a0System.IO.StreamReader\u00a0class. The following examples show both approaches.\nIn .NET Framework, to get or set the\u00a0FileName\u00a0property requires a privilege level granted by the\u00a0System.Security.Permissions.FileIOPermission\u00a0class. The examples run a\u00a0FileIOPermission\u00a0permission check, and can throw an exception due to insufficient privileges if run in a partial-trust context. For more information, see\u00a0Code access security basics.\nYou can build and run these examples as .NET Framework apps from the C# or Visual Basic command line. For more information, see\u00a0Command-line building with csc.exe\u00a0or\u00a0Build from the command line.\nStarting with .NET Core 3.0, you can also build and run the examples as Windows .NET Core apps from a folder that has a .NET Core Windows Forms\u00a0<folder name>.csproj\u00a0project file.\nExample: Read a file as a stream with StreamReade\nThe following example uses the Windows Forms\u00a0Button\u00a0control's\u00a0Click\u00a0event handler to open the\u00a0OpenFileDialog\u00a0with the\u00a0ShowDialog\u00a0method. After the user chooses a file and selects\u00a0OK, an instance of the\u00a0StreamReader\u00a0class reads the file and displays its contents in the form's text box. For more information about reading from file streams, see\u00a0FileStream.BeginRead\u00a0and\u00a0FileStream.Read.\nC#\nusing System;\nusing System.Drawing;\nusing System.IO;\nusing System.Security;\nusing System.Windows.Forms;\n\npublic class OpenFileDialogForm : Form\n{\n    [STAThread]\n    public static void Main()\n    {\n        Application.SetCompatibleTextRenderingDefault(false);\n        Application.EnableVisualStyles();\n        Application.Run(new OpenFileDialogForm());\n    }\n\n    private Button selectButton;\n    private OpenFileDialog openFileDialog1;\n    private TextBox textBox1;\n\n    public OpenFileDialogForm()\n    {\n        openFileDialog1 = new OpenFileDialog();\n        selectButton = new Button\n        {\n            Size = new Size(100, 20),\n            Location = new Point(15, 15),\n            Text = \"Select file\"\n        };\n        selectButton.Click += new EventHandler(SelectButton_Click);\n        textBox1 = new TextBox\n        {\n            Size = new Size(300, 300),\n            Location = new Point(15, 40),\n            Multiline = true,\n            ScrollBars = ScrollBars.Vertical\n        };\n        ClientSize = new Size(330, 360);\n        Controls.Add(selectButton);\n        Controls.Add(textBox1);\n    }\n    private void SetText(string text)\n    {\n        textBox1.Text = text;\n    }\n    private void SelectButton_Click(object sender, EventArgs e)\n    {\n        if (openFileDialog1.ShowDialog() == DialogResult.OK)\n        {\n            try\n            {\n                var sr = new StreamReader(openFileDialog1.FileName);\n                SetText(sr.ReadToEnd());\n            }\n            catch (SecurityException ex)\n            {\n                MessageBox.Show($\"Security error.\\n\\nError message: {ex.Message}\\n\\n\" +\n                $\"Details:\\n\\n{ex.StackTrace}\");\n            }\n        }\n    }\n}\n\nExample: Open a file from a filtered selection with OpenFile\nThe following example uses the\u00a0Button\u00a0control's\u00a0Click\u00a0event handler to open the\u00a0OpenFileDialog\u00a0with a filter that shows only text files. After the user chooses a text file and selects\u00a0OK, the\u00a0OpenFile\u00a0method is used to open the file in Notepad.\nC#\nusing System;\nusing System.ComponentModel;\nusing System.Diagnostics;\nusing System.Drawing;\nusing System.IO;\nusing System.Security;\nusing System.Windows.Forms;\n\npublic class OpenFileDialogForm : Form\n{\n    [STAThread]\n    public static void Main()\n    {\n        Application.SetCompatibleTextRenderingDefault(false);\n        Application.EnableVisualStyles();\n        Application.Run(new OpenFileDialogForm());\n    }\n\n    private Button selectButton;\n    private OpenFileDialog openFileDialog1;\n\n    public OpenFileDialogForm()\n    {\n        openFileDialog1 = new OpenFileDialog()\n        {\n            FileName = \"Select a text file\",\n            Filter = \"Text files (*.txt)|*.txt\",\n            Title = \"Open text file\"\n        };\n\n        selectButton = new Button()\n        {\n            Size = new Size(100, 20),\n            Location = new Point(15, 15),\n            Text = \"Select file\"\n        };\n        selectButton.Click += new EventHandler(selectButton_Click);\n        Controls.Add(selectButton);\n    }\n\n    private void selectButton_Click(object sender, EventArgs e)\n    {\n        if (openFileDialog1.ShowDialog() == DialogResult.OK)\n        {\n            try\n            {\n                var filePath = openFileDialog1.FileName;\n                using (Stream str = openFileDialog1.OpenFile())\n                {\n                    Process.Start(\"notepad.exe\", filePath);\n                }\n            }\n            catch (SecurityException ex)\n            {\n                MessageBox.Show($\"Security error.\\n\\nError message: {ex.Message}\\n\\n\" +\n                $\"Details:\\n\\n{ex.StackTrace}\");\n            }\n        }\n    }\n}"
    },
    {
        "title": "SaveFileDialog Programming Guide",
        "created_at": "2025-01-21T04:54:44Z",
        "url": "savefiledialog-programming-guide",
        "editing_roles": "teachers",
        "page_id": 4602865,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/savefiledialog-programming-guide",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:44Z",
        "locked_for_user": false,
        "body": "How to: Save Files Using the SaveFileDialog Component\nThe\u00a0SaveFileDialog\u00a0component allows users to browse the file system and select files to be saved. The dialog box returns the path and name of the file the user has selected in the dialog box. However, you must write the code to actually write the files to disk.\nTo save a file using the SaveFileDialog component Display the\u00a0Save File\u00a0dialog box and call a method to save the file selected by the user.\nUse the\u00a0SaveFileDialog\u00a0component's\u00a0OpenFile\u00a0method to save the file. This method gives you a\u00a0Stream\u00a0object you can write to.\nThe example below uses the\u00a0DialogResult\u00a0property to get the name of the file, and the\u00a0OpenFile\u00a0method to save the file. The\u00a0OpenFile\u00a0method gives you a stream to write the file to.\nIn the example below, there is a\u00a0Button\u00a0control with an image assigned to it. When you click the button, a\u00a0SaveFileDialog\u00a0component is instantiated with a filter that allows files of type .gif, .jpeg, and .bmp. If a file of this type is selected in the Save File dialog box, the button's image is saved.\n\n\u00a0Important\nTo get or set the\u00a0FileName\u00a0property, your assembly requires a privilege level granted by the\u00a0System.Security.Permissions.FileIOPermission\u00a0class. If you are running in a partial-trust context, the process might throw an exception due to insufficient privileges. For more information, see\u00a0Code Access Security Basics.\n\nThe example assumes your form has a\u00a0Button\u00a0control with its\u00a0Image\u00a0property set to a file of type .gif, .jpeg, or .bmp.\n\n\u00a0Note\nThe\u00a0FileDialog\u00a0class's\u00a0FilterIndex\u00a0property (which, due to inheritance, is part of the\u00a0SaveFileDialog\u00a0class) uses a one-based index. This is important if you are writing code to save data in a specific format (for example, saving a file in plain text versus binary format). This property is featured in the example below.\n\nC#\nprivate void button2_Click(object sender, System.EventArgs e)\n{\n    // Displays a SaveFileDialog so the user can save the Image\n    // assigned to Button2.\n    SaveFileDialog saveFileDialog1 = new SaveFileDialog();\n    saveFileDialog1.Filter = \"JPeg Image|*.jpg|Bitmap Image|*.bmp|Gif Image|*.gif\";\n    saveFileDialog1.Title = \"Save an Image File\";\n    saveFileDialog1.ShowDialog();\n\n    // If the file name is not an empty string open it for saving.\n    if(saveFileDialog1.FileName != \"\")\n    {\n      // Saves the Image via a FileStream created by the OpenFile method.\n      System.IO.FileStream fs =\n          (System.IO.FileStream)saveFileDialog1.OpenFile();\n      // Saves the Image in the appropriate ImageFormat based upon the\n      // File type selected in the dialog box.\n      // NOTE that the FilterIndex property is one-based.\n      switch(saveFileDialog1.FilterIndex)\n      {\n          case 1 :\n          this.button2.Image.Save(fs,\n            System.Drawing.Imaging.ImageFormat.Jpeg);\n          break;\n\n          case 2 :\n          this.button2.Image.Save(fs,\n            System.Drawing.Imaging.ImageFormat.Bmp);\n          break;\n\n          case 3 :\n          this.button2.Image.Save(fs,\n            System.Drawing.Imaging.ImageFormat.Gif);\n          break;\n      }\n\n    fs.Close();\n    }\n}\n\n(Visual C#) Place the following code in the form's constructor to register the event handler.\nC#\nthis.button2.Click += new System.EventHandler(this.button2_Click);"
    },
    {
        "title": "8.2 Serialization",
        "created_at": "2025-01-21T04:54:32Z",
        "url": "8-dot-2-serialization",
        "editing_roles": "teachers",
        "page_id": 4602778,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/8-dot-2-serialization",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:32Z",
        "locked_for_user": false,
        "body": "Lecture Slides: Serialization.pdf\n\u00a0Sample Code: SerialData.zip\n\u00a0Video Lectures\u00a0:"
    },
    {
        "title": "Basic Serialization Programming Guide",
        "created_at": "2025-01-21T04:54:33Z",
        "url": "basic-serialization-programming-guide",
        "editing_roles": "teachers",
        "page_id": 4602785,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/basic-serialization-programming-guide",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:33Z",
        "locked_for_user": false,
        "body": "Basic serialization\nThe easiest way to make a class serializable is to mark it with the\u00a0SerializableAttribute\u00a0as follows.\n\nC#\n\u00a0\n\n[Serializable]  \npublic class MyObject {  \n  public int n1 = 0;  \n  public int n2 = 0;  \n  public String str = null;  \n}  \n\nThe following code example shows how an instance of this class can be serialized to a file.\nC#\nMyObject obj = new MyObject();  \nobj.n1 = 1;  \nobj.n2 = 24;  \nobj.str = \"Some String\";  \nIFormatter formatter = new BinaryFormatter();  \nStream stream = new FileStream(\"MyFile.bin\", FileMode.Create, FileAccess.Write, FileShare.None);  \nformatter.Serialize(stream, obj);  \nstream.Close();  \n\nThis example uses a binary formatter to do the serialization. All you need to do is create an instance of the stream and the formatter you intend to use, and then call the\u00a0Serialize\u00a0method on the formatter. The stream and the object to serialize are provided as parameters to this call. Although it is not explicitly demonstrated in this example, all member variables of a class will be serialized\u2014even variables marked as private. In this aspect, binary serialization differs from the\u00a0XmlSerializer\u00a0class, which only serializes public fields. For information on excluding member variables from binary serialization, see\u00a0Selective Serialization.\nRestoring the object back to its former state is just as easy. First, create a stream for reading and a\u00a0Formatter, and then instruct the formatter to deserialize the object. The code example below shows how this is done.\nC#\nIFormatter formatter = new BinaryFormatter();  \nStream stream = new FileStream(\"MyFile.bin\", FileMode.Open, FileAccess.Read, FileShare.Read);  \nMyObject obj = (MyObject) formatter.Deserialize(stream);  \nstream.Close();  \n  \n// Here's the proof.  \nConsole.WriteLine(\"n1: {0}\", obj.n1);  \nConsole.WriteLine(\"n2: {0}\", obj.n2);  \nConsole.WriteLine(\"str: {0}\", obj.str);  \n\nThe\u00a0BinaryFormatter\u00a0used above is very efficient and produces a compact byte stream. All objects serialized with this formatter can also be deserialized with it, which makes it an ideal tool for serializing objects that will be deserialized on the .NET Framework. It is important to note that constructors are not called when an object is deserialized. This constraint is placed on deserialization for performance reasons. However, this violates some of the usual contracts the runtime makes with the object writer, and developers should ensure that they understand the ramifications when marking an object as serializable."
    },
    {
        "title": "8.3 UWP File Picker",
        "created_at": "2025-01-21T04:54:32Z",
        "url": "8-dot-3-uwp-file-picker",
        "editing_roles": "teachers",
        "page_id": 4602779,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/8-dot-3-uwp-file-picker",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:32Z",
        "locked_for_user": false,
        "body": "Sample Code:\u00a0\n\nIntroUWP.zip\nFilePicker.zip\n\n\u00a0Pick a single file: step-by-step:\u00a0\nUsing a file picker involves creating and customizing a file picker object, and then showing the file picker so the user can pick one or more items. Create and customize a FileOpenPicker\nC#\nvar picker = new Windows.Storage.Pickers.FileOpenPicker();\npicker.ViewMode = Windows.Storage.Pickers.PickerViewMode.Thumbnail;\npicker.SuggestedStartLocation = Windows.Storage.Pickers.PickerLocationId.PicturesLibrary;\npicker.FileTypeFilter.Add(\".jpg\");\npicker.FileTypeFilter.Add(\".jpeg\");\npicker.FileTypeFilter.Add(\".png\");\n\nSet properties on the file picker object relevant to your users and app.\nThis example creates a rich, visual display of pictures in a convenient location that the user can pick from by setting three properties:\u00a0ViewMode,\u00a0SuggestedStartLocation, and\u00a0FileTypeFilter. Setting\u00a0ViewMode\u00a0to the\u00a0PickerViewMode\u00a0Thumbnail\u00a0enum value creates a rich, visual display by using picture thumbnails to represent files in the file picker. Do this for picking visual files such as pictures or videos. Otherwise, use\u00a0PickerViewMode.List. A hypothetical email app with\u00a0Attach Picture or Video\u00a0and\u00a0Attach Document\u00a0features would set the\u00a0ViewMode\u00a0appropriate to the feature before showing the file picker. Setting\u00a0SuggestedStartLocation\u00a0to Pictures using\u00a0PickerLocationId.PicturesLibrary\u00a0starts the user in a location where they're likely to find pictures. Set\u00a0SuggestedStartLocation\u00a0to a location appropriate for the type of file being picked, for example Music, Pictures, Videos, or Documents. From the start location, the user can navigate to other locations. Using\u00a0FileTypeFilter\u00a0to specify file types keeps the user focused on picking files that are relevant. To replace previous file types in the\u00a0FileTypeFilter\u00a0with new entries, use\u00a0ReplaceAll\u00a0instead of\u00a0Add. Show the FileOpenPicker To pick a single file\nC#\nWindows.Storage.StorageFile file = await picker.PickSingleFileAsync();\nif (file != null)\n{\n    // Application now has read/write access to the picked file\n    this.textBlock.Text = \"Picked photo: \" + file.Name;\n}\nelse\n{\n    this.textBlock.Text = \"Operation cancelled.\";\n} To pick multiple files\nC#\nvar files = await picker.PickMultipleFilesAsync();\nif (files.Count > 0)\n{\n    StringBuilder output = new StringBuilder(\"Picked files:\\n\");\n\n    // Application now has read/write access to the picked file(s)\n    foreach (Windows.Storage.StorageFile file in files)\n    {\n        output.Append(file.Name + \"\\n\");\n    }\n    this.textBlock.Text = output.ToString();\n}\nelse\n{\n    this.textBlock.Text = \"Operation cancelled.\";\n}"
    },
    {
        "title": "8.4 UWP Create, Write, and Read a file",
        "created_at": "2025-01-21T04:54:32Z",
        "url": "8-dot-4-uwp-create-write-and-read-a-file",
        "editing_roles": "teachers",
        "page_id": 4602780,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/8-dot-4-uwp-create-write-and-read-a-file",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:32Z",
        "locked_for_user": false,
        "body": "Recommended Online Resources:\n\nUWP: Work with files\n\nCreating a file\nHere's how to create a file in the app's local folder. If it already exists, we replace it.\nC#\n// Create sample file; replace if exists.\nWindows.Storage.StorageFolder storageFolder =\n    Windows.Storage.ApplicationData.Current.LocalFolder;\nWindows.Storage.StorageFile sampleFile =\n    await storageFolder.CreateFileAsync(\"sample.txt\",\n        Windows.Storage.CreationCollisionOption.ReplaceExisting);\n\nWriting to a file\nHere's how to write to a writable file on disk using the\u00a0StorageFile\u00a0class. The common first step for each of the ways of writing to a file (unless you're writing to the file immediately after creating it) is to get the file with\u00a0StorageFolder.GetFileAsync.\nC#\nWindows.Storage.StorageFolder storageFolder =\n    Windows.Storage.ApplicationData.Current.LocalFolder;\nWindows.Storage.StorageFile sampleFile =\n    await storageFolder.GetFileAsync(\"sample.txt\");\n\nWriting text to a file\nWrite text to your file by calling the\u00a0FileIO.WriteTextAsync\u00a0method.\nC#\nawait Windows.Storage.FileIO.WriteTextAsync(sampleFile, \"Swift as a shadow\");\n\nWriting bytes to a file by using a buffer (2 steps) First, call\u00a0CryptographicBuffer.ConvertStringToBinary\u00a0to get a buffer of the bytes (based on a string) that you want to write to your file.\nC#\nvar buffer = Windows.Security.Cryptography.CryptographicBuffer.ConvertStringToBinary(\n    \"What fools these mortals be\", Windows.Security.Cryptography.BinaryStringEncoding.Utf8); Then write the bytes from your buffer to your file by calling the\u00a0FileIO.WriteBufferAsync\u00a0method.\nC#\nawait Windows.Storage.FileIO.WriteBufferAsync(sampleFile, buffer); Writing text to a file by using a stream (4 steps) First, open the file by calling the\u00a0StorageFile.OpenAsync\u00a0method. It returns a stream of the file's content when the open operation completes.\nC#\nvar stream = await sampleFile.OpenAsync(Windows.Storage.FileAccessMode.ReadWrite); Next, get an output stream by calling the\u00a0IRandomAccessStream.GetOutputStreamAt\u00a0method from the\u00a0stream. If you're using C#, then enclose this in a\u00a0using\u00a0statement to manage the output stream's lifetime. If you're using\u00a0C++/WinRT, then you can control its lifetime by enclosing it in a block, or setting it to\u00a0nullptr\u00a0when you're done with it.\nC#\nusing (var outputStream = stream.GetOutputStreamAt(0))\n{\n    // We'll add more code here in the next step.\n}\nstream.Dispose(); // Or use the stream variable (see previous code snippet) with a using statement as well. Now add this code (if you're using C#, within the existing\u00a0using\u00a0statement) to write to the output stream by creating a new\u00a0DataWriter\u00a0object and calling the\u00a0DataWriter.WriteString\u00a0method.\nC#\nusing (var dataWriter = new Windows.Storage.Streams.DataWriter(outputStream))\n{\n    dataWriter.WriteString(\"DataWriter has methods to write to various types, such as DataTimeOffset.\");\n} Lastly, add this code (if you're using C#, within the inner\u00a0using\u00a0statement) to save the text to your file with\u00a0DataWriter.StoreAsync\u00a0and close the stream with\u00a0IOutputStream.FlushAsync.\nC#\nawait dataWriter.StoreAsync();\nawait outputStream.FlushAsync(); Best practices for writing to a file\nFor additional details and best practice guidance, see\u00a0Best practices for writing to files.\nReading from a file\nHere's how to read from a file on disk using the\u00a0StorageFile\u00a0class. The common first step for each of the ways of reading from a file is to get the file with\u00a0StorageFolder.GetFileAsync.\nC#\nWindows.Storage.StorageFolder storageFolder =\n    Windows.Storage.ApplicationData.Current.LocalFolder;\nWindows.Storage.StorageFile sampleFile =\n    await storageFolder.GetFileAsync(\"sample.txt\");\n\nReading text from a file\nRead text from your file by calling the\u00a0FileIO.ReadTextAsync\u00a0method.\nC#\nstring text = await Windows.Storage.FileIO.ReadTextAsync(sampleFile);\n\nReading text from a file by using a buffer (2 steps) First, call the\u00a0FileIO.ReadBufferAsync\u00a0method.\nC#\nvar buffer = await Windows.Storage.FileIO.ReadBufferAsync(sampleFile); Then use a\u00a0DataReader\u00a0object to read first the length of the buffer and then its contents.\nC#\nusing (var dataReader = Windows.Storage.Streams.DataReader.FromBuffer(buffer))\n{\n    string text = dataReader.ReadString(buffer.Length);\n} Reading text from a file by using a stream (4 steps) Open a stream for your file by calling the\u00a0StorageFile.OpenAsync\u00a0method. It returns a stream of the file's content when the operation completes.\nC#\nvar stream = await sampleFile.OpenAsync(Windows.Storage.FileAccessMode.Read); Get the size of the stream to use later.\nC#\nulong size = stream.Size; Get an input stream by calling the\u00a0IRandomAccessStream.GetInputStreamAt\u00a0method. Put this in a\u00a0using\u00a0statement to manage the stream's lifetime. Specify 0 when you call\u00a0GetInputStreamAt\u00a0to set the position to the beginning of the stream.\nC#\nusing (var inputStream = stream.GetInputStreamAt(0))\n{\n    // We'll add more code here in the next step.\n} Lastly, add this code within the existing\u00a0using\u00a0statement to get a\u00a0DataReader\u00a0object on the stream then read the text by calling\u00a0DataReader.LoadAsync\u00a0and\u00a0DataReader.ReadString.\nC#\nusing (var dataReader = new Windows.Storage.Streams.DataReader(inputStream))\n{\n    uint numBytesLoaded = await dataReader.LoadAsync((uint)size);\n    string text = dataReader.ReadString(numBytesLoaded);\n}"
    },
    {
        "title": "M7 Roadmap & Objectives ",
        "created_at": "2025-01-21T04:54:42Z",
        "url": "m7-roadmap-and-objectives",
        "editing_roles": "teachers",
        "page_id": 4602848,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/m7-roadmap-and-objectives",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:42Z",
        "locked_for_user": false,
        "body": "M7\u00a0Objectives\n\nAfter completing this week's work, you will be able to:\n\nDeclare a delegate type to create an abstraction of a method signature. \nCreate an instance of a delegate to refer to a specific method. \nCall a method through a delegate. \nDefine a lambda expression to specify the code to be executed by a delegate. \nDeclare an event field. Handle an event by using a delegate. \nRaise an event.\n\n\u00a0\n\n\u00a0M7 Activities\u00a0 Watch Video Lectures\nRead Lecture Slides & Programming Guide,\nPractice with Sample Code\nComplete M7\u00a0 Quiz and Assignment"
    },
    {
        "title": "7.1 Delegates",
        "created_at": "2025-01-21T04:54:32Z",
        "url": "7-dot-1-delegates",
        "editing_roles": "teachers",
        "page_id": 4602774,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/7-dot-1-delegates",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:32Z",
        "locked_for_user": false,
        "body": "Lecture Slides: Delegates.pdf\n\u00a0Sample Code: Delegate_Lamda.zip\n\u00a0Video Lectures:\u00a0\nIntroduction to Delegates\n\nLamda Expressions"
    },
    {
        "title": "Delegates Programming Guide",
        "created_at": "2025-01-21T04:54:35Z",
        "url": "delegates-programming-guide",
        "editing_roles": "teachers",
        "page_id": 4602794,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/delegates-programming-guide",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:35Z",
        "locked_for_user": false,
        "body": "Delegates\u00a0\nA\u00a0delegate\u00a0is a type that safely encapsulates a method, similar to a function pointer in C and C++. Unlike C function pointers, delegates are object-oriented, type safe, and secure. The type of a delegate is defined by the name of the delegate. The following example declares a delegate named\u00a0Del\u00a0that can encapsulate a method that takes a\u00a0string\u00a0as an argument and returns\u00a0void:\nC#\npublic delegate void Del(string message);\n\nA delegate object is normally constructed by providing the name of the method the delegate will wrap, or with an\u00a0anonymous function. Once a delegate is instantiated, a method call made to the delegate will be passed by the delegate to that method. The parameters passed to the delegate by the caller are passed to the method, and the return value, if any, from the method is returned to the caller by the delegate. This is known as invoking the delegate. An instantiated delegate can be invoked as if it were the wrapped method itself. For example:\nC#\n// Create a method for a delegate.\npublic static void DelegateMethod(string message)\n{\n    Console.WriteLine(message);\n}\n\nC#\n// Instantiate the delegate.\nDel handler = DelegateMethod;\n\n// Call the delegate.\nhandler(\"Hello World\");\n\nDelegate types are derived from the\u00a0Delegate\u00a0class in the .NET Framework. Delegate types are\u00a0sealed\u2014they cannot be derived from\u2014 and it is not possible to derive custom classes from\u00a0Delegate. Because the instantiated delegate is an object, it can be passed as a parameter, or assigned to a property. This allows a method to accept a delegate as a parameter, and call the delegate at some later time. This is known as an asynchronous callback, and is a common method of notifying a caller when a long process has completed. When a delegate is used in this fashion, the code using the delegate does not need any knowledge of the implementation of the method being used. The functionality is similar to the encapsulation interfaces provide.\nAnother common use of callbacks is defining a custom comparison method and passing that delegate to a sort method. It allows the caller's code to become part of the sort algorithm. The following example method uses the\u00a0Del\u00a0type as a parameter:\nC#\npublic static void MethodWithCallback(int param1, int param2, Del callback)\n{\n    callback(\"The number is: \" + (param1 + param2).ToString());\n}\n\nYou can then pass the delegate created above to that method:\nC#\nMethodWithCallback(1, 2, handler);\n\nand receive the following output to the console:\nconsole\nThe number is: 3\n\nUsing the delegate as an abstraction,\u00a0MethodWithCallback\u00a0does not need to call the console directly\u2014it does not have to be designed with a console in mind. What\u00a0MethodWithCallback\u00a0does is simply prepare a string and pass the string to another method. This is especially powerful since a delegated method can use any number of parameters.\nWhen a delegate is constructed to wrap an instance method, the delegate references both the instance and the method. A delegate has no knowledge of the instance type aside from the method it wraps, so a delegate can refer to any type of object as long as there is a method on that object that matches the delegate signature. When a delegate is constructed to wrap a static method, it only references the method. Consider the following declarations:\nC#\npublic class MethodClass\n{\n    public void Method1(string message) { }\n    public void Method2(string message) { }\n}\n\nAlong with the static\u00a0DelegateMethod\u00a0shown previously, we now have three methods that can be wrapped by a\u00a0Del\u00a0instance.\nA delegate can call more than one method when invoked. This is referred to as multicasting. To add an extra method to the delegate's list of methods\u2014the invocation list\u2014simply requires adding two delegates using the addition or addition assignment operators ('+' or '+='). For example:\nC#\nvar obj = new MethodClass();\nDel d1 = obj.Method1;\nDel d2 = obj.Method2;\nDel d3 = DelegateMethod;\n\n//Both types of assignment are valid.\nDel allMethodsDelegate = d1 + d2;\nallMethodsDelegate += d3;\n\nAt this point\u00a0allMethodsDelegate\u00a0contains three methods in its invocation list\u2014Method1,\u00a0Method2, and\u00a0DelegateMethod. The original three delegates,\u00a0d1,\u00a0d2, and\u00a0d3, remain unchanged. When\u00a0allMethodsDelegate\u00a0is invoked, all three methods are called in order. If the delegate uses reference parameters, the reference is passed sequentially to each of the three methods in turn, and any changes by one method are visible to the next method. When any of the methods throws an exception that is not caught within the method, that exception is passed to the caller of the delegate and no subsequent methods in the invocation list are called. If the delegate has a return value and/or out parameters, it returns the return value and parameters of the last method invoked. To remove a method from the invocation list, use the\u00a0subtraction or subtraction assignment operators\u00a0(-\u00a0or\u00a0-=). For example:\nC#\n//remove Method1\nallMethodsDelegate -= d1;\n\n// copy AllMethodsDelegate while removing d2\nDel oneMethodDelegate = allMethodsDelegate - d2;\n\nBecause delegate types are derived from\u00a0System.Delegate, the methods and properties defined by that class can be called on the delegate. For example, to find the number of methods in a delegate's invocation list, you may write:\nC#\nint invocationCount = d1.GetInvocationList().GetLength(0);\n\nDelegates with more than one method in their invocation list derive from\u00a0MulticastDelegate, which is a subclass of\u00a0System.Delegate. The above code works in either case because both classes support\u00a0GetInvocationList.\nMulticast delegates are used extensively in event handling. Event source objects send event notifications to recipient objects that have registered to receive that event. To register for an event, the recipient creates a method designed to handle the event, then creates a delegate for that method and passes the delegate to the event source. The source calls the delegate when the event occurs. The delegate then calls the event handling method on the recipient, delivering the event data. The delegate type for a given event is defined by the event source. For more, see\u00a0Events.\nComparing delegates of two different types assigned at compile-time will result in a compilation error. If the delegate instances are statically of the type\u00a0System.Delegate, then the comparison is allowed, but will return false at run time. For example:\nC#\ndelegate void Delegate1();\ndelegate void Delegate2();\n\nstatic void method(Delegate1 d, Delegate2 e, System.Delegate f)\n{\n    // Compile-time error.\n    //Console.WriteLine(d == e);\n\n    // OK at compile-time. False if the run-time type of f \n    // is not the same as that of d.\n    Console.WriteLine(d == f);\n}"
    },
    {
        "title": "7.2 Events",
        "created_at": "2025-01-21T04:54:32Z",
        "url": "7-dot-2-events",
        "editing_roles": "teachers",
        "page_id": 4602775,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/7-dot-2-events",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:32Z",
        "locked_for_user": false,
        "body": "Lecture Slides: Events.pdf\n\u00a0Sample Code: \n\nStockEvent.zip\nStockEvent_standard.zip\n\n\u00a0Video Lectures:\u00a0\nIntroduction to Events\n\nStandard Events"
    },
    {
        "title": "Events Programming Guide",
        "created_at": "2025-01-21T04:54:36Z",
        "url": "events-programming-guide",
        "editing_roles": "teachers",
        "page_id": 4602798,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/events-programming-guide",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:36Z",
        "locked_for_user": false,
        "body": "Events\u00a0\nEvents enable a\u00a0class\u00a0or object to notify other classes or objects when something of interest occurs. The class that sends (or\u00a0raises) the event is called the\u00a0publisher\u00a0and the classes that receive (or\u00a0handle) the event are called\u00a0subscribers.\nIn a typical C# Windows Forms or Web application, you subscribe to events raised by controls such as buttons and list boxes. You can use the Visual C# integrated development environment (IDE) to browse the events that a control publishes and select the ones that you want to handle. The IDE provides an easy way to automatically add an empty event handler method and the code to subscribe to the event.\nEvents Overview\nEvents have the following properties: The publisher determines when an event is raised; the subscribers determine what action is taken in response to the event. An event can have multiple subscribers. A subscriber can handle multiple events from multiple publishers. Events that have no subscribers are never raised. Events are typically used to signal user actions such as button clicks or menu selections in graphical user interfaces. When an event has multiple subscribers, the event handlers are invoked synchronously when an event is raised. To invoke events asynchronously, see\u00a0Calling Synchronous Methods Asynchronously. In the .NET Framework class library, events are based on the\u00a0EventHandler\u00a0delegate and the\u00a0EventArgs\u00a0base class."
    },
    {
        "title": "Subscribing and unsubscribing",
        "created_at": "2025-01-21T04:54:45Z",
        "url": "subscribing-and-unsubscribing",
        "editing_roles": "teachers",
        "page_id": 4602869,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/subscribing-and-unsubscribing",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:45Z",
        "locked_for_user": false,
        "body": "How to subscribe to and unsubscribe from events\u00a0\nYou subscribe to an event that is published by another class when you want to write custom code that is called when that event is raised. For example, you might subscribe to a button's\u00a0click\u00a0event in order to make your application do something useful when the user clicks the button.\nTo subscribe to events by using the Visual Studio IDE If you cannot see the\u00a0Properties\u00a0window, in\u00a0Design\u00a0view, right-click the form or control for which you want to create an event handler, and select\u00a0Properties. On top of the\u00a0Properties\u00a0window, click the\u00a0Events\u00a0icon. Double-click the event that you want to create, for example the\u00a0Load\u00a0event.\nVisual C# creates an empty event handler method and adds it to your code. Alternatively you can add the code manually in\u00a0Code\u00a0view. For example, the following lines of code declare an event handler method that will be called when the\u00a0Form\u00a0class raises the\u00a0Load\u00a0event.\nC#\nprivate void Form1_Load(object sender, System.EventArgs e)\n{\n    // Add your form load event handling code here.\n}\n\nThe line of code that is required to subscribe to the event is also automatically generated in the\u00a0InitializeComponent\u00a0method in the Form1.Designer.cs file in your project. It resembles this:\nC#\nthis.Load += new System.EventHandler(this.Form1_Load);   To subscribe to events programmatically Define an event handler method whose signature matches the delegate signature for the event. For example, if the event is based on the\u00a0EventHandler\u00a0delegate type, the following code represents the method stub:\nC#\nvoid HandleCustomEvent(object sender, CustomEventArgs a)  \n{  \n   // Do something useful here.  \n}   Use the addition assignment operator (+=) to attach an event handler to the event. In the following example, assume that an object named\u00a0publisher\u00a0has an event named\u00a0RaiseCustomEvent. Note that the subscriber class needs a reference to the publisher class in order to subscribe to its events.\nC#\npublisher.RaiseCustomEvent += HandleCustomEvent;  \n\nNote that the previous syntax is new in C# 2.0. It is exactly equivalent to the C# 1.0 syntax in which the encapsulating delegate must be explicitly created by using the\u00a0new\u00a0keyword:\nC#\npublisher.RaiseCustomEvent += new CustomEventHandler(HandleCustomEvent);  \n\nYou also can use a\u00a0lambda expression\u00a0to specify an event handler:\nC#\npublic Form1()  \n{  \n    InitializeComponent();  \n    this.Click += (s,e) =>\n        {\n            MessageBox.Show(((MouseEventArgs)e).Location.ToString());\n        };\n}   To subscribe to events by using an anonymous method If you will not have to unsubscribe to an event later, you can use the addition assignment operator (+=) to attach an anonymous method to the event. In the following example, assume that an object named\u00a0publisher\u00a0has an event named\u00a0RaiseCustomEvent\u00a0and that a\u00a0CustomEventArgs\u00a0class has also been defined to carry some kind of specialized event information. Note that the subscriber class needs a reference to\u00a0publisher\u00a0in order to subscribe to its events.\nC#\npublisher.RaiseCustomEvent += delegate(object o, CustomEventArgs e)  \n{  \n  string s = o.ToString() + \" \" + e.ToString();  \n  Console.WriteLine(s);  \n};  \n\nIt is important to notice that you cannot easily unsubscribe from an event if you used an anonymous function to subscribe to it. To unsubscribe in this scenario, it is necessary to go back to the code where you subscribe to the event, store the anonymous method in a delegate variable, and then add the delegate to the event. In general, we recommend that you do not use anonymous functions to subscribe to events if you will have to unsubscribe from the event at some later point in your code. For more information about anonymous functions, see\u00a0Anonymous Functions. Unsubscribing\nTo prevent your event handler from being invoked when the event is raised, unsubscribe from the event. In order to prevent resource leaks, you should unsubscribe from events before you dispose of a subscriber object. Until you unsubscribe from an event, the multicast delegate that underlies the event in the publishing object has a reference to the delegate that encapsulates the subscriber's event handler. As long as the publishing object holds that reference, garbage collection will not delete your subscriber object.\nTo unsubscribe from an event Use the subtraction assignment operator (-=) to unsubscribe from an event:\nC#\npublisher.RaiseCustomEvent -= HandleCustomEvent;  \n\nWhen all subscribers have unsubscribed from an event, the event instance in the publisher class is set to\u00a0null."
    },
    {
        "title": "M6 Roadmap & Objectives",
        "created_at": "2025-01-21T04:54:42Z",
        "url": "m6-roadmap-and-objectives",
        "editing_roles": "teachers",
        "page_id": 4602845,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/m6-roadmap-and-objectives",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:42Z",
        "locked_for_user": false,
        "body": "M6\u00a0Objectives\nAfter completing this week's work, you will be able to:\n\nReview Exception Handling in Module 4.\nUnderstand\u00a0what exceptions are and how they\u2019re handled.\nHandle exceptions by using the try, catch, and finally statements\nUnderstand\u00a0the .NET exception class hierarchy.\nDesign and develop an interactive user interface with WPF with code behind\n\n\u00a0\n\u00a0M6 Activities\u00a0\n\nWatch Video Lectures\nRead Lecture Slides & Programming Guide,\nPractice with Sample Code\nComplete M6\u00a0 Quiz and Assignment"
    },
    {
        "title": "6.1 Create and Use Class Library",
        "created_at": "2025-01-21T04:54:31Z",
        "url": "6-dot-1-create-and-use-class-library",
        "editing_roles": "teachers",
        "page_id": 4602770,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/6-dot-1-create-and-use-class-library",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:31Z",
        "locked_for_user": false,
        "body": "Lecture Slides: Class Library (use your University credential to access)\nSample Code: ClassLibraryProject\nTutorial :\u00a0Create a .NET class library using Visual Studio"
    },
    {
        "title": "6.2 How to Document Your Classes ",
        "created_at": "2025-01-21T04:54:31Z",
        "url": "6-dot-2-how-to-document-your-classes",
        "editing_roles": "teachers",
        "page_id": 4602771,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/6-dot-2-how-to-document-your-classes",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:31Z",
        "locked_for_user": false,
        "body": "Lecture Slides: How to Document your Classes (use your University credential to access doc on Google Drive through MU)\nRef: Recommended XML tags for C# documentation comments"
    },
    {
        "title": "6.3 Case Study: MathsOperators",
        "created_at": "2025-01-21T04:54:32Z",
        "url": "6-dot-3-case-study-mathsoperators",
        "editing_roles": "teachers",
        "page_id": 4602772,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/6-dot-3-case-study-mathsoperators",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:32Z",
        "locked_for_user": false,
        "body": "Sample Code:\u00a0 MathsOperators.zip\n\u00a0Video Lectures:"
    },
    {
        "title": "6.4 Data & Time Picker Review",
        "created_at": "2025-01-21T04:54:32Z",
        "url": "6-dot-4-data-and-time-picker-review",
        "editing_roles": "teachers",
        "page_id": 4602773,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/6-dot-4-data-and-time-picker-review",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:32Z",
        "locked_for_user": false,
        "body": "Video Lectures:\u00a0\nA review of M5 Challenge:\u00a0 Data & Time Picker"
    },
    {
        "title": "M5 Roadmap & Objectives",
        "created_at": "2025-01-21T04:54:42Z",
        "url": "m5-roadmap-and-objectives",
        "editing_roles": "teachers",
        "page_id": 4602843,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/m5-roadmap-and-objectives",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:42Z",
        "locked_for_user": false,
        "body": "M5\u00a0Objectives\n\nAfter completing this week's work, you will be able to:\n\nIllustrate different WPF layout controls (size, position, transform, margin, padding)\nDescribe commonly used WPF user interface elements\nExplain the relationship between UI and code behind\nDesign and develop an interactive user interface with WPF with code behind\n\n\u00a0\n\n\u00a0M5 Activities\u00a0 Watch Video Lectures\nRead Lecture Slides & Programming Guide,\nPractice with Sample Code\nComplete M5 Quiz and Assignment"
    },
    {
        "title": "5.1 Introduction to WPF",
        "created_at": "2025-01-21T04:54:31Z",
        "url": "5-dot-1-introduction-to-wpf",
        "editing_roles": "teachers",
        "page_id": 4602766,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/5-dot-1-introduction-to-wpf",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:31Z",
        "locked_for_user": false,
        "body": "Lecture Slides: IntroWPF.pdf"
    },
    {
        "title": "WPF Programming Guide",
        "created_at": "2025-01-21T04:54:47Z",
        "url": "wpf-programming-guide",
        "editing_roles": "teachers",
        "page_id": 4602886,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/wpf-programming-guide",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:47Z",
        "locked_for_user": false,
        "body": "WPF overview\nWindows Presentation Foundation (WPF) lets you create desktop client applications for Windows with visually stunning user experiences.\nThe core of WPF is a resolution-independent and vector-based rendering engine that is built to take advantage of modern graphics hardware. WPF extends the core with a comprehensive set of application-development features that include Extensible Application Markup Language (XAML), controls, data binding, layout, 2D and 3D graphics, animation, styles, templates, documents, media, text, and typography. WPF is part of .NET, so you can build applications that incorporate other elements of the .NET API.\nThis overview is intended for newcomers and covers the key capabilities and concepts of WPF.\nProgram with WPF\nWPF exists as a subset of .NET types that are (for the most part) located in the\u00a0System.Windows\u00a0namespace. If you have previously built applications with .NET using managed technologies like ASP.NET and Windows Forms, the fundamental WPF programming experience should be familiar; you instantiate classes, set properties, call methods, and handle events, using your favorite .NET programming language, such as C# or Visual Basic.\nWPF includes additional programming constructs that enhance properties and events:\u00a0dependency properties\u00a0and\u00a0routed events.\nMarkup and code-behind\nWPF lets you develop an application using both\u00a0markup\u00a0and\u00a0code-behind, an experience with which ASP.NET developers should be familiar. You generally use XAML markup to implement the appearance of an application while using managed programming languages (code-behind) to implement its behavior. This separation of appearance and behavior has the following benefits: Development and maintenance costs are reduced because appearance-specific markup is not tightly coupled with behavior-specific code. Development is more efficient because designers can implement an application's appearance simultaneously with developers who are implementing the application's behavior. Globalization and localization\u00a0for WPF applications is simplified. Markup\nXAML is an XML-based markup language that implements an application's appearance declaratively. You typically use it to create windows, dialog boxes, pages, and user controls, and to fill them with controls, shapes, and graphics.\nThe following example uses XAML to implement the appearance of a window that contains a single button:\nXAML\n<Window\n    xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n    Title=\"Window with Button\"\n    Width=\"250\" Height=\"100\">\n\n  <!-- Add button to window -->\n  <Button Name=\"button\">Click Me!</Button>\n\n</Window>\n\nSpecifically, this XAML defines a window and a button by using the\u00a0Window\u00a0and\u00a0Button\u00a0elements, respectively. Each element is configured with attributes, such as the\u00a0Window\u00a0element's\u00a0Title\u00a0attribute to specify the window's title-bar text. At run time, WPF converts the elements and attributes that are defined in markup to instances of WPF classes. For example, the\u00a0Window\u00a0element is converted to an instance of the\u00a0Window\u00a0class whose\u00a0Title\u00a0property is the value of the\u00a0Title\u00a0attribute.\nThe following figure shows the user interface (UI) that is defined by the XAML in the previous example:\n\nSince XAML is XML-based, the UI that you compose with it is assembled in a hierarchy of nested elements known as an\u00a0element tree. The element tree provides a logical and intuitive way to create and manage UIs.\nCode-behind\nThe main behavior of an application is to implement the functionality that responds to user interactions, including handling events (for example, clicking a menu, tool bar, or button) and calling business logic and data access logic in response. In WPF, this behavior is implemented in code that is associated with markup. This type of code is known as code-behind. The following example shows the updated markup from the previous example and the code-behind:\nXAML\n<Window\n    xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n    xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n    x:Class=\"SDKSample.AWindow\"\n    Title=\"Window with Button\"\n    Width=\"250\" Height=\"100\">\n\n  <!-- Add button to window -->\n  <Button Name=\"button\" Click=\"button_Click\">Click Me!</Button>\n\n</Window>\n\nC#\nusing System.Windows; // Window, RoutedEventArgs, MessageBox\u00a0\n\nnamespace SDKSample\n{\n    public\u00a0partial\u00a0class AWindow : Window\n    {\n        public AWindow()\n        {\n            // InitializeComponent call is required to merge the UI\u00a0\n            // that is defined in markup with this class, including \u00a0\n            // setting properties and registering event handlers\n            InitializeComponent();\n        }\n\n        void button_Click(object sender, RoutedEventArgs e)\n        {\n            // Show message box when button is clicked.\n            MessageBox.Show(\"Hello, Windows Presentation Foundation!\");\n        }\n    }\n}\n\nIn this example, the code-behind implements a class that derives from the\u00a0Window\u00a0class. The\u00a0x:Class\u00a0attribute is used to associate the markup with the code-behind class.\u00a0InitializeComponent\u00a0is called from the code-behind class's constructor to merge the UI that is defined in markup with the code-behind class. (InitializeComponent\u00a0is generated for you when your application is built, which is why you don't need to implement it manually.) The combination of\u00a0x:Class\u00a0and\u00a0InitializeComponent\u00a0ensure that your implementation is correctly initialized whenever it is created. The code-behind class also implements an event handler for the button's\u00a0Click\u00a0event. When the button is clicked, the event handler shows a message box by calling the\u00a0System.Windows.MessageBox.Show\u00a0method.\nThe following figure shows the result when the button is clicked:"
    },
    {
        "title": "5.2 UI Elements Layout",
        "created_at": "2025-01-21T04:54:31Z",
        "url": "5-dot-2-ui-elements-layout",
        "editing_roles": "teachers",
        "page_id": 4602767,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/5-dot-2-ui-elements-layout",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:31Z",
        "locked_for_user": false,
        "body": "Lecture Slides: LayoutChildren.pdf\n\u00a0Video Lectures:\u00a0\n\nWPF Layout Margin & Padding \u00a0\n\u00a0 \u00a0 2. WPF Layout Alignment & Transform"
    },
    {
        "title": "Alignment, Margins, and Padding",
        "created_at": "2025-01-21T04:54:33Z",
        "url": "alignment-margins-and-padding",
        "editing_roles": "teachers",
        "page_id": 4602782,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/alignment-margins-and-padding",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:33Z",
        "locked_for_user": false,
        "body": "Alignment, Margins, and Padding Overview\nThe\u00a0FrameworkElement\u00a0class exposes several properties that are used to precisely position child elements. This topic discusses four of the most important properties:\u00a0HorizontalAlignment,\u00a0Margin,\u00a0Padding, and\u00a0VerticalAlignment. The effects of these properties are important to understand, because they provide the basis for controlling the position of elements in Windows Presentation Foundation (WPF) applications.\nIntroduction to Element Positioning\nThere are numerous ways to position elements using WPF. However, achieving ideal layout goes beyond simply choosing the right\u00a0Panel\u00a0element. Fine control of positioning requires an understanding of the\u00a0HorizontalAlignment,\u00a0Margin,\u00a0Padding, and\u00a0VerticalAlignment\u00a0properties.\nThe following illustration shows a layout scenario that utilizes several positioning properties.\n\nAt first glance, the\u00a0Button\u00a0elements in this illustration may appear to be placed randomly. However, their positions are actually precisely controlled by using a combination of margins, alignments, and padding.\nThe following example describes how to create the layout in the preceding illustration. A\u00a0Border\u00a0element encapsulates a parent\u00a0StackPanel, with a\u00a0Padding\u00a0value of 15 device independent pixels. This accounts for the narrow\u00a0LightBlue\u00a0band that surrounds the child\u00a0StackPanel. Child elements of the\u00a0StackPanel\u00a0are used to illustrate each of the various positioning properties that are detailed in this topic. Three\u00a0Button\u00a0elements are used to demonstrate both the\u00a0Margin\u00a0and\u00a0HorizontalAlignment\u00a0properties.\nC#\n\n// Create the application's main Window.\nmainWindow = new Window ();\nmainWindow.Title = \"Margins, Padding and Alignment Sample\";\n\n// Add a Border\nmyBorder = new Border();\nmyBorder.Background = Brushes.LightBlue;\nmyBorder.BorderBrush = Brushes.Black;\nmyBorder.Padding = new Thickness(15);\nmyBorder.BorderThickness = new Thickness(2);\n\nmyStackPanel = new StackPanel();\nmyStackPanel.Background = Brushes.White;\nmyStackPanel.HorizontalAlignment = HorizontalAlignment.Center;\nmyStackPanel.VerticalAlignment = VerticalAlignment.Top;\n\nTextBlock myTextBlock = new TextBlock();\nmyTextBlock.Margin = new Thickness(5, 0, 5, 0);\nmyTextBlock.FontSize = 18;\nmyTextBlock.HorizontalAlignment = HorizontalAlignment.Center;\nmyTextBlock.Text = \"Alignment, Margin and Padding Sample\";\nButton myButton1 = new Button();\nmyButton1.HorizontalAlignment = HorizontalAlignment.Left;\nmyButton1.Margin = new Thickness(20);\nmyButton1.Content = \"Button 1\";\nButton myButton2 = new Button();\nmyButton2.HorizontalAlignment = HorizontalAlignment.Right;\nmyButton2.Margin = new Thickness(10);\nmyButton2.Content = \"Button 2\";\nButton myButton3 = new Button();\nmyButton3.HorizontalAlignment = HorizontalAlignment.Stretch;\nmyButton3.Margin = new Thickness(0);\nmyButton3.Content = \"Button 3\";\n\n// Add child elements to the parent StackPanel.\nmyStackPanel.Children.Add(myTextBlock);\nmyStackPanel.Children.Add(myButton1);\nmyStackPanel.Children.Add(myButton2);\nmyStackPanel.Children.Add(myButton3);\n\n// Add the StackPanel as the lone Child of the Border.\nmyBorder.Child = myStackPanel;\n\n// Add the Border as the Content of the Parent Window Object.\nmainWindow.Content = myBorder;\nmainWindow.Show (); The following diagram provides a close-up view of the various positioning properties that are used in the preceding sample. Subsequent sections in this topic describe in greater detail how to use each positioning property.\n\n\u00a0\nUnderstanding Alignment Properties\nThe\u00a0HorizontalAlignment\u00a0and\u00a0VerticalAlignment\u00a0properties describe how a child element should be positioned within a parent element's allocated layout space. By using these properties together, you can position child elements precisely. For example, child elements of a\u00a0DockPanel\u00a0can specify four different horizontal alignments:\u00a0Left,\u00a0Right, or\u00a0Center, or to\u00a0Stretch\u00a0to fill available space. Similar values are available for vertical positioning.\n\n\u00a0Note\nExplicitly-set\u00a0Height\u00a0and\u00a0Width\u00a0properties on an element take precedence over the\u00a0Stretch\u00a0property value. Attempting to set\u00a0Height,\u00a0Width, and a\u00a0HorizontalAlignment\u00a0value of\u00a0Stretch\u00a0results in the\u00a0Stretch\u00a0request being ignored.\n\n\u00a0\nHorizontalAlignment Property\nThe\u00a0HorizontalAlignment\u00a0property declares the horizontal alignment characteristics to apply to child elements. The following table shows each of the possible values of the\u00a0HorizontalAlignment\u00a0property. Member\nDescription Left\nChild elements are aligned to the left of the parent element's allocated layout space. Center\nChild elements are aligned to the center of the parent element's allocated layout space. Right\nChild elements are aligned to the right of the parent element's allocated layout space. Stretch\u00a0(Default)\nChild elements are stretched to fill the parent element's allocated layout space. Explicit\u00a0Width\u00a0and\u00a0Height\u00a0values take precedence. The following example shows how to apply the\u00a0HorizontalAlignment\u00a0property to\u00a0Button\u00a0elements. Each attribute value is shown, to better illustrate the various rendering behaviors.\nC#\nButton myButton1 = new Button();\nmyButton1.HorizontalAlignment = HorizontalAlignment.Left;\nmyButton1.Content = \"Button 1 (Left)\";\nButton myButton2 = new Button();\nmyButton2.HorizontalAlignment = HorizontalAlignment.Right;\nmyButton2.Content = \"Button 2 (Right)\";\nButton myButton3 = new Button();\nmyButton3.HorizontalAlignment = HorizontalAlignment.Center;\nmyButton3.Content = \"Button 3 (Center)\";\nButton myButton4 = new Button();\nmyButton4.HorizontalAlignment = HorizontalAlignment.Stretch;\nmyButton4.Content = \"Button 4 (Stretch)\";\n\nThe preceding code yields a layout similar to the following image. The positioning effects of each\u00a0HorizontalAlignment\u00a0value are visible in the illustration.\n\nVerticalAlignment Property\nThe\u00a0VerticalAlignment\u00a0property describes the vertical alignment characteristics to apply to child elements. The following table shows each of the possible values for the\u00a0VerticalAlignment\u00a0property. Member\nDescription Top\nChild elements are aligned to the top of the parent element's allocated layout space. Center\nChild elements are aligned to the center of the parent element's allocated layout space. Bottom\nChild elements are aligned to the bottom of the parent element's allocated layout space. Stretch\u00a0(Default)\nChild elements are stretched to fill the parent element's allocated layout space. Explicit\u00a0Width\u00a0and\u00a0Height\u00a0values take precedence. The following example shows how to apply the\u00a0VerticalAlignment\u00a0property to\u00a0Button\u00a0elements. Each attribute value is shown, to better illustrate the various rendering behaviors. For purposes of this sample, a\u00a0Grid\u00a0element with visible gridlines is used as the parent, to better illustrate the layout behavior of each property value.\nC#\nTextBlock myTextBlock = new TextBlock();\nmyTextBlock.FontSize = 18;\nmyTextBlock.HorizontalAlignment = HorizontalAlignment.Center;\nmyTextBlock.Text = \"VerticalAlignment Sample\";\nGrid.SetRow(myTextBlock, 0);\nButton myButton1 = new Button();\nmyButton1.VerticalAlignment = VerticalAlignment.Top;\nmyButton1.Content = \"Button 1 (Top)\";\nGrid.SetRow(myButton1, 1);\nButton myButton2 = new Button();\nmyButton2.VerticalAlignment = VerticalAlignment.Bottom;\nmyButton2.Content = \"Button 2 (Bottom)\";\nGrid.SetRow(myButton2, 2);\nButton myButton3 = new Button();\nmyButton3.VerticalAlignment = VerticalAlignment.Center;\nmyButton3.Content = \"Button 3 (Center)\";\nGrid.SetRow(myButton3, 3);\nButton myButton4 = new Button();\nmyButton4.VerticalAlignment = VerticalAlignment.Stretch;\nmyButton4.Content = \"Button 4 (Stretch)\";\nGrid.SetRow(myButton4, 4); XAMLCopy\n<Page xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" \n      xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n      WindowTitle=\"VerticalAlignment Sample\">\n  <Border Background=\"LightBlue\" BorderBrush=\"Black\" BorderThickness=\"2\" Padding=\"15\">\n    <Grid Background=\"White\" ShowGridLines=\"True\">\n      <Grid.RowDefinitions>\n        <RowDefinition Height=\"25\"/>\n        <RowDefinition Height=\"50\"/>\n        <RowDefinition Height=\"50\"/>\n        <RowDefinition Height=\"50\"/>\n        <RowDefinition Height=\"50\"/>\n      </Grid.RowDefinitions>\n            <TextBlock Grid.Row=\"0\" Grid.Column=\"0\" FontSize=\"18\" HorizontalAlignment=\"Center\">VerticalAlignment Sample</TextBlock>\n            <Button Grid.Row=\"1\" Grid.Column=\"0\" VerticalAlignment=\"Top\">Button 1 (Top)</Button>\n            <Button Grid.Row=\"2\" Grid.Column=\"0\" VerticalAlignment=\"Bottom\">Button 2 (Bottom)</Button>    \n            <Button Grid.Row=\"3\" Grid.Column=\"0\" VerticalAlignment=\"Center\">Button 3 (Center)</Button>\n            <Button Grid.Row=\"4\" Grid.Column=\"0\" VerticalAlignment=\"Stretch\">Button 4 (Stretch)</Button>          \n    </Grid>\n  </Border>    \n</Page>\n\nThe preceding code yields a layout similar to the following image. The positioning effects of each\u00a0VerticalAlignment\u00a0value are visible in the illustration. Understanding Margin Properties\nThe\u00a0Margin\u00a0property describes the distance between an element and its child or peers.\u00a0Margin\u00a0values can be uniform, by using syntax like\u00a0Margin=\"20\". With this syntax, a uniform\u00a0Margin\u00a0of 20 device independent pixels would be applied to the element.\u00a0Margin\u00a0values can also take the form of four distinct values, each value describing a distinct margin to apply to the left, top, right, and bottom (in that order), like\u00a0Margin=\"0,10,5,25\". Proper use of the\u00a0Margin\u00a0property enables very fine control of an element's rendering position and the rendering position of its neighbor elements and children.\n\n\u00a0Note\nA non-zero margin applies space outside the element's\u00a0ActualWidth\u00a0and\u00a0ActualHeight.\n\nThe following example shows how to apply uniform margins around a group of\u00a0Button\u00a0elements. The\u00a0Button\u00a0elements are spaced evenly with a ten-pixel margin buffer in each direction.\nC#\nButton myButton7 = new Button();\nmyButton7.Margin = new Thickness(10);\nmyButton7.Content = \"Button 7\";\nButton myButton8 = new Button();\nmyButton8.Margin = new Thickness(10);\nmyButton8.Content = \"Button 8\";\nButton myButton9 = new Button();\nmyButton9.Margin = new Thickness(10);\nmyButton9.Content = \"Button 9\";\n\nXAML\n<Button Margin=\"10\">Button 7</Button>\n<Button Margin=\"10\">Button 8</Button>\n<Button Margin=\"10\">Button 9</Button>\n\nIn many instances, a uniform margin is not appropriate. In these cases, non-uniform spacing can be applied. The following example shows how to apply non-uniform margin spacing to child elements. Margins are described in this order: left, top, right, bottom.\nC#\nButton myButton1 = new Button();\nmyButton1.Margin = new Thickness(0, 10, 0, 10);\nmyButton1.Content = \"Button 1\";\nButton myButton2 = new Button();\nmyButton2.Margin = new Thickness(0, 10, 0, 10);\nmyButton2.Content = \"Button 2\";\nButton myButton3 = new Button();\nmyButton3.Margin = new Thickness(0, 10, 0, 10);\n\nXAML\n<Button Margin=\"0,10,0,10\">Button 1</Button>\n<Button Margin=\"0,10,0,10\">Button 2</Button>\n<Button Margin=\"0,10,0,10\">Button 3</Button>\n\nUnderstanding the Padding Property\nPadding is similar to\u00a0Margin\u00a0in most respects. The Padding property is exposed on only on a few classes, primarily as a convenience:\u00a0Block,\u00a0Border,\u00a0Control, and\u00a0TextBlock\u00a0are samples of classes that expose a Padding property. The\u00a0Padding\u00a0property enlarges the effective size of a child element by the specified\u00a0Thickness\u00a0value.\nThe following example shows how to apply\u00a0Padding\u00a0to a parent\u00a0Border\u00a0element.\nC#\nmyBorder = new Border();\nmyBorder.Background = Brushes.LightBlue;\nmyBorder.BorderBrush = Brushes.Black;\nmyBorder.BorderThickness = new Thickness(2);\nmyBorder.CornerRadius = new CornerRadius(45);\nmyBorder.Padding = new Thickness(25);\n\nXAML\n<Border Background=\"LightBlue\" \n        BorderBrush=\"Black\" \n        BorderThickness=\"2\" \n        CornerRadius=\"45\" \n        Padding=\"25\">\n\nUsing Alignment, Margins, and Padding in an Application\nHorizontalAlignment,\u00a0Margin,\u00a0Padding, and\u00a0VerticalAlignment\u00a0provide the positioning control necessary to create a complex user interface (UI). You can use the effects of each property to change child-element positioning, enabling flexibility in creating dynamic applications and user experiences.\nThe following example demonstrates each of the concepts that are detailed in this topic. Building on the infrastructure found in the first sample in this topic, this example adds a\u00a0Grid\u00a0element as a child of the\u00a0Border\u00a0in the first sample.\u00a0Padding\u00a0is applied to the parent\u00a0Border\u00a0element. The\u00a0Grid\u00a0is used to partition space between three child\u00a0StackPanel\u00a0elements.\u00a0Button\u00a0elements are again used to show the various effects of\u00a0Margin\u00a0and\u00a0HorizontalAlignment.\u00a0TextBlock\u00a0elements are added to each\u00a0ColumnDefinition\u00a0to better define the various properties applied to the\u00a0Button\u00a0elements in each column.\nC#\nmainWindow = new Window();\n\nmyBorder = new Border();\nmyBorder.Background = Brushes.LightBlue;\nmyBorder.BorderBrush = Brushes.Black;\nmyBorder.BorderThickness = new Thickness(2);\nmyBorder.CornerRadius = new CornerRadius(45);\nmyBorder.Padding = new Thickness(25);\n\n// Define the Grid.\nmyGrid = new Grid();\nmyGrid.Background = Brushes.White;\nmyGrid.ShowGridLines = true;\n\n// Define the Columns.\nColumnDefinition myColDef1 = new ColumnDefinition();\nmyColDef1.Width = new GridLength(1, GridUnitType.Auto);\nColumnDefinition myColDef2 = new ColumnDefinition();\nmyColDef2.Width = new GridLength(1, GridUnitType.Star);\nColumnDefinition myColDef3 = new ColumnDefinition();\nmyColDef3.Width = new GridLength(1, GridUnitType.Auto);\n\n// Add the ColumnDefinitions to the Grid.\nmyGrid.ColumnDefinitions.Add(myColDef1);\nmyGrid.ColumnDefinitions.Add(myColDef2);\nmyGrid.ColumnDefinitions.Add(myColDef3);\n\n// Add the first child StackPanel.\nStackPanel myStackPanel = new StackPanel();\nmyStackPanel.HorizontalAlignment = HorizontalAlignment.Left;\nmyStackPanel.VerticalAlignment = VerticalAlignment.Top;\nGrid.SetColumn(myStackPanel, 0);\nGrid.SetRow(myStackPanel, 0);\nTextBlock myTextBlock1 = new TextBlock();\nmyTextBlock1.FontSize = 18;\nmyTextBlock1.HorizontalAlignment = HorizontalAlignment.Center;\nmyTextBlock1.Margin = new Thickness(0, 0, 0, 15);\nmyTextBlock1.Text = \"StackPanel 1\";\nButton myButton1 = new Button();\nmyButton1.Margin = new Thickness(0, 10, 0, 10);\nmyButton1.Content = \"Button 1\";\nButton myButton2 = new Button();\nmyButton2.Margin = new Thickness(0, 10, 0, 10);\nmyButton2.Content = \"Button 2\";\nButton myButton3 = new Button();\nmyButton3.Margin = new Thickness(0, 10, 0, 10);\nTextBlock myTextBlock2 = new TextBlock();\nmyTextBlock2.Text = @\"ColumnDefinition.Width = \"\"Auto\"\"\";\nTextBlock myTextBlock3 = new TextBlock();\nmyTextBlock3.Text = @\"StackPanel.HorizontalAlignment = \"\"Left\"\"\";\nTextBlock myTextBlock4 = new TextBlock();\nmyTextBlock4.Text = @\"StackPanel.VerticalAlignment = \"\"Top\"\"\";\nTextBlock myTextBlock5 = new TextBlock();\nmyTextBlock5.Text = @\"StackPanel.Orientation = \"\"Vertical\"\"\";\nTextBlock myTextBlock6 = new TextBlock();\nmyTextBlock6.Text = @\"Button.Margin = \"\"1,10,0,10\"\"\";\nmyStackPanel.Children.Add(myTextBlock1);\nmyStackPanel.Children.Add(myButton1);\nmyStackPanel.Children.Add(myButton2);\nmyStackPanel.Children.Add(myButton3);\nmyStackPanel.Children.Add(myTextBlock2);\nmyStackPanel.Children.Add(myTextBlock3);\nmyStackPanel.Children.Add(myTextBlock4);\nmyStackPanel.Children.Add(myTextBlock5);\nmyStackPanel.Children.Add(myTextBlock6);\n\n// Add the second child StackPanel.\nStackPanel myStackPanel2 = new StackPanel();\nmyStackPanel2.HorizontalAlignment = HorizontalAlignment.Stretch;\nmyStackPanel2.VerticalAlignment = VerticalAlignment.Top;\nmyStackPanel2.Orientation = Orientation.Vertical;\nGrid.SetColumn(myStackPanel2, 1);\nGrid.SetRow(myStackPanel2, 0);\nTextBlock myTextBlock7 = new TextBlock();\nmyTextBlock7.FontSize = 18;\nmyTextBlock7.HorizontalAlignment = HorizontalAlignment.Center;\nmyTextBlock7.Margin = new Thickness(0, 0, 0, 15);\nmyTextBlock7.Text = \"StackPanel 2\";\nButton myButton4 = new Button();\nmyButton4.Margin = new Thickness(10, 0, 10, 0);\nmyButton4.Content = \"Button 4\";\nButton myButton5 = new Button();\nmyButton5.Margin = new Thickness(10, 0, 10, 0);\nmyButton5.Content = \"Button 5\";\nButton myButton6 = new Button();\nmyButton6.Margin = new Thickness(10, 0, 10, 0);\nmyButton6.Content = \"Button 6\";\nTextBlock myTextBlock8 = new TextBlock();\nmyTextBlock8.HorizontalAlignment = HorizontalAlignment.Center;\nmyTextBlock8.Text = @\"ColumnDefinition.Width = \"\"*\"\"\";\nTextBlock myTextBlock9 = new TextBlock();\nmyTextBlock9.HorizontalAlignment = HorizontalAlignment.Center;\nmyTextBlock9.Text = @\"StackPanel.HorizontalAlignment = \"\"Stretch\"\"\";\nTextBlock myTextBlock10 = new TextBlock();\nmyTextBlock10.HorizontalAlignment = HorizontalAlignment.Center;\nmyTextBlock10.Text = @\"StackPanel.VerticalAlignment = \"\"Top\"\"\";\nTextBlock myTextBlock11 = new TextBlock();\nmyTextBlock11.HorizontalAlignment = HorizontalAlignment.Center;\nmyTextBlock11.Text = @\"StackPanel.Orientation = \"\"Horizontal\"\"\";\nTextBlock myTextBlock12 = new TextBlock();\nmyTextBlock12.HorizontalAlignment = HorizontalAlignment.Center;\nmyTextBlock12.Text = @\"Button.Margin = \"\"10,0,10,0\"\"\";\nmyStackPanel2.Children.Add(myTextBlock7);\nmyStackPanel2.Children.Add(myButton4);\nmyStackPanel2.Children.Add(myButton5);\nmyStackPanel2.Children.Add(myButton6);\nmyStackPanel2.Children.Add(myTextBlock8);\nmyStackPanel2.Children.Add(myTextBlock9);\nmyStackPanel2.Children.Add(myTextBlock10);\nmyStackPanel2.Children.Add(myTextBlock11);\nmyStackPanel2.Children.Add(myTextBlock12);\n\n// Add the final child StackPanel.\nStackPanel myStackPanel3 = new StackPanel();\nmyStackPanel3.HorizontalAlignment = HorizontalAlignment.Left;\nmyStackPanel3.VerticalAlignment = VerticalAlignment.Top;\nGrid.SetColumn(myStackPanel3, 2);\nGrid.SetRow(myStackPanel3, 0);\nTextBlock myTextBlock13 = new TextBlock();\nmyTextBlock13.FontSize = 18;\nmyTextBlock13.HorizontalAlignment = HorizontalAlignment.Center;\nmyTextBlock13.Margin = new Thickness(0, 0, 0, 15);\nmyTextBlock13.Text = \"StackPanel 3\";\nButton myButton7 = new Button();\nmyButton7.Margin = new Thickness(10);\nmyButton7.Content = \"Button 7\";\nButton myButton8 = new Button();\nmyButton8.Margin = new Thickness(10);\nmyButton8.Content = \"Button 8\";\nButton myButton9 = new Button();\nmyButton9.Margin = new Thickness(10);\nmyButton9.Content = \"Button 9\";\nTextBlock myTextBlock14 = new TextBlock();\nmyTextBlock14.Text = @\"ColumnDefinition.Width = \"\"Auto\"\"\";\nTextBlock myTextBlock15 = new TextBlock();\nmyTextBlock15.Text = @\"StackPanel.HorizontalAlignment = \"\"Left\"\"\";\nTextBlock myTextBlock16 = new TextBlock();\nmyTextBlock16.Text = @\"StackPanel.VerticalAlignment = \"\"Top\"\"\";\nTextBlock myTextBlock17 = new TextBlock();\nmyTextBlock17.Text = @\"StackPanel.Orientation = \"\"Vertical\"\"\";\nTextBlock myTextBlock18 = new TextBlock();\nmyTextBlock18.Text = @\"Button.Margin = \"\"10\"\"\";\nmyStackPanel3.Children.Add(myTextBlock13);\nmyStackPanel3.Children.Add(myButton7);\nmyStackPanel3.Children.Add(myButton8);\nmyStackPanel3.Children.Add(myButton9);\nmyStackPanel3.Children.Add(myTextBlock14);\nmyStackPanel3.Children.Add(myTextBlock15);\nmyStackPanel3.Children.Add(myTextBlock16);\nmyStackPanel3.Children.Add(myTextBlock17);\nmyStackPanel3.Children.Add(myTextBlock18);\n\n// Add child content to the parent Grid.\nmyGrid.Children.Add(myStackPanel);\nmyGrid.Children.Add(myStackPanel2);\nmyGrid.Children.Add(myStackPanel3);\n\n// Add the Grid as the lone child of the Border.\nmyBorder.Child = myGrid;\n\n// Add the Border to the Window as Content and show the Window.\nmainWindow.Content = myBorder;\nmainWindow.Title = \"Margin, Padding, and Alignment Sample\";\nmainWindow.Show();\n\nXAML\n<Page xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" WindowTitle=\"Margins, Padding and Alignment Sample\">\n  <Border Background=\"LightBlue\" \n          BorderBrush=\"Black\" \n          BorderThickness=\"2\" \n          CornerRadius=\"45\" \n          Padding=\"25\">\n    <Grid Background=\"White\" ShowGridLines=\"True\">\n      <Grid.ColumnDefinitions>\n        <ColumnDefinition Width=\"Auto\"/>\n        <ColumnDefinition Width=\"*\"/>\n        <ColumnDefinition Width=\"Auto\"/>\n      </Grid.ColumnDefinitions>\n        \n    <StackPanel Grid.Column=\"0\" Grid.Row=\"0\" HorizontalAlignment=\"Left\" Name=\"StackPanel1\" VerticalAlignment=\"Top\">\n        <TextBlock FontSize=\"18\" HorizontalAlignment=\"Center\" Margin=\"0,0,0,15\">StackPanel1</TextBlock>\n        <Button Margin=\"0,10,0,10\">Button 1</Button>\n        <Button Margin=\"0,10,0,10\">Button 2</Button>\n        <Button Margin=\"0,10,0,10\">Button 3</Button>\n        <TextBlock>ColumnDefinition.Width=\"Auto\"</TextBlock>\n        <TextBlock>StackPanel.HorizontalAlignment=\"Left\"</TextBlock>\n        <TextBlock>StackPanel.VerticalAlignment=\"Top\"</TextBlock>\n        <TextBlock>StackPanel.Orientation=\"Vertical\"</TextBlock>\n        <TextBlock>Button.Margin=\"0,10,0,10\"</TextBlock>\n    </StackPanel>\n    \n    <StackPanel Grid.Column=\"1\" Grid.Row=\"0\" HorizontalAlignment=\"Stretch\" Name=\"StackPanel2\" VerticalAlignment=\"Top\" Orientation=\"Vertical\">\n        <TextBlock FontSize=\"18\" HorizontalAlignment=\"Center\" Margin=\"0,0,0,15\">StackPanel2</TextBlock>\n        <Button Margin=\"10,0,10,0\">Button 4</Button>\n        <Button Margin=\"10,0,10,0\">Button 5</Button>\n        <Button Margin=\"10,0,10,0\">Button 6</Button>\n        <TextBlock HorizontalAlignment=\"Center\">ColumnDefinition.Width=\"*\"</TextBlock>\n        <TextBlock HorizontalAlignment=\"Center\">StackPanel.HorizontalAlignment=\"Stretch\"</TextBlock>\n        <TextBlock HorizontalAlignment=\"Center\">StackPanel.VerticalAlignment=\"Top\"</TextBlock>\n        <TextBlock HorizontalAlignment=\"Center\">StackPanel.Orientation=\"Horizontal\"</TextBlock>\n        <TextBlock HorizontalAlignment=\"Center\">Button.Margin=\"10,0,10,0\"</TextBlock>\n    </StackPanel>        \n        \n    <StackPanel Grid.Column=\"2\" Grid.Row=\"0\" HorizontalAlignment=\"Left\" Name=\"StackPanel3\" VerticalAlignment=\"Top\">\n        <TextBlock FontSize=\"18\" HorizontalAlignment=\"Center\" Margin=\"0,0,0,15\">StackPanel3</TextBlock>\n        <Button Margin=\"10\">Button 7</Button>\n        <Button Margin=\"10\">Button 8</Button>\n        <Button Margin=\"10\">Button 9</Button>\n        <TextBlock>ColumnDefinition.Width=\"Auto\"</TextBlock>\n        <TextBlock>StackPanel.HorizontalAlignment=\"Left\"</TextBlock>\n        <TextBlock>StackPanel.VerticalAlignment=\"Top\"</TextBlock>\n        <TextBlock>StackPanel.Orientation=\"Vertical\"</TextBlock>\n        <TextBlock>Button.Margin=\"10\"</TextBlock>      \n    </StackPanel>\n  </Grid>\n  </Border>    \n</Page>\n\nWhen compiled, the preceding application yields a UI that looks like the following illustration. The effects of the various property values are evident in the spacing between elements, and significant property values for elements in each column are shown within\u00a0TextBlock\u00a0elements."
    },
    {
        "title": "5.3 WPF Panels",
        "created_at": "2025-01-21T04:54:31Z",
        "url": "5-dot-3-wpf-panels",
        "editing_roles": "teachers",
        "page_id": 4602768,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/5-dot-3-wpf-panels",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:31Z",
        "locked_for_user": false,
        "body": "Lecture Slides: LayoutPanels.pdf\n\u00a0Recommended Online Resources:\n*Note: these youtube videos are WPF with VB not C#. But XAML and WPF related information are still very useful.\nThe Grid\nStack Panel\nDock Panel"
    },
    {
        "title": "WPF Panels Programming Guide",
        "created_at": "2025-01-21T04:54:47Z",
        "url": "wpf-panels-programming-guide",
        "editing_roles": "teachers",
        "page_id": 4602885,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/wpf-panels-programming-guide",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:47Z",
        "locked_for_user": false,
        "body": "Panels Overview\nPanel\u00a0elements are components that control the rendering of elements\u2014their size and dimensions, their position, and the arrangement of their child content. The Windows Presentation Foundation (WPF) provides a number of predefined\u00a0Panel\u00a0elements as well as the ability to construct custom\u00a0Panel elements.\nThe Panel Class\nPanel\u00a0is the base class for all elements that provide layout support in Windows Presentation Foundation (WPF). Derived\u00a0Panel\u00a0elements are used to position and arrange elements in Extensible Application Markup Language (XAML) and code.\nThe WPF includes a comprehensive suite of derived panel implementations that enable many complex layouts. These derived classes expose properties and methods that enable most standard user interface (UI) scenarios. Developers who are unable to find a child arrangement behavior that meets their needs can create new layouts by overriding the\u00a0ArrangeOverride\u00a0and\u00a0MeasureOverride\u00a0methods. For more information on custom layout behaviors, see\u00a0Custom Panel Elements.\n\nPanel Common Members\nAll\u00a0Panel\u00a0elements support the base sizing and positioning properties defined by\u00a0FrameworkElement, including\u00a0Height,\u00a0Width,\u00a0HorizontalAlignment,\u00a0VerticalAlignment,\u00a0Margin, and\u00a0LayoutTransform. For additional information on positioning properties defined by\u00a0FrameworkElement, see\u00a0Alignment, Margins, and Padding Overview.\nPanel\u00a0exposes additional properties that are of critical importance in understanding and using layout. The\u00a0Background\u00a0property is used to fill the area between the boundaries of a derived panel element with a\u00a0Brush.\u00a0Children\u00a0represents the child collection of elements that the\u00a0Panel\u00a0is comprised of.\u00a0InternalChildren\u00a0represents the content of the\u00a0Children\u00a0collection plus those members generated by data binding. Both consist of a\u00a0UIElementCollection\u00a0of child elements hosted within the parent\u00a0Panel.\nPanel also exposes a\u00a0Panel.ZIndex\u00a0attached property that can be used to achieve layered order in a derived\u00a0Panel. Members of a panel's\u00a0Children\u00a0collection with a higher\u00a0Panel.ZIndex\u00a0value appear in front of those with a lower\u00a0Panel.ZIndex\u00a0value. This is particularly useful for panels such as\u00a0Canvas\u00a0and\u00a0Grid\u00a0which allow children to share the same coordinate space.\nPanel\u00a0also defines the\u00a0OnRender\u00a0method, which can be used to override the default presentation behavior of a\u00a0Panel.\n\u00a0\nDerived Panel Elements\nMany objects derive from\u00a0Panel, but not all of them are intended for use as root layout providers. There are six defined panel classes (Canvas,\u00a0DockPanel,\u00a0Grid,\u00a0StackPanel,\u00a0VirtualizingStackPanel, and\u00a0WrapPanel) that are designed specifically for creating application UI.\nEach panel element encapsulates its own special functionality, as seen in the following table. Element Name\nUI Panel?\nDescription Canvas\nYes\nDefines an area within which you can explicitly position child elements by coordinates relative to the\u00a0Canvas\u00a0area. DockPanel\nYes\nDefines an area within which you can arrange child elements either horizontally or vertically, relative to each other. Grid\nYes\nDefines a flexible grid area consisting of columns and rows. Child elements of a\u00a0Grid\u00a0can be positioned precisely using the\u00a0Margin\u00a0property. StackPanel\nYes\nArranges child elements into a single line that can be oriented horizontally or vertically. TabPanel\nNo\nHandles the layout of tab buttons in a\u00a0TabControl. ToolBarOverflowPanel\nNo\nArranges content within a\u00a0ToolBar\u00a0control. UniformGrid\nNo\n\nUniformGrid\u00a0is used to arrange children in a grid with all equal cell sizes. VirtualizingPanel\nNo\nProvides a base class for panels that can \"virtualize\" their children collection. VirtualizingStackPanel\nYes\nArranges and virtualizes content on a single line oriented horizontally or vertically. WrapPanel\nYes\n\nWrapPanel\u00a0positions child elements in sequential position from left to right, breaking content to the next line at the edge of the containing box. Subsequent ordering happens sequentially from top to bottom or right to left, depending on the value of the\u00a0Orientation\u00a0property."
    },
    {
        "title": "GridPanel Programming Guide",
        "created_at": "2025-01-21T04:54:38Z",
        "url": "gridpanel-programming-guide",
        "editing_roles": "teachers",
        "page_id": 4602810,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/gridpanel-programming-guide",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:38Z",
        "locked_for_user": false,
        "body": "Grid\nThe\u00a0Grid\u00a0element merges the functionality of an absolute positioning and tabular data control. A\u00a0Grid\u00a0enables you to easily position and style elements.\u00a0Grid\u00a0allows you to define flexible row and column groupings, and even provides a mechanism to share sizing information between multiple\u00a0Grid\u00a0elements.\nHow is Grid Different from Table?\nTable\u00a0and\u00a0Grid\u00a0share some common functionality, but each is best suited for different scenarios. A\u00a0Table\u00a0is designed for use within flow content (see\u00a0Flow Document Overview\u00a0for more information on flow content). Grids are best used inside of forms (basically anywhere outside of flow content). Within a\u00a0FlowDocument,\u00a0Table\u00a0supports flow content behaviors like pagination, column reflow, and content selection while a\u00a0Grid\u00a0does not. A\u00a0Grid\u00a0on the other hand is best used outside of a\u00a0FlowDocument\u00a0for many reasons including\u00a0Grid\u00a0adds elements based on a row and column index,\u00a0Table\u00a0does not. The\u00a0Grid\u00a0element allows layering of child content, allowing more than one element to exist within a single \"cell.\"\u00a0Table\u00a0does not support layering. Child elements of a\u00a0Grid\u00a0can be absolutely positioned relative to the area of their \"cell\" boundaries.\u00a0Table\u00a0does not support this feature. Finally, a\u00a0Grid\u00a0is lighter weight than a\u00a0Table.\nSizing Behavior of Columns and Rows\nColumns and rows defined within a\u00a0Grid\u00a0can take advantage of\u00a0Star\u00a0sizing in order to distribute remaining space proportionally. When\u00a0Star\u00a0is selected as the Height or Width of a row or column, that column or row receives a weighted proportion of remaining available space. This is in contrast to\u00a0Auto, which will distribute space evenly based on the size of the content within a column or row. This value is expressed as\u00a0*\u00a0or\u00a02*\u00a0when using Extensible Application Markup Language (XAML). In the first case, the row or column would receive one times the available space, in the second case, two times, and so on. By combining this technique to proportionally distribute space with a\u00a0HorizontalAlignment\u00a0and\u00a0VerticalAlignment\u00a0value of\u00a0Stretch\u00a0it is possible to partition layout space by percentage of screen space.\u00a0Grid\u00a0is the only layout panel that can distribute space in this manner.\nDefining and Using a Grid\nThe following example demonstrates how to build a UI similar to that found on the Run dialog available on the Windows Start menu.\n\nC#Copy\n\n// Create the Grid.\ngrid1 = new Grid ();\ngrid1.Background = Brushes.Gainsboro;\ngrid1.HorizontalAlignment = HorizontalAlignment.Left;\ngrid1.VerticalAlignment = VerticalAlignment.Top;\ngrid1.ShowGridLines = true;\ngrid1.Width = 425;\ngrid1.Height = 165;\n\n// Define the Columns.\ncolDef1 = new ColumnDefinition();\ncolDef1.Width = new GridLength(1, GridUnitType.Auto);\ncolDef2 = new ColumnDefinition();\ncolDef2.Width = new GridLength(1, GridUnitType.Star);\ncolDef3 = new ColumnDefinition();\ncolDef3.Width = new GridLength(1, GridUnitType.Star);\ncolDef4 = new ColumnDefinition();\ncolDef4.Width = new GridLength(1, GridUnitType.Star);\ncolDef5 = new ColumnDefinition();\ncolDef5.Width = new GridLength(1, GridUnitType.Star);\ngrid1.ColumnDefinitions.Add(colDef1);\ngrid1.ColumnDefinitions.Add(colDef2);\ngrid1.ColumnDefinitions.Add(colDef3);\ngrid1.ColumnDefinitions.Add(colDef4);\ngrid1.ColumnDefinitions.Add(colDef5);\n\n// Define the Rows.\nrowDef1 = new RowDefinition();\nrowDef1.Height = new GridLength(1, GridUnitType.Auto);\nrowDef2 = new RowDefinition();\nrowDef2.Height = new GridLength(1, GridUnitType.Auto);\nrowDef3 = new RowDefinition();\nrowDef3.Height = new GridLength(1, GridUnitType.Star);\nrowDef4 = new RowDefinition();\nrowDef4.Height = new GridLength(1, GridUnitType.Auto);\ngrid1.RowDefinitions.Add(rowDef1);\ngrid1.RowDefinitions.Add(rowDef2);\ngrid1.RowDefinitions.Add(rowDef3);\ngrid1.RowDefinitions.Add(rowDef4);\n\n// Add the Image.\nimg1 = new Image();\nimg1.Source = new System.Windows.Media.Imaging.BitmapImage(new Uri(\"runicon.png\", UriKind.Relative));\nGrid.SetRow(img1, 0);\nGrid.SetColumn(img1, 0);\n\n// Add the main application dialog.\ntxt1 = new TextBlock();\ntxt1.Text = \"Type the name of a program, folder, document, or Internet resource, and Windows will open it for you.\";\ntxt1.TextWrapping = TextWrapping.Wrap;\nGrid.SetColumnSpan(txt1, 4);\nGrid.SetRow(txt1, 0);\nGrid.SetColumn(txt1, 1);\n\n// Add the second text cell to the Grid.\ntxt2 = new TextBlock();\ntxt2.Text = \"Open:\";\nGrid.SetRow(txt2, 1);\nGrid.SetColumn(txt2, 0);\n\n// Add the TextBox control.\ntb1 = new TextBox();\nGrid.SetRow(tb1, 1);\nGrid.SetColumn(tb1, 1);\nGrid.SetColumnSpan(tb1, 5);\n\n// Add the buttons.\nbutton1 = new Button();\nbutton2 = new Button();\nbutton3 = new Button();\nbutton1.Content = \"OK\";\nbutton2.Content = \"Cancel\";\nbutton3.Content = \"Browse ...\";\nGrid.SetRow(button1, 3);\nGrid.SetColumn(button1, 2);\nbutton1.Margin = new Thickness(10, 0, 10, 15);\nbutton2.Margin = new Thickness(10, 0, 10, 15);\nbutton3.Margin = new Thickness(10, 0, 10, 15);\nGrid.SetRow(button2, 3);\nGrid.SetColumn(button2, 3);\nGrid.SetRow(button3, 3);\nGrid.SetColumn(button3, 4);\n\ngrid1.Children.Add(img1);\ngrid1.Children.Add(txt1);\ngrid1.Children.Add(txt2);\ngrid1.Children.Add(tb1);\ngrid1.Children.Add(button1);\ngrid1.Children.Add(button2);\ngrid1.Children.Add(button3);\n\nmainWindow.Content = grid1;\n\nThe compiled application yields a new UI that looks like this."
    },
    {
        "title": "DockPanel Programming Guide",
        "created_at": "2025-01-21T04:54:35Z",
        "url": "dockpanel-programming-guide",
        "editing_roles": "teachers",
        "page_id": 4602796,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/dockpanel-programming-guide",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:35Z",
        "locked_for_user": false,
        "body": "DockPanel\nThe\u00a0DockPanel\u00a0element uses the\u00a0DockPanel.Dock\u00a0attached property as set in child content elements to position content along the edges of a container. When\u00a0DockPanel.Dock\u00a0is set to\u00a0Top\u00a0or\u00a0Bottom, it positions child elements above or below each other. When\u00a0DockPanel.Dock\u00a0is set to\u00a0Left\u00a0or\u00a0Right, it positions child elements to the left or right of each other. The\u00a0LastChildFill\u00a0property determines the position of the final element added as a child of a\u00a0DockPanel.\nYou can use\u00a0DockPanel\u00a0to position a group of related controls, such as a set of buttons. Alternately, you can use it to create a \"paned\" UI, similar to that found in Microsoft Outlook.\nSizing to Content\nIf its\u00a0Height\u00a0and\u00a0Width\u00a0properties are not specified,\u00a0DockPanel\u00a0sizes to its content. The size can increase or decrease to accommodate the size of its child elements. However, when these properties are specified and there is no longer room for the next specified child element,\u00a0DockPanel\u00a0does not display that child element or subsequent child elements and does not measure subsequent child elements.\nLastChildFill\nBy default, the last child of a\u00a0DockPanel\u00a0element will \"fill\" the remaining, unallocated space. If this behavior is not desired, set the\u00a0LastChildFill\u00a0property to\u00a0false.\nDefining and Using a DockPanel\nThe following example demonstrates how to partition space using a\u00a0DockPanel. Five\u00a0Border\u00a0elements are added as children of a parent\u00a0DockPanel. Each uses a different positioning property of a\u00a0DockPanel\u00a0to partition space. The final element \"fills\" the remaining, unallocated space.\nC#\n\n// Create the application's main window\nmainWindow = new Window ();\nmainWindow.Title = \"DockPanel Sample\";\n\n// Create the DockPanel\nDockPanel myDockPanel = new DockPanel();\nmyDockPanel.LastChildFill = true;\n\n// Define the child content\nBorder myBorder1 = new Border();\nmyBorder1.Height = 25;\nmyBorder1.Background = Brushes.SkyBlue;\nmyBorder1.BorderBrush = Brushes.Black;\nmyBorder1.BorderThickness = new Thickness(1);\nDockPanel.SetDock(myBorder1, Dock.Top);\nTextBlock myTextBlock1 = new TextBlock();\nmyTextBlock1.Foreground = Brushes.Black;\nmyTextBlock1.Text = \"Dock = Top\";\nmyBorder1.Child = myTextBlock1;\n\nBorder myBorder2 = new Border();\nmyBorder2.Height = 25;\nmyBorder2.Background = Brushes.SkyBlue;\nmyBorder2.BorderBrush = Brushes.Black;\nmyBorder2.BorderThickness = new Thickness(1);\nDockPanel.SetDock(myBorder2, Dock.Top);\nTextBlock myTextBlock2 = new TextBlock();\nmyTextBlock2.Foreground = Brushes.Black;\nmyTextBlock2.Text = \"Dock = Top\";\nmyBorder2.Child = myTextBlock2;\n\nBorder myBorder3 = new Border();\nmyBorder3.Height = 25;\nmyBorder3.Background = Brushes.LemonChiffon;\nmyBorder3.BorderBrush = Brushes.Black;\nmyBorder3.BorderThickness = new Thickness(1);\nDockPanel.SetDock(myBorder3, Dock.Bottom);\nTextBlock myTextBlock3 = new TextBlock();\nmyTextBlock3.Foreground = Brushes.Black;\nmyTextBlock3.Text = \"Dock = Bottom\";\nmyBorder3.Child = myTextBlock3;\n\nBorder myBorder4 = new Border();\nmyBorder4.Width = 200;\nmyBorder4.Background = Brushes.PaleGreen;\nmyBorder4.BorderBrush = Brushes.Black;\nmyBorder4.BorderThickness = new Thickness(1);\nDockPanel.SetDock(myBorder4, Dock.Left);\nTextBlock myTextBlock4 = new TextBlock();\nmyTextBlock4.Foreground = Brushes.Black;\nmyTextBlock4.Text = \"Dock = Left\";\nmyBorder4.Child = myTextBlock4;\n\nBorder myBorder5 = new Border();\nmyBorder5.Background = Brushes.White;\nmyBorder5.BorderBrush = Brushes.Black;\nmyBorder5.BorderThickness = new Thickness(1);\nTextBlock myTextBlock5 = new TextBlock();\nmyTextBlock5.Foreground = Brushes.Black;\nmyTextBlock5.Text = \"This content will Fill the remaining space\";\nmyBorder5.Child = myTextBlock5; // Add child elements to the DockPanel Children collection\nmyDockPanel.Children.Add(myBorder1);\nmyDockPanel.Children.Add(myBorder2);\nmyDockPanel.Children.Add(myBorder3);\nmyDockPanel.Children.Add(myBorder4);\nmyDockPanel.Children.Add(myBorder5);\n           \n// Add the parent Canvas as the Content of the Window Object\nmainWindow.Content = myDockPanel;\nmainWindow.Show (); XAML\n<Page xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" WindowTitle=\"DockPanel Sample\">\n  <DockPanel LastChildFill=\"True\">\n    <Border Height=\"25\" Background=\"SkyBlue\" BorderBrush=\"Black\" BorderThickness=\"1\" DockPanel.Dock=\"Top\">\n      <TextBlock Foreground=\"Black\">Dock = \"Top\"</TextBlock>\n    </Border>\n    <Border Height=\"25\" Background=\"SkyBlue\" BorderBrush=\"Black\" BorderThickness=\"1\" DockPanel.Dock=\"Top\">\n      <TextBlock Foreground=\"Black\">Dock = \"Top\"</TextBlock>\n    </Border>\n    <Border Height=\"25\" Background=\"LemonChiffon\" BorderBrush=\"Black\" BorderThickness=\"1\" DockPanel.Dock=\"Bottom\">\n      <TextBlock Foreground=\"Black\">Dock = \"Bottom\"</TextBlock>\n    </Border>\n    <Border Width=\"200\" Background=\"PaleGreen\" BorderBrush=\"Black\" BorderThickness=\"1\" DockPanel.Dock=\"Left\">\n      <TextBlock Foreground=\"Black\">Dock = \"Left\"</TextBlock>\n    </Border>\n    <Border Background=\"White\" BorderBrush=\"Black\" BorderThickness=\"1\">\n      <TextBlock Foreground=\"Black\">This content will \"Fill\" the remaining space</TextBlock>\n    </Border>\n  </DockPanel>\n</Page>\n\nThe compiled application yields a new UI that looks like this."
    },
    {
        "title": "StackPanel Programming Guide",
        "created_at": "2025-01-21T04:54:44Z",
        "url": "stackpanel-programming-guide",
        "editing_roles": "teachers",
        "page_id": 4602866,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/stackpanel-programming-guide",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:44Z",
        "locked_for_user": false,
        "body": "StackPanel\nA\u00a0StackPanel\u00a0enables you to \"stack\" elements in an assigned direction. The default stack direction is vertical. The\u00a0Orientation\u00a0property can be used to control content flow.\nStackPanel vs. DockPanel\nAlthough\u00a0DockPanel\u00a0can also \"stack\" child elements,\u00a0DockPanel\u00a0and\u00a0StackPanel\u00a0do not produce analogous results in some usage scenarios. For example, the order of child elements can affect their size in a\u00a0DockPanel\u00a0but not in a\u00a0StackPanel. This is because\u00a0StackPanel\u00a0measures in the direction of stacking at\u00a0PositiveInfinity, whereas\u00a0DockPanel\u00a0measures only the available size.\nThe following example demonstrates this key difference.\n\nC#Copy\n\n// Create the application's main window\nmainWindow = new Window ();\nmainWindow.Title = \"StackPanel vs. DockPanel\";\n\n// Add root Grid\nmyGrid = new Grid();\nmyGrid.Width = 175;\nmyGrid.Height = 150;\nRowDefinition myRowDef1 = new RowDefinition();\nRowDefinition myRowDef2 = new RowDefinition();\nmyGrid.RowDefinitions.Add(myRowDef1);\nmyGrid.RowDefinitions.Add(myRowDef2);\n\n// Define the DockPanel\nmyDockPanel = new DockPanel();\nGrid.SetRow(myDockPanel, 0);\n\n//Define an Image and Source\nImage myImage = new Image();\nBitmapImage bi = new BitmapImage();\nbi.BeginInit();\nbi.UriSource = new Uri(\"smiley_stackpanel.png\", UriKind.Relative);\nbi.EndInit();\nmyImage.Source = bi;\n\nImage myImage2 = new Image();\nBitmapImage bi2 = new BitmapImage();\nbi2.BeginInit();\nbi2.UriSource = new Uri(\"smiley_stackpanel.png\", UriKind.Relative);\nbi2.EndInit();\nmyImage2.Source = bi2;\n\nImage myImage3 = new Image();\nBitmapImage bi3 = new BitmapImage();\nbi3.BeginInit();\nbi3.UriSource = new Uri(\"smiley_stackpanel.PNG\", UriKind.Relative);\nbi3.EndInit();\nmyImage3.Stretch = Stretch.Fill;\nmyImage3.Source = bi3;\n\n// Add the images to the parent DockPanel\nmyDockPanel.Children.Add(myImage);\nmyDockPanel.Children.Add(myImage2);\nmyDockPanel.Children.Add(myImage3);\n\n//Define a StackPanel\nmyStackPanel = new StackPanel();\nmyStackPanel.Orientation = Orientation.Horizontal;\nGrid.SetRow(myStackPanel, 1);\n\nImage myImage4 = new Image();\nBitmapImage bi4 = new BitmapImage();\nbi4.BeginInit();\nbi4.UriSource = new Uri(\"smiley_stackpanel.png\", UriKind.Relative);\nbi4.EndInit();\nmyImage4.Source = bi4;\n\nImage myImage5 = new Image();\nBitmapImage bi5 = new BitmapImage();\nbi5.BeginInit();\nbi5.UriSource = new Uri(\"smiley_stackpanel.png\", UriKind.Relative);\nbi5.EndInit();\nmyImage5.Source = bi5;\n\nImage myImage6 = new Image();\nBitmapImage bi6 = new BitmapImage();\nbi6.BeginInit();\nbi6.UriSource = new Uri(\"smiley_stackpanel.PNG\", UriKind.Relative);\nbi6.EndInit();\nmyImage6.Stretch = Stretch.Fill;\nmyImage6.Source = bi6;\n\n// Add the images to the parent StackPanel\nmyStackPanel.Children.Add(myImage4);\nmyStackPanel.Children.Add(myImage5);\nmyStackPanel.Children.Add(myImage6);\n\n// Add the layout panels as children of the Grid\nmyGrid.Children.Add(myDockPanel);\nmyGrid.Children.Add(myStackPanel);\n\n// Add the Grid as the Content of the Parent Window Object\nmainWindow.Content = myGrid;\nmainWindow.Show (); XAMLCopy\n<Page xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n      WindowTitle=\"StackPanel vs. DockPanel\">\n  <Grid Width=\"175\" Height=\"150\">\n    <Grid.ColumnDefinitions>\n      <ColumnDefinition />\n    </Grid.ColumnDefinitions>\n    <Grid.RowDefinitions>\n      <RowDefinition />\n      <RowDefinition />\n    </Grid.RowDefinitions>\n    \n    <DockPanel Grid.Column=\"0\" Grid.Row=\"0\">\n      <Image Source=\"smiley_stackpanel.png\" />\n      <Image Source=\"smiley_stackpanel.png\" />\n      <Image Source=\"smiley_stackpanel.png\" Stretch=\"Fill\"/>\n    </DockPanel>\n\n    <StackPanel Grid.Column=\"0\" Grid.Row=\"1\"  Orientation=\"Horizontal\">\n      <Image Source=\"smiley_stackpanel.png\" />\n      <Image Source=\"smiley_stackpanel.png\" />\n      <Image Source=\"smiley_stackpanel.png\" Stretch=\"Fill\"/>\n    </StackPanel>\n    </Grid>\n</Page>\n\nThe difference in rendering behavior can be seen in this image.\n\nDefining and Using a StackPanel\nThe following example demonstrates how to use a\u00a0StackPanel\u00a0to create a set of vertically-positioned buttons. For horizontal positioning, set the\u00a0Orientation\u00a0property to\u00a0Horizontal.\n\nC#Copy\n\n  // Create the application's main window\n  mainWindow = new Window ();\n  mainWindow.Title = \"StackPanel Sample\";\n\n  // Define the StackPanel\n  myStackPanel = new StackPanel();\n  myStackPanel.HorizontalAlignment = HorizontalAlignment.Left;\n  myStackPanel.VerticalAlignment = VerticalAlignment.Top;\n\n  // Define child content\n  Button myButton1 = new Button();\n  myButton1.Content = \"Button 1\";\n  Button myButton2 = new Button();\n  myButton2.Content = \"Button 2\";\n  Button myButton3 = new Button();\n  myButton3.Content = \"Button 3\";\n\n  // Add child elements to the parent StackPanel\n  myStackPanel.Children.Add(myButton1);\n  myStackPanel.Children.Add(myButton2);\n  myStackPanel.Children.Add(myButton3);           \n\n  // Add the StackPanel as the Content of the Parent Window Object\n  mainWindow.Content = myStackPanel;\n  mainWindow.Show (); The compiled application yields a new UI that looks like this."
    },
    {
        "title": "5.4 WPF Controls",
        "created_at": "2025-01-21T04:54:31Z",
        "url": "5-dot-4-wpf-controls",
        "editing_roles": "teachers",
        "page_id": 4602769,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/5-dot-4-wpf-controls",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:31Z",
        "locked_for_user": false,
        "body": "Lecture Slides: Controls.pdf\n\u00a0Sample Code: Example Set 1.zip\n\u00a0Video Lectures:"
    },
    {
        "title": "M4 Roadmap & Objectives",
        "created_at": "2025-01-21T04:54:41Z",
        "url": "m4-roadmap-and-objectives",
        "editing_roles": "teachers",
        "page_id": 4602841,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/m4-roadmap-and-objectives",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:41Z",
        "locked_for_user": false,
        "body": "M4 Objectives\n\nAfter completing this week's work, you will be able to:\n\nDeclare an enumeration type.\nCreate and use an enumeration type.\nDeclare a structure type.\nCreate and use a structure type.\nExplain the differences in behavior between a structure and a class.\nCreate and modify strings\nExplain the difference between a value type and a reference type\nModify the way in which arguments are passed as method parameters by using the ref and out keywords\u00a0\n\n\u00a0\n\n\u00a0M4 Activities\u00a0 Watch Video Lectures\nRead Lecture Slides & Programming Guide,\nPractice with Sample Code\nComplete M4 Quiz and Assignment"
    },
    {
        "title": "4.1 Enum & Struct",
        "created_at": "2025-01-21T04:54:31Z",
        "url": "4-dot-1-enum-and-struct",
        "editing_roles": "teachers",
        "page_id": 4602762,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/4-dot-1-enum-and-struct",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:31Z",
        "locked_for_user": false,
        "body": "Lecture Slides: Enum_Struct.pdf\n\u00a0Sample Code:\u00a0: StructsAndEnums.zip\nRecommended Online Resources:\n\nChannel 9 -  Enumerations and the Switch Decision Statement\n\n\u00a0When do you use structs vs classes? (starts at around 4')"
    },
    {
        "title": "Struct Programming Guide",
        "created_at": "2025-01-21T04:54:45Z",
        "url": "struct-programming-guide",
        "editing_roles": "teachers",
        "page_id": 4602868,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/struct-programming-guide",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:45Z",
        "locked_for_user": false,
        "body": "struct\u00a0\nA\u00a0struct\u00a0type is a value type that is typically used to encapsulate small groups of related variables, such as the coordinates of a rectangle or the characteristics of an item in an inventory. The following example shows a simple struct declaration:\nC#\npublic struct Book\n{\n    public decimal price;\n    public string title;\n    public string author;\n}\n\n\u00a0\nStructs can also contain\u00a0constructors,\u00a0constants,\u00a0fields,\u00a0methods,\u00a0properties,\u00a0indexers,\u00a0operators,\u00a0events, and\u00a0nested types, although if several such members are required, you should consider making your type a class instead.\nstruct vs. class\nThe\u00a0struct\u00a0type is suitable for representing lightweight objects such as\u00a0Point,\u00a0Rectangle, and\u00a0Color. Although it is just as convenient to represent a point as a\u00a0class\u00a0with\u00a0Auto-Implemented Properties, a\u00a0struct\u00a0might be more efficient in some scenarios. For example, if you declare an array of 1000\u00a0Point\u00a0objects, you will allocate additional memory for referencing each object; in this case, a struct would be less expensive. Because .NET already contains an object called\u00a0Point, the struct in this example is named\u00a0Coords\u00a0instead.\nC#\npublic struct Coords\n{\n    public int x, y;\n\n    public Coords(int p1, int p2)\n    {\n        x = p1;\n        y = p2;\n    }\n}\n\nIt is an error to define a parameterless constructor for a struct. It is also an error to initialize an instance field in a struct body. You can initialize externally accessible struct members only by using a parameterized constructor, the implicit, parameterless constructor, an\u00a0object initializer, or by accessing the members individually after the struct is declared. Any private or otherwise inaccessible members require the use of constructors exclusively.\nWhen you create a struct object using the\u00a0new\u00a0operator, it gets created and the appropriate constructor is called according to the\u00a0constructor's signature. Unlike classes, structs can be instantiated without using the\u00a0new\u00a0operator. In such a case, there is no constructor call, which makes the allocation more efficient. However, the fields will remain unassigned and the object cannot be used until all of the fields are initialized. This includes the inability to get or set values through properties.\nIf you instantiate a struct object using the parameterless constructor, all members are assigned according to their\u00a0default values.\nWhen writing a constructor with parameters for a struct, you must explicitly initialize all members; otherwise one or more members remain unassigned and the struct cannot be used, producing compiler error\u00a0CS0171.\nThere is no inheritance for structs as there is for classes. A struct cannot inherit from another struct or class, and it cannot be the base of a class. Structs, however, inherit from the base class\u00a0Object. A struct can implement interfaces, and it does that exactly as classes do.\nYou cannot declare a class using the keyword\u00a0struct. In C#, classes and structs are semantically different. A struct is a value type, while a class is a reference type. For more information, see\u00a0Value types\u00a0and\u00a0Reference types.\nUnless you need reference-type semantics, a small class may be more efficiently handled by the system if you declare it as a struct instead.\nExample 1\nThis example demonstrates\u00a0struct\u00a0initialization using both parameterless and parameterized constructors.\nC#\npublic struct Coords\n{\n    public int x, y;\n\n    public Coords(int p1, int p2)\n    {\n        x = p1;\n        y = p2;\n    }\n} C#Copy\n// Declare and initialize struct objects.\nclass TestCoords\n{\n    static void Main()\n    {\n        // Initialize.\n        var coords1 = new Coords();\n        var coords2 = new Coords(10, 10);\n\n        // Display results.\n        Console.Write(\"Coords 1: \");\n        Console.WriteLine($\"x = {coords1.x}, y = {coords1.y}\");\n\n        Console.Write(\"Coords 2: \");\n        Console.WriteLine($\"x = {coords2.x}, y = {coords2.y}\");\n\n        // Keep the console window open in debug mode.\n        Console.WriteLine(\"Press any key to exit.\");\n        Console.ReadKey();\n    }\n}\n/* Output:\n    Coords 1: x = 0, y = 0\n    Coords 2: x = 10, y = 10\n*/\n\nExample 2\nThis example demonstrates a feature that is unique to structs. It creates a Coords object without using the\u00a0new\u00a0operator. If you replace the word\u00a0struct\u00a0with the word\u00a0class, the program will not compile.\nC#\npublic struct Coords\n{\n    public int x, y;\n\n    public Coords(int p1, int p2)\n    {\n        x = p1;\n        y = p2;\n    }\n} C#Copy\n// Declare a struct object without \"new\".\nclass TestCoordsNoNew\n{\n    static void Main()\n    {\n        // Declare an object.\n        Coords coords1;\n\n        // Initialize.\n        coords1.x = 10;\n        coords1.y = 20;\n\n        // Display results.\n        Console.Write(\"Coords 1: \");\n        Console.WriteLine($\"x = {coords1.x}, y = {coords1.y}\");\n\n        // Keep the console window open in debug mode.\n        Console.WriteLine(\"Press any key to exit.\");\n        Console.ReadKey();\n    }\n}\n// Output: Coords 1: x = 10, y = 20"
    },
    {
        "title": "Enum Programming Guide",
        "created_at": "2025-01-21T04:54:35Z",
        "url": "enum-programming-guide",
        "editing_roles": "teachers",
        "page_id": 4602797,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/enum-programming-guide",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:35Z",
        "locked_for_user": false,
        "body": "enum\u00a0\nThe\u00a0enum\u00a0keyword is used to declare an enumeration, a distinct type that consists of a set of named constants called the enumerator list.\nUsually it is best to define an enum directly within a namespace so that all classes in the namespace can access it with equal convenience. However, an enum can also be nested within a class or struct.\nBy default, the first enumerator has the value 0, and the value of each successive enumerator is increased by 1. For example, in the following enumeration,\u00a0Sat\u00a0is\u00a00,\u00a0Sun\u00a0is\u00a01,\u00a0Mon\u00a0is\u00a02, and so forth.\nC#\nenum Day {Sat, Sun, Mon, Tue, Wed, Thu, Fri};\n\nEnumerators can use initializers to override the default values, as shown in the following example.\nC#\nenum Day {Sat=1, Sun, Mon, Tue, Wed, Thu, Fri};\n\nIn this enumeration, the sequence of elements is forced to start from\u00a01\u00a0instead of\u00a00. However, including a constant that has the value of 0 is recommended. For more information, see\u00a0Enumeration Types.\nEvery enumeration type has an underlying type, which can be any\u00a0integral numeric type. The\u00a0 char\u00a0type cannot be an underlying type of an enum. The default underlying type of enumeration elements is\u00a0int. To declare an enum of another integral type, such as\u00a0byte, use a colon after the identifier followed by the type, as shown in the following example.\n\nC#Copy\nenum Day : byte {Sat=1, Sun, Mon, Tue, Wed, Thu, Fri};\n\nA variable of an enumeration type can be assigned any value in the range of the underlying type; the values are not limited to the named constants.\nThe default value of an\u00a0enum E\u00a0is the value produced by the expression\u00a0(E)0.\n\n\u00a0Note\nAn enumerator cannot contain white space in its name.\n\nThe underlying type specifies how much storage is allocated for each enumerator. However, an explicit cast is necessary to convert from\u00a0enum\u00a0type to an integral type. For example, the following statement assigns the enumerator\u00a0Sun\u00a0to a variable of the type\u00a0int\u00a0by using a cast to convert from\u00a0enum\u00a0to\u00a0int.\n\nC#Copy\nint x = (int)Day.Sun;\n\nWhen you apply\u00a0System.FlagsAttribute\u00a0to an enumeration that contains elements that can be combined with a bitwise\u00a0OR\u00a0operation, the attribute affects the behavior of the\u00a0enum\u00a0when it is used with some tools. You can notice these changes when you use tools such as the\u00a0Console\u00a0class methods and the Expression Evaluator. (See the third example.)\nRobust programming\nJust as with any constant, all references to the individual values of an enum are converted to numeric literals at compile time. This can create potential versioning issues as described in\u00a0Constants.\nAssigning additional values to new versions of enums, or changing the values of the enum members in a new version, can cause problems for dependent source code. Enum values often are used in\u00a0switch\u00a0statements. If additional elements have been added to the\u00a0enum\u00a0type, the default section of the switch statement can be selected unexpectedly.\nIf other developers use your code, you should provide guidelines about how their code should react if new elements are added to any\u00a0enum\u00a0types.\nExample\nIn the following example, an enumeration,\u00a0Day, is declared. Two enumerators are explicitly converted to integer and assigned to integer variables.\nC#\npublic class EnumTest\n{\n    enum Day { Sun, Mon, Tue, Wed, Thu, Fri, Sat };\n\n    static void Main()\n    {\n        int x = (int)Day.Sun;\n        int y = (int)Day.Fri;\n        Console.WriteLine(\"Sun = {0}\", x);\n        Console.WriteLine(\"Fri = {0}\", y);\n    }\n}\n/* Output:\n   Sun = 0\n   Fri = 5\n*/\n\nExample\n\nIn the following example, the base-type option is used to declare an\u00a0enum\u00a0whose members are of type\u00a0long. Notice that even though the underlying type of the enumeration is\u00a0long, the enumeration members still must be explicitly converted to type\u00a0long\u00a0by using a cast.\nC#\npublic class EnumTest2\n{\n    enum Range : long { Max = 2147483648L, Min = 255L };\n    static void Main()\n    {\n        long x = (long)Range.Max;\n        long y = (long)Range.Min;\n        Console.WriteLine(\"Max = {0}\", x);\n        Console.WriteLine(\"Min = {0}\", y);\n    }\n}\n/* Output:\n   Max = 2147483648\n   Min = 255\n*/\n\nExample\n\nThe following code example illustrates the use and effect of the\u00a0System.FlagsAttribute\u00a0attribute on an\u00a0enum\u00a0declaration.\nC#\n// Add the attribute Flags or FlagsAttribute.\n[Flags]\npublic enum CarOptions\n{\n    // The flag for SunRoof is 0001.\n    SunRoof = 0x01,\n    // The flag for Spoiler is 0010.\n    Spoiler = 0x02,\n    // The flag for FogLights is 0100.\n    FogLights = 0x04,\n    // The flag for TintedWindows is 1000.\n    TintedWindows = 0x08,\n}\n\nclass FlagTest\n{\n    static void Main()\n    {\n        // The bitwise OR of 0001 and 0100 is 0101.\n        CarOptions options = CarOptions.SunRoof | CarOptions.FogLights;\n\n        // Because the Flags attribute is specified, Console.WriteLine displays\n        // the name of each enum element that corresponds to a flag that has\n        // the value 1 in variable options.\n        Console.WriteLine(options);\n        // The integer value of 0101 is 5.\n        Console.WriteLine((int)options);\n    }\n}\n/* Output:\n   SunRoof, FogLights\n   5\n*/\n\nComments\n\nIf you remove\u00a0Flags, the example displays the following values:\n5\n5"
    },
    {
        "title": "4.2 Reference and Value Types",
        "created_at": "2025-01-21T04:54:31Z",
        "url": "4-dot-2-reference-and-value-types",
        "editing_roles": "teachers",
        "page_id": 4602763,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/4-dot-2-reference-and-value-types",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:31Z",
        "locked_for_user": false,
        "body": "Lecture Slides: ValueRefType.pdf\n\u00a0Video Lectures:"
    },
    {
        "title": "Value Types Programming Guide",
        "created_at": "2025-01-21T04:54:46Z",
        "url": "value-types-programming-guide",
        "editing_roles": "teachers",
        "page_id": 4602877,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/value-types-programming-guide",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:46Z",
        "locked_for_user": false,
        "body": "Value types\u00a0\nThere are two kinds of value types: Structs Enumerations Main features of value types\nA variable of a value type contains a value of the type. For example, a variable of the\u00a0int\u00a0type might contain the value\u00a042. This differs from a variable of a reference type, which contains a reference to an instance of the type, also known as an object. When you assign a new value to a variable of a value type, that value is copied. When you assign a new value to a variable of a reference type, the reference is copied, not the object itself.\nAll value types are derived implicitly from the\u00a0System.ValueType.\nUnlike with reference types, you cannot derive a new type from a value type. However, like reference types, structs can implement interfaces.\nValue type variables cannot be\u00a0null\u00a0by default. However, variables of the corresponding\u00a0nullable value types\u00a0can be\u00a0null.\nEach value type has an implicit parameterless constructor that initializes the default value of that type. For information about default values of value types, see\u00a0Default values table.\nSimple types\nThe\u00a0simple types\u00a0are a set of predefined struct types provided by C# and comprise the following types: Integral types: integer numeric types and the\u00a0char\u00a0type\nFloating-point types\nbool\n\nThe simple types are identified through keywords, but these keywords are simply aliases for predefined struct types in the\u00a0System\u00a0namespace. For example,\u00a0int\u00a0is an alias of\u00a0System.Int32. For a complete list of aliases, see\u00a0Built-in types table.\nThe simple types differ from other struct types in that they permit certain additional operations: Simple types can be initialized by using literals. For example,\u00a0'A'\u00a0is a literal of the type\u00a0char\u00a0and\u00a02001\u00a0is a literal of the type\u00a0int. You can declare constants of the simple types with the\u00a0const\u00a0keyword. It's not possible to have constants of other struct types. Constant expressions, whose operands are all simple type constants, are evaluated at compile time. For more information, see the\u00a0Simple types\u00a0section of the\u00a0C# language specification.\nInitializing value types\nLocal variables in C# must be initialized before they are used. For example, you might declare a local variable without initialization as in the following example:\nC#\nint myInt;\n\nYou cannot use it before you initialize it. You can initialize it using the following statement:\nC#\nmyInt = new int();  // Invoke parameterless constructor for int type.\n\nThis statement is equivalent to the following statement:\nC#\nmyInt = 0;         // Assign an initial value, 0 in this example.\n\nYou can, of course, have the declaration and the initialization in the same statement as in the following examples:\nC#\nint myInt = new int();\n\n\u2013or\u2013\nC#\nint myInt = 0;\n\nUsing the\u00a0new\u00a0operator calls the parameterless constructor of the specific type and assigns the default value to the variable. In the preceding example, the parameterless constructor assigned the value\u00a00\u00a0to\u00a0myInt. For more information about values assigned by calling parameterless constructors, see\u00a0Default values table.\nWith user-defined types, use\u00a0new\u00a0to invoke the parameterless constructor. For example, the following statement invokes the parameterless constructor of the\u00a0Point\u00a0struct:\nC#\nvar p = new Point(); // Invoke parameterless constructor for the struct.\n\nAfter this call, the struct is considered to be definitely assigned; that is, all its members are initialized to their default values.\nFor more information about the\u00a0new\u00a0operator, see\u00a0new."
    },
    {
        "title": "Reference Types Programming Guide",
        "created_at": "2025-01-21T04:54:44Z",
        "url": "reference-types-programming-guide",
        "editing_roles": "teachers",
        "page_id": 4602863,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/reference-types-programming-guide",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:44Z",
        "locked_for_user": false,
        "body": "Reference types\u00a0\nThere are two kinds of types in C#: reference types and value types. Variables of reference types store references to their data (objects), while variables of value types directly contain their data. With reference types, two variables can reference the same object; therefore, operations on one variable can affect the object referenced by the other variable. With value types, each variable has its own copy of the data, and it is not possible for operations on one variable to affect the other (except in the case of in, ref and out parameter variables; see\u00a0in,\u00a0ref\u00a0and\u00a0out\u00a0parameter modifier).\nThe following keywords are used to declare reference types: class interface delegate C# also provides the following built-in reference types: dynamic object string"
    },
    {
        "title": "4.3 String",
        "created_at": "2025-01-21T04:54:31Z",
        "url": "4-dot-3-string",
        "editing_roles": "teachers",
        "page_id": 4602764,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/4-dot-3-string",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:31Z",
        "locked_for_user": false,
        "body": "Lecture Slides: String.pdf\n\u00a0Sample Code: ILoveDatesandTimes.zip\nRecommended Online Resources:\n1. Channel 9 -\u00a0 Working with Strings\n2. Channel 9 -\u00a0 Working with Dates and Times"
    },
    {
        "title": "String  Programming Guide",
        "created_at": "2025-01-21T04:54:45Z",
        "url": "string-programming-guide",
        "editing_roles": "teachers",
        "page_id": 4602867,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/string-programming-guide",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:45Z",
        "locked_for_user": false,
        "body": "Strings\u00a0\nA string is an object of type\u00a0\u00a0whose value is text. Internally, the text is stored as a sequential read-only collection of\u00a0Char\u00a0objects. There is no null-terminating character at the end of a C# string; therefore a C# string can contain any number of embedded null characters ('\\0'). The\u00a0Length\u00a0property of a string represents the number of\u00a0Char\u00a0objects it contains, not the number of Unicode characters. To access the individual Unicode code points in a string, use the\u00a0StringInfo\u00a0object.\nstring vs. System.String\nIn C#, the\u00a0string\u00a0keyword is an alias for\u00a0String. Therefore,\u00a0String\u00a0and\u00a0string\u00a0are equivalent, and you can use whichever naming convention you prefer. The\u00a0String\u00a0class provides many methods for safely creating, manipulating, and comparing strings. In addition, the C# language overloads some operators to simplify common string operations. For more information about the keyword, see\u00a0string. For more information about the type and its methods, see\u00a0String.\nDeclaring and Initializing Strings\nYou can declare and initialize strings in various ways, as shown in the following example:\nC#\n// Declare without initializing.\nstring message1;\n\n// Initialize to null.\nstring message2 = null;\n\n// Initialize as an empty string.\n// Use the Empty constant instead of the literal \"\".\nstring message3 = System.String.Empty;\n\n// Initialize with a regular string literal.\nstring oldPath = \"c:\\\\Program Files\\\\Microsoft Visual Studio 8.0\";\n\n// Initialize with a verbatim string literal.\nstring newPath = @\"c:\\Program Files\\Microsoft Visual Studio 9.0\";\n\n// Use System.String if you prefer.\nSystem.String greeting = \"Hello World!\";\n\n// In local variables (i.e. within a method body)\n// you can use implicit typing.\nvar temp = \"I'm still a strongly-typed System.String!\";\n\n// Use a const string to prevent 'message4' from\n// being used to store another string value.\nconst string message4 = \"You can't get rid of me!\";\n\n// Use the String constructor only when creating\n// a string from a char*, char[], or sbyte*. See\n// System.String documentation for details.\nchar[] letters = { 'A', 'B', 'C' };\nstring alphabet = new string(letters);\n\nNote that you do not use the\u00a0new\u00a0operator to create a string object except when initializing the string with an array of chars.\nInitialize a string with the\u00a0Empty\u00a0constant value to create a new\u00a0String\u00a0object whose string is of zero length. The string literal representation of a zero-length string is \"\". By initializing strings with the\u00a0Empty\u00a0value instead of\u00a0null, you can reduce the chances of a\u00a0NullReferenceException\u00a0occurring. Use the static\u00a0IsNullOrEmpty(String)\u00a0method to verify the value of a string before you try to access it.\nImmutability of String Objects\nString objects are\u00a0immutable: they cannot be changed after they have been created. All of the\u00a0String\u00a0methods and C# operators that appear to modify a string actually return the results in a new string object. In the following example, when the contents of\u00a0s1\u00a0and\u00a0s2\u00a0are concatenated to form a single string, the two original strings are unmodified. The\u00a0+=\u00a0operator creates a new string that contains the combined contents. That new object is assigned to the variable\u00a0s1, and the original object that was assigned to\u00a0s1\u00a0is released for garbage collection because no other variable holds a reference to it.\nC#\nstring s1 = \"A string is more \";\nstring s2 = \"than the sum of its chars.\";\n\n// Concatenate s1 and s2. This actually creates a new\n// string object and stores it in s1, releasing the\n// reference to the original object.\ns1 += s2;\n\nSystem.Console.WriteLine(s1);\n// Output: A string is more than the sum of its chars.\n\nBecause a string \"modification\" is actually a new string creation, you must use caution when you create references to strings. If you create a reference to a string, and then \"modify\" the original string, the reference will continue to point to the original object instead of the new object that was created when the string was modified. The following code illustrates this behavior:\nC#\nstring s1 = \"Hello \";\nstring s2 = s1;\ns1 += \"World\";\n\nSystem.Console.WriteLine(s2);\n//Output: Hello\n\nFor more information about how to create new strings that are based on modifications such as search and replace operations on the original string, see\u00a0How to modify string contents.\nRegular and Verbatim String Literals\nUse regular string literals when you must embed escape characters provided by C#, as shown in the following example:\nC#\nstring columns = \"Column 1\\tColumn 2\\tColumn 3\";\n//Output: Column 1        Column 2        Column 3\n\nstring rows = \"Row 1\\r\\nRow 2\\r\\nRow 3\";\n/* Output:\n  Row 1\n  Row 2\n  Row 3\n*/\n\nstring title = \"\\\"The \\u00C6olean Harp\\\", by Samuel Taylor Coleridge\";\n//Output: \"The \u00c6olean Harp\", by Samuel Taylor Coleridge\n\nUse verbatim strings for convenience and better readability when the string text contains backslash characters, for example in file paths. Because verbatim strings preserve new line characters as part of the string text, they can be used to initialize multiline strings. Use double quotation marks to embed a quotation mark inside a verbatim string. The following example shows some common uses for verbatim strings:\nC#\nstring filePath = @\"C:\\Users\\scoleridge\\Documents\\\";\n//Output: C:\\Users\\scoleridge\\Documents\\\n\nstring text = @\"My pensive SARA ! thy soft cheek reclined\n    Thus on mine arm, most soothing sweet it is\n    To sit beside our Cot,...\";\n/* Output:\nMy pensive SARA ! thy soft cheek reclined\n   Thus on mine arm, most soothing sweet it is\n   To sit beside our Cot,... \n*/\n\nstring quote = @\"Her name was \"\"Sara.\"\"\";\n//Output: Her name was \"Sara.\"\n\nString Escape Sequences Escape sequence\nCharacter name\nUnicode encoding \\'\nSingle quote\n0x0027 \\\"\nDouble quote\n0x0022 \\\\\nBackslash\n0x005C \\0\nNull\n0x0000 \\a\nAlert\n0x0007 \\b\nBackspace\n0x0008 \\f\nForm feed\n0x000C \\n\nNew line\n0x000A \\r\nCarriage return\n0x000D \\t\nHorizontal tab\n0x0009 \\v\nVertical tab\n0x000B \\u\nUnicode escape sequence (UTF-16)\n\n\\uHHHH\u00a0(range: 0000 - FFFF; example:\u00a0\\u00E7\u00a0= \"\u00e7\") \\U\nUnicode escape sequence (UTF-32)\n\n\\U00HHHHHH\u00a0(range: 000000 - 10FFFF; example:\u00a0\\U0001F47D\u00a0= \"\ud83d\udc7d\") \\x\nUnicode escape sequence similar to \"\\u\" except with variable length\n\n\\xH[H][H][H]\u00a0(range: 0 - FFFF; example:\u00a0\\x00E7\u00a0or\u00a0\\x0E7\u00a0or\u00a0\\xE7\u00a0= \"\u00e7\") \u00a0Note At compile time, verbatim strings are converted to ordinary strings with all the same escape sequences. Therefore, if you view a verbatim string in the debugger watch window, you will see the escape characters that were added by the compiler, not the verbatim version from your source code. For example, the verbatim string\u00a0@\"C:\\files.txt\"\u00a0will appear in the watch window as \"C:\\\\files.txt\".\n\nFormat Strings\nA format string is a string whose contents are determined dynamically at runtime. Format strings are created by embedding\u00a0interpolated expressions\u00a0or placeholders inside of braces within a string. Everything inside the braces ({...}) will be resolved to a value and output as a formatted string at runtime. There are two methods to create format strings: string interpolation and composite formatting.\nString Interpolation\n\nAvailable in C# 6.0 and later,\u00a0interpolated strings\u00a0are identified by the\u00a0$\u00a0special character and include interpolated expressions in braces. If you are new to string interpolation, see the\u00a0String interpolation - C# interactive tutorial\u00a0for a quick overview.\nUse string interpolation to improve the readability and maintainability of your code. String interpolation achieves the same results as the\u00a0String.Format\u00a0method, but improves ease of use and inline clarity.\nC#\nvar jh = (firstName: \"Jupiter\", lastName: \"Hammon\", born: 1711, published: 1761);\nConsole.WriteLine($\"{jh.firstName} {jh.lastName} was an African American poet born in {jh.born}.\");\nConsole.WriteLine($\"He was first published in {jh.published} at the age of {jh.published - jh.born}.\");\nConsole.WriteLine($\"He'd be over {Math.Round((2018d - jh.born) / 100d) * 100d} years old today.\");\n\n// Output:\n// Jupiter Hammon was an African American poet born in 1711.\n// He was first published in 1761 at the age of 50.\n// He'd be over 300 years old today. \n\nComposite Formatting\n\nThe\u00a0String.Format\u00a0utilizes placeholders in braces to create a format string. This example results in similar output to the string interpolation method used above.\nC#\nvar pw = (firstName: \"Phillis\", lastName: \"Wheatley\", born: 1753, published: 1773);\nConsole.WriteLine(\"{0} {1} was an African American poet born in {2}.\", pw.firstName, pw.lastName, pw.born);\nConsole.WriteLine(\"She was first published in {0} at the age of {1}.\", pw.published, pw.published - pw.born);\nConsole.WriteLine(\"She'd be over {0} years old today.\", Math.Round((2018d - pw.born) / 100d) * 100d);\n\n// Output:\n// Phillis Wheatley was an African American poet born in 1753.\n// She was first published in 1773 at the age of 20.\n// She'd be over 300 years old today.\n\nFor more information on formatting .NET types see\u00a0Formatting Types in .NET.\nSubstrings\nA substring is any sequence of characters that is contained in a string. Use the\u00a0Substring\u00a0method to create a new string from a part of the original string. You can search for one or more occurrences of a substring by using the\u00a0IndexOf\u00a0method. Use the\u00a0Replace\u00a0method to replace all occurrences of a specified substring with a new string. Like the\u00a0Substring\u00a0method,\u00a0Replace\u00a0actually returns a new string and does not modify the original string. For more information, see\u00a0How to search strings\u00a0and\u00a0How to modify string contents.\nC#\nstring s3 = \"Visual C# Express\";\nSystem.Console.WriteLine(s3.Substring(7, 2));\n// Output: \"C#\"\n\nSystem.Console.WriteLine(s3.Replace(\"C#\", \"Basic\"));\n// Output: \"Visual Basic Express\"\n\n// Index values are zero-based\nint index = s3.IndexOf(\"C\");\n// index = 7\n\nAccessing Individual Characters\nYou can use array notation with an index value to acquire read-only access to individual characters, as in the following example:\nC#\nstring s5 = \"Printing backwards\";\n\nfor (int i = 0; i < s5.Length; i++)\n{\n    System.Console.Write(s5[s5.Length - i - 1]);\n}\n// Output: \"sdrawkcab gnitnirP\"\n\nIf the\u00a0String\u00a0methods do not provide the functionality that you must have to modify individual characters in a string, you can use a\u00a0StringBuilder\u00a0object to modify the individual chars \"in-place\", and then create a new string to store the results by using the\u00a0StringBuilder\u00a0methods. In the following example, assume that you must modify the original string in a particular way and then store the results for future use:\nC#\nstring question = \"hOW DOES mICROSOFT wORD DEAL WITH THE cAPS lOCK KEY?\";\nSystem.Text.StringBuilder sb = new System.Text.StringBuilder(question);\n\nfor (int j = 0; j < sb.Length; j++)\n{\n    if (System.Char.IsLower(sb[j]) == true)\n        sb[j] = System.Char.ToUpper(sb[j]);\n    else if (System.Char.IsUpper(sb[j]) == true)\n        sb[j] = System.Char.ToLower(sb[j]);\n}\n// Store the new string.\nstring corrected = sb.ToString();\nSystem.Console.WriteLine(corrected);\n// Output: How does Microsoft Word deal with the Caps Lock key?            \n\nNull Strings and Empty Strings\nAn empty string is an instance of a\u00a0System.String\u00a0object that contains zero characters. Empty strings are used often in various programming scenarios to represent a blank text field. You can call methods on empty strings because they are valid\u00a0System.String\u00a0objects. Empty strings are initialized as follows:\nC#\nstring s = String.Empty;  \n\nBy contrast, a null string does not refer to an instance of a\u00a0System.String\u00a0object and any attempt to call a method on a null string causes a\u00a0NullReferenceException. However, you can use null strings in concatenation and comparison operations with other strings. The following examples illustrate some cases in which a reference to a null string does and does not cause an exception to be thrown:\nC#\nstatic void Main()\n{\n    string str = \"hello\";\n    string nullStr = null;\n    string emptyStr = String.Empty;\n\n    string tempStr = str + nullStr;\n    // Output of the following line: hello\n    Console.WriteLine(tempStr);\n\n    bool b = (emptyStr == nullStr);\n    // Output of the following line: False\n    Console.WriteLine(b);\n\n    // The following line creates a new empty string.\n    string newStr = emptyStr + nullStr;\n\n    // Null strings and empty strings behave differently. The following\n    // two lines display 0.\n    Console.WriteLine(emptyStr.Length);\n    Console.WriteLine(newStr.Length);\n    // The following line raises a NullReferenceException.\n    //Console.WriteLine(nullStr.Length);\n\n    // The null character can be displayed and counted, like other chars.\n    string s1 = \"\\x0\" + \"abc\";\n    string s2 = \"abc\" + \"\\x0\";\n    // Output of the following line: * abc*\n    Console.WriteLine(\"*\" + s1 + \"*\");\n    // Output of the following line: *abc *\n    Console.WriteLine(\"*\" + s2 + \"*\");\n    // Output of the following line: 4\n    Console.WriteLine(s2.Length);\n}\n\nUsing StringBuilder for Fast String Creation\nString operations in .NET are highly optimized and in most cases do not significantly impact performance. However, in some scenarios such as tight loops that are executing many hundreds or thousands of times, string operations can affect performance. The\u00a0StringBuilder\u00a0class creates a string buffer that offers better performance if your program performs many string manipulations. The\u00a0StringBuilder\u00a0string also enables you to reassign individual characters, something the built-in string data type does not support. This code, for example, changes the content of a string without creating a new string:\nC#\nSystem.Text.StringBuilder sb = new System.Text.StringBuilder(\"Rat: the ideal pet\");\nsb[0] = 'C';\nSystem.Console.WriteLine(sb.ToString());\nSystem.Console.ReadLine();\n\n//Outputs Cat: the ideal pet\n\nIn this example, a\u00a0StringBuilder\u00a0object is used to create a string from a set of numeric types:\nC#\nusing System;\nusing System.Text;\n\nnamespace CSRefStrings\n{\n    class TestStringBuilder\n    {\n        static void Main()\n        {\n            var sb = new StringBuilder();\n\n            // Create a string composed of numbers 0 - 9\n            for (int i = 0; i < 10; i++)\n            {\n                sb.Append(i.ToString());\n            }\n            Console.WriteLine(sb);  // displays 0123456789\n\n            // Copy one character of the string (not possible with a System.String)\n            sb[0] = sb[9];\n\n            Console.WriteLine(sb);  // displays 9123456789\n            Console.WriteLine();\n        }\n    }\n}"
    },
    {
        "title": "4.4 Managing Exceptions",
        "created_at": "2025-01-21T04:54:31Z",
        "url": "4-dot-4-managing-exceptions",
        "editing_roles": "teachers",
        "page_id": 4602765,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/4-dot-4-managing-exceptions",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:31Z",
        "locked_for_user": false,
        "body": "Lecture Slides: Exceptions.pdf\n\u00a0Video Lectures:"
    },
    {
        "title": "Exceptions Programming Guide",
        "created_at": "2025-01-21T04:54:36Z",
        "url": "exceptions-programming-guide",
        "editing_roles": "teachers",
        "page_id": 4602799,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/exceptions-programming-guide",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:36Z",
        "locked_for_user": false,
        "body": "Using Exceptions\u00a0\nIn C#, errors in the program at run time are propagated through the program by using a mechanism called exceptions. Exceptions are thrown by code that encounters an error and caught by code that can correct the error. Exceptions can be thrown by the .NET Framework common language runtime (CLR) or by code in a program. Once an exception is thrown, it propagates up the call stack until a\u00a0catch\u00a0statement for the exception is found. Uncaught exceptions are handled by a generic exception handler provided by the system that displays a dialog box.\nExceptions are represented by classes derived from\u00a0Exception. This class identifies the type of exception and contains properties that have details about the exception. Throwing an exception involves creating an instance of an exception-derived class, optionally configuring properties of the exception, and then throwing the object by using the\u00a0throw\u00a0keyword. For example:\n\nC#\n\u00a0        class CustomException : Exception\n       {\n           public CustomException(string message)\n           {\n              \n           }\n\n       }\n       private static void TestThrow()\n       {\n           CustomException ex =\n               new CustomException(\"Custom exception in TestThrow()\");\n\n           throw ex;\n       }\n\nAfter an exception is thrown, the runtime checks the current statement to see whether it is within a\u00a0try\u00a0block. If it is, any\u00a0catch\u00a0blocks associated with the\u00a0try\u00a0block are checked to see whether they can catch the exception.\u00a0Catch\u00a0blocks typically specify exception types; if the type of the\u00a0catch\u00a0block is the same type as the exception, or a base class of the exception, the\u00a0catch\u00a0block can handle the method. For example:\nC#\nstatic void TestCatch()\n{\n    try\n    {\n        TestThrow();\n    }\n    catch (CustomException ex)\n    {\n        System.Console.WriteLine(ex.ToString());\n    }\n}\n\nIf the statement that throws an exception is not within a\u00a0try\u00a0block or if the\u00a0try\u00a0block that encloses it has no matching\u00a0catch\u00a0block, the runtime checks the calling method for a\u00a0try\u00a0statement and\u00a0catch\u00a0blocks. The runtime continues up the calling stack, searching for a compatible\u00a0catch\u00a0block. After the\u00a0catch\u00a0block is found and executed, control is passed to the next statement after that\u00a0catch\u00a0block.\nA\u00a0try\u00a0statement can contain more than one\u00a0catch\u00a0block. The first\u00a0catch\u00a0statement that can handle the exception is executed; any following\u00a0catch\u00a0statements, even if they are compatible, are ignored. Therefore, catch blocks should always be ordered from most specific (or most-derived) to least specific. For example:\n\nC#\n\u00a0\n\nusing System;\nusing System.IO;\n\npublic class ExceptionExample\n{\n    static void Main()\n    {\n        try\n        {\n            using (var sw = new StreamWriter(@\"C:\\test\\test.txt\"))\n            {\n                sw.WriteLine(\"Hello\");\n            }   \n        }\n        // Put the more specific exceptions first.\n        catch (DirectoryNotFoundException ex)\n        {\n            Console.WriteLine(ex);  \n        }\n        catch (FileNotFoundException ex)\n        {\n            Console.WriteLine(ex);  \n        }\n        // Put the least specific exception last.\n        catch (IOException ex)\n        {\n            Console.WriteLine(ex);  \n        }\n\n        Console.WriteLine(\"Done\"); \n    }\n}\n\nBefore the\u00a0catch\u00a0block is executed, the runtime checks for\u00a0finally\u00a0blocks.\u00a0Finally\u00a0blocks enable the programmer to clean up any ambiguous state that could be left over from an aborted\u00a0try\u00a0block, or to release any external resources (such as graphics handles, database connections or file streams) without waiting for the garbage collector in the runtime to finalize the objects. For example:\n\nC#\n\u00a0\n\nstatic void TestFinally()\n{\n    System.IO.FileStream file = null;\n    //Change the path to something that works on your machine.\n    System.IO.FileInfo fileInfo = new System.IO.FileInfo(@\"C:\\file.txt\");\n\n    try\n    {\n        file = fileInfo.OpenWrite();\n        file.WriteByte(0xF);\n    }\n    finally\n    {\n        // Closing the file allows you to reopen it immediately - otherwise IOException is thrown.\n        if (file != null)\n        {\n            file.Close();\n        }\n    }\n\n    try\n    {\n        file = fileInfo.OpenWrite();\n        System.Console.WriteLine(\"OpenWrite() succeeded\");\n    }\n    catch (System.IO.IOException)\n    {\n        System.Console.WriteLine(\"OpenWrite() failed\");\n    }\n}\n\nIf\u00a0WriteByte()\u00a0threw an exception, the code in the second\u00a0try\u00a0block that tries to reopen the file would fail if\u00a0file.Close()\u00a0is not called, and the file would remain locked. Because\u00a0finally\u00a0blocks are executed even if an exception is thrown, the\u00a0finally\u00a0block in the previous example allows for the file to be closed correctly and helps avoid an error.\nIf no compatible\u00a0catch\u00a0block is found on the call stack after an exception is thrown, one of three things occurs: If the exception is within a finalizer, the finalizer is aborted and the base finalizer, if any, is called. If the call stack contains a static constructor, or a static field initializer, a\u00a0TypeInitializationException\u00a0is thrown, with the original exception assigned to the\u00a0InnerException\u00a0property of the new exception. If the start of the thread is reached, the thread is terminated."
    },
    {
        "title": "Try-Catch-Finally Blocks Programming Guide",
        "created_at": "2025-01-21T04:54:46Z",
        "url": "try-catch-finally-blocks-programming-guide",
        "editing_roles": "teachers",
        "page_id": 4602875,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/try-catch-finally-blocks-programming-guide",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:46Z",
        "locked_for_user": false,
        "body": "Try Blocks\nA\u00a0try\u00a0block is used by C# programmers to partition code that might be affected by an exception. Associated\u00a0catch\u00a0blocks are used to handle any resulting exceptions. A\u00a0finally\u00a0block contains code that is run regardless of whether or not an exception is thrown in the\u00a0try\u00a0block, such as releasing resources that are allocated in the\u00a0try\u00a0block. A\u00a0try\u00a0block requires one or more associated\u00a0catch\u00a0blocks, or a\u00a0finally\u00a0block, or both.\nThe following examples show a\u00a0try-catch\u00a0statement, a\u00a0try-finally\u00a0statement, and a\u00a0try-catch-finally\u00a0statement.\n\nC#\n\u00a0\n\ntry\n{\n    // Code to try goes here.\n}\ncatch (SomeSpecificException ex)\n{\n    // Code to handle the exception goes here.\n    // Only catch exceptions that you know how to handle.\n    // Never catch base class System.Exception without\n    // rethrowing it at the end of the catch block.\n} C#\n\u00a0\n\ntry\n{\n    // Code to try goes here.\n}\nfinally\n{\n    // Code to execute after the try block goes here.\n} C#\n\u00a0\n\ntry\n{\n    // Code to try goes here.\n}\ncatch (SomeSpecificException ex)\n{\n    // Code to handle the exception goes here.\n}\nfinally\n{\n    // Code to execute after the try (and possibly catch) blocks \n    // goes here.\n}\n\nA\u00a0try\u00a0block without a\u00a0catch\u00a0or\u00a0finally\u00a0block causes a compiler error.\nCatch Blocks\nA\u00a0catch\u00a0block can specify the type of exception to catch. The type specification is called an\u00a0exception filter. The exception type should be derived from\u00a0Exception. In general, do not specify\u00a0Exception\u00a0as the exception filter unless either you know how to handle all exceptions that might be thrown in the\u00a0try\u00a0block, or you have included a\u00a0throw\u00a0statement at the end of your\u00a0catch\u00a0block.\nMultiple\u00a0catch\u00a0blocks with different exception filters can be chained together. The\u00a0catch\u00a0blocks are evaluated from top to bottom in your code, but only one\u00a0catch\u00a0block is executed for each exception that is thrown. The first\u00a0catch\u00a0block that specifies the exact type or a base class of the thrown exception is executed. If no\u00a0catch\u00a0block specifies a matching exception filter, a\u00a0catch\u00a0block that does not have a filter is selected, if one is present in the statement. It is important to position\u00a0catch\u00a0blocks with the most specific (that is, the most derived) exception types first.\nYou should catch exceptions when the following conditions are true: You have a good understanding of why the exception might be thrown, and you can implement a specific recovery, such as prompting the user to enter a new file name when you catch a\u00a0FileNotFoundException\u00a0object. You can create and throw a new, more specific exception.\n\nC#\n\u00a0\n\nint GetInt(int[] array, int index)\n{\n    try\n    {\n        return array[index];\n    }\n    catch(System.IndexOutOfRangeException e)\n    {\n        throw new System.ArgumentOutOfRangeException(\n            \"Parameter index is out of range.\", e);\n    }\n} You want to partially handle an exception before passing it on for additional handling. In the following example, a\u00a0catch\u00a0block is used to add an entry to an error log before re-throwing the exception.\n\nC#\n\u00a0\n\ntry\n{\n    // Try to access a resource.\n}\ncatch (System.UnauthorizedAccessException e)\n{\n    // Call a custom error logging procedure.\n    LogError(e);\n    // Re-throw the error.\n    throw;     \n} Finally Blocks\nA\u00a0finally\u00a0block enables you to clean up actions that are performed in a\u00a0try\u00a0block. If present, the\u00a0finally\u00a0block executes last, after the\u00a0try\u00a0block and any matched\u00a0catch\u00a0block. A\u00a0finally\u00a0block always runs, regardless of whether an exception is thrown or a\u00a0catch\u00a0block matching the exception type is found.\nThe\u00a0finally\u00a0block can be used to release resources such as file streams, database connections, and graphics handles without waiting for the garbage collector in the runtime to finalize the objects. See\u00a0using Statement\u00a0for more information.\nIn the following example, the\u00a0finally\u00a0block is used to close a file that is opened in the\u00a0try\u00a0block. Notice that the state of the file handle is checked before the file is closed. If the\u00a0try\u00a0block cannot open the file, the file handle still has the value\u00a0null\u00a0and the\u00a0finally\u00a0block does not try to close it. Alternatively, if the file is opened successfully in the\u00a0try\u00a0block, the\u00a0finally\u00a0block closes the open file.\n\nC#\n\u00a0\n\nSystem.IO.FileStream file = null;\nSystem.IO.FileInfo fileinfo = new System.IO.FileInfo(\"C:\\\\file.txt\");\ntry\n{\n    file = fileinfo.OpenWrite();\n    file.WriteByte(0xF);\n}\nfinally\n{\n    // Check for null because OpenWrite might have failed.\n    if (file != null)\n    {\n        file.Close();\n    }\n}"
    },
    {
        "title": "M3 Roadmap & Objectives",
        "created_at": "2025-01-21T04:54:41Z",
        "url": "m3-roadmap-and-objectives",
        "editing_roles": "teachers",
        "page_id": 4602838,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/m3-roadmap-and-objectives",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:41Z",
        "locked_for_user": false,
        "body": "Our readings, materials, and discussion this week are aimed at helping us get started with Object Oriented Programming concept - Class & Object.\n\n\u00a0Objectives\n\nAfter completing this week's work, you will be able to:\n\nDefine a class containing a related set of methods and data items.\nControl the accessibility of members by using the public and private keywords.\nCreate objects by using the new keyword to invoke a constructor.\nWrite and call your own constructors.\nCreate methods and data that can be shared by all instances of the same class by using the static keyword.\n\n\u00a0\n\n\u00a0M3 Activities\u00a0 Watch Video Lectures\nRead Lecture Slides & Programming Guide,\nPractice with Sample Code\nComplete M3 Quiz and Assignment"
    },
    {
        "title": "3.1 Classes and Objects Overview",
        "created_at": "2025-01-21T04:54:30Z",
        "url": "3-dot-1-classes-and-objects-overview",
        "editing_roles": "teachers",
        "page_id": 4602758,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/3-dot-1-classes-and-objects-overview",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:30Z",
        "locked_for_user": false,
        "body": "Lecture Slides: Classes.pdf\nRecommended Online Resources:\n1. Microsoft Learn - \u00a0Understanding Classes\n2. Microsoft Learn -\u00a0 More About Classes and Methods\n3. Microsoft Learn - Tutorial: Explore object oriented programming with classes and objects\u00a0 with video: Object Oriented Programming: Objects and Classes"
    },
    {
        "title": "Class Programming Guide",
        "created_at": "2025-01-21T04:54:34Z",
        "url": "class-programming-guide",
        "editing_roles": "teachers",
        "page_id": 4602789,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/class-programming-guide",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:34Z",
        "locked_for_user": false,
        "body": "Classes\nClasses\u00a0 is essentially a data structure that encapsulates a set of data and behaviors that belong together as a logical unit. The data and behaviors are the members of the class , and they include its methods, properties, and events, and so on.\nA class declaration is like a blueprint that is used to create instances or objects at run time. If you define a class called Person,\u00a0Person\u00a0is the name of the type. If you declare and initialize a variable\u00a0p\u00a0of type\u00a0Person,\u00a0p\u00a0is said to be an object or instance of\u00a0Person. Multiple instances of the same\u00a0Person\u00a0type can be created, and each instance can have different values in its properties and fields.\nA class is a reference type. When an object of the class is created, the variable to which the object is assigned holds only a reference to that memory. When the object reference is assigned to a new variable, the new variable refers to the original object. Changes made through one variable are reflected in the other variable because they both refer to the same data.\nIn general, classes are used to model more complex behavior, or data that is intended to be modified after a class object is created.\u00a0\nExample\nIn the following example,\u00a0CustomClass\u00a0in the\u00a0ProgrammingGuide\u00a0namespace has three members: an instance constructor, a property named\u00a0Number, and a method named\u00a0Multiply. The\u00a0Main\u00a0method in the\u00a0Program\u00a0class creates an instance (object) of\u00a0CustomClass, and the object\u2019s method and property are accessed by using dot notation.\nC#\nusing System;\n\nnamespace ProgrammingGuide\n{\n   // Class definition.\n   public class CustomClass\n   {\n      // Class members.\n      //\n      // Property.\n      public int Number { get; set; }\n\n      // Method.\n      public int Multiply(int num)\n      {\n          return num * Number;\n      }\n\n      // Instance Constructor.\n      public CustomClass()\n      {\n          Number = 0;\n      }\n   }\n\n   // Another class definition that contains Main, the program entry point.\n   class Program\n   {\n      static void Main(string[] args)\n      {\n         // Create an object of type CustomClass.\n         CustomClass custClass = new CustomClass();\n\n         // Set the value of the public property.\n         custClass.Number = 27;\n\n         // Call the public method.\n         int result = custClass.Multiply(4);\n         Console.WriteLine($\"The result is {result}.\");\n      }\n   }\n}\n// The example displays the following output:\n//      The result is 108. \n\n\u00a0\nEncapsulation is sometimes referred to as the first pillar or principle of object-oriented programming. According to the principle of encapsulation, a class\u00a0 can specify how accessible each of its members is to code outside of the class. Methods and variables that are not intended to be used from outside of the class or assembly can be hidden to limit the potential for coding errors or malicious exploits.\nFor more information about classes, see\u00a0Classes\u00a0and\u00a0Objects.\nMembers\nAll methods, fields, constants, properties, and events must be declared within a type; these are called the\u00a0members\u00a0of the type. In C#, there are no global variables or methods as there are in some other languages. Even a program's entry point, the\u00a0Main method, must be declared within a class. The following list includes all the various kinds of members that may be declared in a class . Fields Constants Properties Methods Constructors Events Finalizers Indexers Operators Nested Types"
    },
    {
        "title": "3.2 Constructors",
        "created_at": "2025-01-21T04:54:30Z",
        "url": "3-dot-2-constructors",
        "editing_roles": "teachers",
        "page_id": 4602759,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/3-dot-2-constructors",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:30Z",
        "locked_for_user": false,
        "body": "Sample Code: Management - Starting Point.zip\n\u00a0Video Lectures:\u00a0\n\nRecommended Online Resources:\n\u00a01. Microsoft Doc: Constructors"
    },
    {
        "title": "3.3 Fields and Properties",
        "created_at": "2025-01-21T04:54:30Z",
        "url": "3-dot-3-fields-and-properties",
        "editing_roles": "teachers",
        "page_id": 4602760,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/3-dot-3-fields-and-properties",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:30Z",
        "locked_for_user": false,
        "body": "Sample Code: Management - Starting Point.zip\n\u00a0Video Lectures:\u00a0\n\nRecommended Online Resources:\n\u00a01. Microsoft Doc: Fields\n2.\u00a0 Microsoft Doc: Properties"
    },
    {
        "title": "3.4 Instance and Static Methods",
        "created_at": "2025-01-21T04:54:31Z",
        "url": "3-dot-4-instance-and-static-methods",
        "editing_roles": "teachers",
        "page_id": 4602761,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/3-dot-4-instance-and-static-methods",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:31Z",
        "locked_for_user": false,
        "body": "Sample Code: Management - Starting Point.zip\n\u00a0Video Lectures:\u00a0\n\nRecommended Online Resources:\n\u00a01. Microsoft Doc: Methods\n\u00a02. Microsoft Doc: Static Classes and Static Class Members"
    },
    {
        "title": " M2 Roadmap & Objectives",
        "created_at": "2025-01-21T04:54:41Z",
        "url": "m2-roadmap-and-objectives",
        "editing_roles": "teachers",
        "page_id": 4602835,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/m2-roadmap-and-objectives",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:41Z",
        "locked_for_user": false,
        "body": "Our readings, materials, and discussion this week are aimed at helping us\u00a0learn the C# programming basics.\n\n\u00a0Objectives\n\nAfter completing this week's work, you will be able to:\n\nDefine the concepts of loops.\u00a0\nWrite for, foreach, while, and\u00a0do iteration statements\nRecognize\u00a0 declare and call methods.\nPass information and return information from a method\nExplain the functionality provided in the different collection classes (array, list) available with the\u00a0\u00a0.NET Framework.\nCreate type-safe collections, and populate a collection with data.\nManipulate and access the data items held in a collection.\nApply loops, methods, array and list operations in programming.\n\n\u00a0\n\n\u00a0M2 Activities\u00a0 Watch video lectures\nRead programming guide\nWork on assessment and read rubric"
    },
    {
        "title": "2.1 Loop",
        "created_at": "2025-01-21T04:54:30Z",
        "url": "2-dot-1-loop",
        "editing_roles": "teachers",
        "page_id": 4602753,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/2-dot-1-loop",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:30Z",
        "locked_for_user": false,
        "body": "Lecture Slides: \u00a0Loops.pdf\n\u00a0Recommended Online Resources:\n1. Channel 9 -  for Iteration Statement\n2. Channel 9 -  While Iteration Statement"
    },
    {
        "title": "for Loop Programming Guide",
        "created_at": "2025-01-21T04:54:37Z",
        "url": "for-loop-programming-guide",
        "editing_roles": "teachers",
        "page_id": 4602803,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/for-loop-programming-guide",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:37Z",
        "locked_for_user": false,
        "body": "For loop:\nThe\u00a0for\u00a0statement executes a statement or a block of statements while a specified Boolean expression evaluates to\u00a0true.\nAt any point within the\u00a0for\u00a0statement block, you can break out of the loop by using the\u00a0break\u00a0statement, or step to the next iteration in the loop by using the\u00a0continue\u00a0statement. You also can exit a\u00a0for\u00a0loop by the\u00a0goto,\u00a0return, or\u00a0throw\u00a0statements.\nStructure of the\u00a0for\u00a0statement\n\nThe\u00a0for\u00a0statement defines\u00a0initializer,\u00a0condition, and\u00a0iterator\u00a0sections:\nC#\nfor (initializer; condition; iterator)\n    body\n\nAll three sections are optional. The body of the loop is either a statement or a block of statements.\nThe following example shows the\u00a0for\u00a0statement with all of the sections defined:\nC#\nfor (int i = 0; i < 5; i++)\n{\n    Console.WriteLine(i);\n}\n\nThe\u00a0initializer\u00a0section\nThe statements in the\u00a0initializer\u00a0section are executed only once, before entering the loop. The\u00a0initializer\u00a0section is either of the following: The declaration and initialization of a local loop variable, which can't be accessed from outside the loop. Zero or more statement expressions from the following list, separated by commas: assignment\u00a0statement invocation of a method prefix or postfix\u00a0increment\u00a0expression, such as\u00a0++i\u00a0or\u00a0i++ prefix or postfix\u00a0decrement\u00a0expression, such as\u00a0--i\u00a0or\u00a0i-- creation of an object by using the\u00a0new\u00a0operator await\u00a0expression The\u00a0initializer\u00a0section in the example above declares and initializes the local loop variable\u00a0i:\nC#\nint i = 0\n\nThe\u00a0condition\u00a0section\nThe\u00a0condition\u00a0section, if present, must be a boolean expression. That expression is evaluated before every loop iteration. If the\u00a0condition\u00a0section is not present or the boolean expression evaluates to\u00a0true, the next loop iteration is executed; otherwise, the loop is exited.\nThe\u00a0condition\u00a0section in the example above determines if the loop terminates based on the value of the local loop variable:\nC#\ni < 5\n\nThe\u00a0iterator\u00a0section\nThe\u00a0iterator\u00a0section defines what happens after each iteration of the body of the loop. The\u00a0iterator\u00a0section contains zero or more of the following statement expressions, separated by commas: assignment\u00a0statement invocation of a method prefix or postfix\u00a0increment\u00a0expression, such as\u00a0++i\u00a0or\u00a0i++ prefix or postfix\u00a0decrement\u00a0expression, such as\u00a0--i\u00a0or\u00a0i-- creation of an object by using the\u00a0new\u00a0operator await\u00a0expression The\u00a0iterator\u00a0section in the example above increments the local loop variable:\nC#\ni++"
    },
    {
        "title": "foreach Loop Programming Guide",
        "created_at": "2025-01-21T04:54:37Z",
        "url": "foreach-loop-programming-guide",
        "editing_roles": "teachers",
        "page_id": 4602804,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/foreach-loop-programming-guide",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:37Z",
        "locked_for_user": false,
        "body": "foreach\nThe\u00a0foreach\u00a0statement executes a statement or a block of statements for each element in an instance of the type that implements the\u00a0System.Collections.IEnumerable\u00a0or\u00a0System.Collections.Generic.IEnumerable<T>\u00a0interface. The\u00a0foreach\u00a0statement is not limited to those types and can be applied to an instance of any type that satisfies the following conditions:\n\nhas the public parameterless\u00a0GetEnumerator\u00a0method whose return type is either class, struct, or interface type,\nthe return type of the\u00a0GetEnumerator\u00a0method has the public\u00a0Current\u00a0property and the public parameterless\u00a0MoveNext\u00a0method whose return type is\u00a0Boolean.\n\nBeginning with C# 7.3, if the enumerator's\u00a0Current\u00a0property returns a\u00a0reference return value\u00a0(ref T\u00a0where\u00a0T\u00a0is the type of the collection element), you can declare the iteration variable with the\u00a0ref\u00a0or\u00a0ref readonly\u00a0modifier.\nAt any point within the\u00a0foreach\u00a0statement block, you can break out of the loop by using the\u00a0break\u00a0statement, or step to the next iteration in the loop by using the\u00a0continue\u00a0statement. You also can exit a\u00a0foreach\u00a0loop by the\u00a0goto,\u00a0return, or\u00a0throw\u00a0statements.\nIf the\u00a0foreach\u00a0statement is applied to\u00a0null, a\u00a0NullReferenceException\u00a0is thrown. If the source collection of the\u00a0foreach\u00a0statement is empty, the body of the\u00a0foreach\u00a0loop is not executed and skipped.\nExamples\nThe following example shows usage of the\u00a0foreach\u00a0statement with an instance of the\u00a0List<T>\u00a0type that implements the\u00a0IEnumerable<T>\u00a0interface:\nC#\nvar fibNumbers = new List<int> { 0, 1, 1, 2, 3, 5, 8, 13 };\nint count = 0;\nforeach (int element in fibNumbers)\n{\n    count++;\n    Console.WriteLine($\"Element #{count}: {element}\");\n}\nConsole.WriteLine($\"Number of elements: {count}\");// Output:\n//Element #1: 0//Element #2: 1//Element #3: 1//Element #4: 2//Element #5: 3//Element #6: 5//Element #7: 8//Element #8: 13//Number of elements: 8"
    },
    {
        "title": "while Loop Programming Guide",
        "created_at": "2025-01-21T04:54:46Z",
        "url": "while-loop-programming-guide",
        "editing_roles": "teachers",
        "page_id": 4602881,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/while-loop-programming-guide",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:46Z",
        "locked_for_user": false,
        "body": "while\u00a0\nThe\u00a0while\u00a0statement executes a statement or a block of statements while a specified Boolean expression evaluates to\u00a0true. Because that expression is evaluated before each execution of the loop, a\u00a0while\u00a0loop executes zero or more times. This differs from the\u00a0do\u00a0loop, which executes one or more times.\nAt any point within the\u00a0while\u00a0statement block, you can break out of the loop by using the\u00a0break\u00a0statement.\nYou can step directly to the evaluation of the\u00a0while\u00a0expression by using the\u00a0continue\u00a0statement. If the expression evaluates to\u00a0true, execution continues at the first statement in the loop. Otherwise, execution continues at the first statement after the loop.\nYou also can exit a\u00a0while\u00a0loop by the\u00a0goto,\u00a0return, or\u00a0throw\u00a0statements.\nExample\nThe following example shows the usage of the\u00a0while\u00a0statement. Select\u00a0Run\u00a0to run the example code. After that you can modify the code and run it again.\nC#\nint n = 0;\nwhile (n < 5)\n{\n    Console.WriteLine(n);\n    n++;\n}"
    },
    {
        "title": "do-while Loop Programming Guide",
        "created_at": "2025-01-21T04:54:35Z",
        "url": "do-while-loop-programming-guide",
        "editing_roles": "teachers",
        "page_id": 4602795,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/do-while-loop-programming-guide",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:35Z",
        "locked_for_user": false,
        "body": "do-while\nThe\u00a0do\u00a0statement executes a statement or a block of statements while a specified Boolean expression evaluates to\u00a0true. Because that expression is evaluated after each execution of the loop, a\u00a0do-while\u00a0loop executes one or more times. This differs from the\u00a0while\u00a0loop, which executes zero or more times.\nAt any point within the\u00a0do\u00a0statement block, you can break out of the loop by using the\u00a0break\u00a0statement.\nYou can step directly to the evaluation of the\u00a0while\u00a0expression by using the\u00a0continue\u00a0statement. If the expression evaluates to\u00a0true, execution continues at the first statement in the loop. Otherwise, execution continues at the first statement after the loop.\nYou also can exit a\u00a0do-while\u00a0loop by the\u00a0goto,\u00a0return, or\u00a0throw\u00a0statements.\nExample\nThe following example shows the usage of the\u00a0do statement.\nC#\nint n = 0;\ndo \n{\n    Console.WriteLine(n);\n    n++;\n} while (n < 5);"
    },
    {
        "title": "2.2 Methods",
        "created_at": "2025-01-21T04:54:30Z",
        "url": "2-dot-2-methods",
        "editing_roles": "teachers",
        "page_id": 4602754,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/2-dot-2-methods",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:30Z",
        "locked_for_user": false,
        "body": "Lecture Slides: \u00a0Method.pdf\n\u00a0Sample Code: Overload1.zip\u00a0\n\u00a0Video Lectures:\u00a0\n\n\u00a0Recommended Online Resources:\n1. Channel 9 -  Defining and Calling Methods"
    },
    {
        "title": "Methods Programming Guide",
        "created_at": "2025-01-21T04:54:43Z",
        "url": "methods-programming-guide",
        "editing_roles": "teachers",
        "page_id": 4602853,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/methods-programming-guide",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:43Z",
        "locked_for_user": false,
        "body": "Methods\u00a0\nA method is a code block that contains a series of statements. A program causes the statements to be executed by calling the method and specifying any required method arguments. In C#, every executed instruction is performed in the context of a method. The\u00a0Main method is the entry point for every C# application and it's called by the common language runtime (CLR) when the program is started. There are named methods, and anonymous methods. We discuss named methods here. Anonymous methods will be covered in later modules.\nMethods are declared in a\u00a0class\u00a0or\u00a0struct\u00a0by specifying:\n\nAn optional access level, such as\u00a0public\u00a0or\u00a0private. The default is\u00a0private.\nOptional modifiers such as\u00a0abstract\u00a0or\u00a0sealed.\nThe return value, or\u00a0void\u00a0if the method has none.\nThe method name.\nAny method parameters. Method parameters are enclosed in parentheses and are separated by commas. Empty parentheses indicate that the method requires no parameters.\n\nThese parts together form the method signature.\n\n\u00a0Note\nA return type of a method is not part of the signature of the method for the purposes of method overloading. However, it is part of the signature of the method when determining the compatibility between a delegate and the method that it points to.\n\nThe following example defines a class named\u00a0Motorcycle\u00a0that contains five methods:\nC#\nusing System;\n\nabstract class Motorcycle\n{\n   // Anyone can call this.\n   public void StartEngine() {/* Method statements here */ }\n\n   // Only derived classes can call this.\n   protected void AddGas(int gallons) { /* Method statements here */ }\n\n   // Derived classes can override the base class implementation.\n   public virtual int Drive(int miles, int speed) { /* Method statements here */ return 1; }\n\n   // Derived classes can override the base class implementation.\n   public virtual int Drive(TimeSpan time, int speed) { /* Method statements here */ return 0; }\n\n   // Derived classes must implement this.\n   public abstract double GetTopSpeed(); \n}\n\nNote that the\u00a0Motorcycle\u00a0class includes an overloaded method,\u00a0Drive. Two methods have the same name, but must be differentiated by their parameter types.\n\nMethod invocation\nMethods can be either\u00a0instance\u00a0or\u00a0static. Invoking an instance method requires that you instantiate an object and call the method on that object; an instance method operates on that instance and its data. You invoke a static method by referencing the name of the type to which the method belongs; static methods do not operate on instance data. Attempting to call a static method through an object instance generates a compiler error.\nCalling a method is like accessing a field. After the object name (if you are calling an instance method) or the type name (if you are calling a\u00a0static\u00a0method), add a period, the name of the method, and parentheses. Arguments are listed within the parentheses, and are separated by commas.\nThe method definition specifies the names and types of any parameters that are required. When a caller invokes the method, it provides concrete values, called arguments, for each parameter. The arguments must be compatible with the parameter type, but the argument name, if one is used in the calling code, does not have to be the same as the parameter named defined in the method. In the following example, the\u00a0Square\u00a0method includes a single parameter of type\u00a0int\u00a0named\u00a0i. The first method call passes the\u00a0Square\u00a0method a variable of type\u00a0int\u00a0named\u00a0num; the second, a numeric constant; and the third, an expression.\n\nC#\npublic class Example\n{\n   public static void Main()\n   {\n      // Call with an int variable.\n      int num = 4;\n      int productA = Square(num);\n\n      // Call with an integer literal.\n      int productB = Square(12);\n\n      // Call with an expression that evaluates to int.\n      int productC = Square(productA * 3);\n   }\n   \n   static int Square(int i)\n   {\n      // Store input argument in a local variable.\n      int input = i;\n      return input * input;\n   }\n}\n\nThe most common form of method invocation used positional arguments; it supplies arguments in the same order as method parameters. The methods of the Motorcycle\u00a0class can therefore be called as in the following example. The call to the\u00a0Drive\u00a0method, for example, includes two arguments that correspond to the two parameters in the method's syntax. The first becomes the value of the\u00a0miles\u00a0parameter, the second the value of the\u00a0speed\u00a0parameter.\n\nC#\nclass TestMotorcycle : Motorcycle\n{\n   public override double GetTopSpeed()\n   {\n      return 108.4;\n   }\n\n   static void Main()\n   {\n      \n      TestMotorcycle moto = new TestMotorcycle();\n\n      moto.StartEngine();\n      moto.AddGas(15);\n      moto.Drive(5, 20);\n      double speed = moto.GetTopSpeed();\n      Console.WriteLine(\"My top speed is {0}\", speed);            \n   }\n}\n\nYou can also used\u00a0named arguments\u00a0instead of positional arguments when invoking a method. When using named arguments, you specify the parameter name followed by a colon (\":\") and the argument. Arguments to the method can appear in any order, as long as all required arguments are present. The following example uses named arguments to invoke the\u00a0TestMotorcycle.Drive\u00a0method. In this example, the named arguments are passed in the opposite order from the method's parameter list.\nC#\nusing System;\n\nclass TestMotorcycle : Motorcycle\n{\n   public override int Drive(int miles, int speed)\n   {\n      return (int) Math.Round( ((double)miles) / speed, 0);\n   }\n\n   public override double GetTopSpeed()\n   {\n      return 108.4;\n   }\n\n   static void Main()\n   {\n      \n      TestMotorcycle moto = new TestMotorcycle();\n      moto.StartEngine();\n      moto.AddGas(15);\n      var travelTime = moto.Drive(speed: 60, miles: 170);\n      Console.WriteLine(\"Travel time: approx. {0} hours\", travelTime);            \n   }\n}\n// The example displays the following output:\n//      Travel time: approx. 3 hours\n\nYou can invoke a method using both positional arguments and named arguments. However, a positional argument cannot follow a named argument. The following example invokes the\u00a0TestMotorcycle.Drive\u00a0method from the previous example using one positional argument and one named argument.\nC#\nvar travelTime = moto.Drive(170, speed: 55);"
    },
    {
        "title": "2.3 Array & List",
        "created_at": "2025-01-21T04:54:30Z",
        "url": "2-dot-3-array-and-list",
        "editing_roles": "teachers",
        "page_id": 4602755,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/2-dot-3-array-and-list",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:30Z",
        "locked_for_user": false,
        "body": "Lecture Slides: \u00a0ArrayList.pdf\n\u00a0Recommended Online Resources:\n1. Channel 9 -\u00a0 Understanding Arrays\n2. Channel 9 -    Working with Collections\u00a0(this video touches topics related to Classes/Objects that we will cover later. Focus on how list works)"
    },
    {
        "title": "Array Programming Guide",
        "created_at": "2025-01-21T04:54:33Z",
        "url": "array-programming-guide",
        "editing_roles": "teachers",
        "page_id": 4602784,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/array-programming-guide",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:33Z",
        "locked_for_user": false,
        "body": "Arrays\u00a0\nYou can store multiple variables of the same type in an array data structure. You declare an array by specifying the type of its elements. If you want the array to store elements of any type, you can specify\u00a0object\u00a0as its type. In the unified type system of C#, all types, predefined and user-defined, reference types and value types, inherit directly or indirectly from\u00a0Object.\nC#\ntype[] arrayName;\n\nExample\nThe following example creates single-dimensional, multidimensional, and jagged arrays:\nC#\nclass TestArraysClass\n{\n    static void Main()\n    {\n        // Declare a single-dimensional array. \n        int[] array1 = new int[5];\n\n        // Declare and set array element values.\n        int[] array2 = new int[] { 1, 3, 5, 7, 9 };\n\n        // Alternative syntax.\n        int[] array3 = { 1, 2, 3, 4, 5, 6 };\n\n        // Declare a two dimensional array.\n        int[,] multiDimensionalArray1 = new int[2, 3];\n\n        // Declare and set array element values.\n        int[,] multiDimensionalArray2 = { { 1, 2, 3 }, { 4, 5, 6 } };\n\n        // Declare a jagged array.\n        int[][] jaggedArray = new int[6][];\n\n        // Set the values of the first array in the jagged array structure.\n        jaggedArray[0] = new int[4] { 1, 2, 3, 4 };\n    }\n}\n\nArray overview\nAn array has the following properties:\n\nAn array can be\u00a0Single-Dimensional,\u00a0Multidimensional\u00a0or\u00a0Jagged.\nThe number of dimensions and the length of each dimension are established when the array instance is created. These values can't be changed during the lifetime of the instance.\nThe default values of numeric array elements are set to zero, and reference elements are set to null.\nA jagged array is an array of arrays, and therefore its elements are reference types and are initialized to\u00a0null.\nArrays are zero indexed: an array with\u00a0n\u00a0elements is indexed from\u00a00\u00a0to\u00a0n-1.\nArray elements can be of any type, including an array type.\nArray types are\u00a0reference types\u00a0derived from the abstract base type\u00a0Array. Since this type implements\u00a0IEnumerable\u00a0and\u00a0IEnumerable<T>, you can use\u00a0foreach\u00a0iteration on all arrays in C#."
    },
    {
        "title": "Lists and Collections",
        "created_at": "2025-01-21T04:54:39Z",
        "url": "lists-and-collections",
        "editing_roles": "teachers",
        "page_id": 4602821,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/lists-and-collections",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:39Z",
        "locked_for_user": false,
        "body": "Lists and Collections\u00a0\nFor many applications, you want to create and manage groups of related objects. There are two ways to group objects: by creating arrays of objects, and by creating collections of objects.\nArrays are most useful for creating and working with a fixed number of strongly-typed objects.\u00a0\nCollections provide a more flexible way to work with groups of objects. Unlike arrays, the group of objects you work with can grow and shrink dynamically as the needs of the application change. For some collections, you can assign a key to any object that you put into the collection so that you can quickly retrieve the object by using the key.\nA collection is a class, so you must declare an instance of the class before you can add elements to that collection.\nIf your collection contains elements of only one data type, you can use one of the classes in the\u00a0System.Collections.Generic namespace. A generic collection enforces type safety so that no other data type can be added to it. When you retrieve an element from a generic collection, you do not have to determine its data type or convert it.\n\u00a0\nUsing a Simple Collection\nThe examples in this section use the generic\u00a0List<T>\u00a0class, which enables you to work with a strongly typed list of objects.\nThe following example creates a list of strings and then iterates through the strings by using a\u00a0foreach\u00a0statement.\nC#\n// Create a list of strings.\nvar salmons = new List<string>();\nsalmons.Add(\"chinook\");\nsalmons.Add(\"coho\");\nsalmons.Add(\"pink\");\nsalmons.Add(\"sockeye\");\n\n// Iterate through the list.\nforeach (var salmon in salmons)\n{\n    Console.Write(salmon + \" \");\n}\n// Output: chinook coho pink sockeye\n\nIf the contents of a collection are known in advance, you can use a\u00a0collection initializer\u00a0to initialize the collection. For more information, see\u00a0Object and Collection Initializers.\nThe following example is the same as the previous example, except a collection initializer is used to add elements to the collection.\nC#\n// Create a list of strings by using a\n// collection initializer.\nvar salmons = new List<string> { \"chinook\", \"coho\", \"pink\", \"sockeye\" };\n\n// Iterate through the list.\nforeach (var salmon in salmons)\n{\n    Console.Write(salmon + \" \");\n}\n// Output: chinook coho pink sockeye\n\nYou can use a\u00a0for\u00a0statement instead of a\u00a0foreach\u00a0statement to iterate through a collection. You accomplish this by accessing the collection elements by the index position. The index of the elements starts at 0 and ends at the element count minus 1.\nThe following example iterates through the elements of a collection by using\u00a0for\u00a0instead of\u00a0foreach.\nC#\n// Create a list of strings by using a\n// collection initializer.\nvar salmons = new List<string> { \"chinook\", \"coho\", \"pink\", \"sockeye\" };\n\nfor (var index = 0; index < salmons.Count; index++)\n{\n    Console.Write(salmons[index] + \" \");\n}\n// Output: chinook coho pink sockeye\n\nThe following example removes an element from the collection by specifying the object to remove.\nC#\n// Create a list of strings by using a\n// collection initializer.\nvar salmons = new List<string> { \"chinook\", \"coho\", \"pink\", \"sockeye\" };\n\n// Remove an element from the list by specifying\n// the object.\nsalmons.Remove(\"coho\");\n\n// Iterate through the list.\nforeach (var salmon in salmons)\n{\n    Console.Write(salmon + \" \");\n}\n// Output: chinook pink sockeye\n\nThe following example removes elements from a generic list. Instead of a\u00a0foreach\u00a0statement, a\u00a0for\u00a0statement that iterates in descending order is used. This is because the\u00a0RemoveAt\u00a0method causes elements after a removed element to have a lower index value.\nC#\nvar numbers = new List<int> { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n\n// Remove odd numbers.\nfor (var index = numbers.Count - 1; index >= 0; index--)\n{\n    if (numbers[index] % 2 == 1)\n    {\n        // Remove the element by specifying\n        // the zero-based index in the list.\n        numbers.RemoveAt(index);\n    }\n}\n\n// Iterate through the list.\n// A lambda expression is placed in the ForEach method\n// of the List(T) object.\nnumbers.ForEach(\n    number => Console.Write(number + \" \"));\n// Output: 0 2 4 6 8\n\nFor the type of elements in the\u00a0List<T>, you can also define your own class. In the following example, the\u00a0Galaxy\u00a0class that is used by the\u00a0List<T>\u00a0is defined in the code.\nC#\nprivate static void IterateThroughList()\n{\n    var theGalaxies = new List<Galaxy>\n        {\n            new Galaxy() { Name=\"Tadpole\", MegaLightYears=400},\n            new Galaxy() { Name=\"Pinwheel\", MegaLightYears=25},\n            new Galaxy() { Name=\"Milky Way\", MegaLightYears=0},\n            new Galaxy() { Name=\"Andromeda\", MegaLightYears=3}\n        };\n\n    foreach (Galaxy theGalaxy in theGalaxies)\n    {\n        Console.WriteLine(theGalaxy.Name + \"  \" + theGalaxy.MegaLightYears);\n    }\n\n    // Output:\n    //  Tadpole  400\n    //  Pinwheel  25\n    //  Milky Way  0\n    //  Andromeda  3\n}\n\npublic class Galaxy\n{\n    public string Name { get; set; }\n    public int MegaLightYears { get; set; }\n}"
    },
    {
        "title": "2.4 Top Level Program - new to C# 9.0",
        "created_at": "2025-01-21T04:54:30Z",
        "url": "2-dot-4-top-level-program-new-to-c-number-9-dot-0",
        "editing_roles": "teachers",
        "page_id": 4602756,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/2-dot-4-top-level-program-new-to-c-number-9-dot-0",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:30Z",
        "locked_for_user": false,
        "body": "Before C# 9,\u00a0 there was a lot of code just to output Hello, World! In C# 9 there is a simpler way and it is known as top-level programs. Let's compare the traditional minimum console app, as shown in the following code: \nusing System;\nclass Program\n{ static void Main(string[] args)\n      { \n           Console.WriteLine(\"Hello World!\"); \n      }\n}\n\nTo the new top-level program minimum console app, as shown in the following code: \nusing System;\nConsole.WriteLine(\"Hello World!\");\nThat is a lot simpler, right? If you had to start with a blank file and write all the statements yourself, this is better. During compilation, all the boilerplate code to define the Program class and its Main method is generated and wrapped around the statements you write. Any using statements still have to go at the top of the file. There can be only one file like this in a project. Personally, especially when teaching and learning C#, I plan to continue to use the traditional project template since it is true to reality.\u00a0 For example, arguments can be passed into a console app. With a top-level program, you would need to know that the args parameter exists even though you cannot see it.\u00a0\nFor more info, see https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-9.0/top-level-statements\nRead .NET 6 Template Changes: C# console app template generates top-level statements\nTutorial: Explore ideas using top-level statements to build code as you learn"
    },
    {
        "title": "2.5 Introduction to .NET",
        "created_at": "2025-01-21T04:54:30Z",
        "url": "2-dot-5-introduction-to-net",
        "editing_roles": "teachers",
        "page_id": 4602757,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/2-dot-5-introduction-to-net",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:30Z",
        "locked_for_user": false,
        "body": ".NET is a free, cross-platform,\u00a0open-source developer platform\u00a0for building\u00a0many kinds of applications. It can run programs written in\u00a0multiple languages, with\u00a0C#\u00a0being the most popular. It relies on a\u00a0high-performance\u00a0runtime that is used in production by many\u00a0high-scale apps.\n\n.NET ecosystem\n\nThere are multiple variants of .NET, each supporting a different type of app. The reason for multiple variants is part historical, part technical.\n.NET implementations:\n\n.NET Framework\u00a0-- The original .NET. It provides access to the broad capabilities of Windows and Windows Server. It is actively supported, in maintenance.\nMono\u00a0-- The original community and open source .NET. A cross-platform implementation of .NET Framework. Actively supported for Android, iOS, and WebAssembly.\n.NET (Core)\u00a0-- Modern .NET. A cross-platform and open source implementation of .NET, rethought for the cloud age while remaining significantly compatible with .NET Framework. Actively supported for Linux, macOS, and Windows.\n\nThe .NET Framework and .NET Core\n.NET Core works similarly to the .NET Framework. In fact, many of the code and techniques that are presented in this course the same regardless of whether you use the .NET Framework or .NET Core. The main difference between these platforms is that the .NET Framework is older and only supports Windows. On the other hand, .NET Core is newer and cross-platform. As a result, .NET Core can run on Windows, macOS, and Linux. Because Microsoft ended development of the .NET Framework at version 4.8, .NET Core is the future of .NET development.\nIn fact, starting with version 5, .NET Core is now just called .NET (no Core in the name). Because .NET combines the best features of the .NET Framework and previous versions of .NET Core, it provides an easy migration path for .NET Framework applications, and it provides a foundation for future development of the .NET platform.\nBoth the .NET Framework and .NET provide a set of class libraries. These class libraries consist of segments of pre-written code called classes that provide many of the functions that you need for developing .NET applications. For instance, the WPF classes are used for developing WPF apps. The ASP.NET and ASP.NET Core classes are used for developing Web Forms apps. The EF and EF Core classes are used for developing apps that access databases. And other classes let you manage security, access files, and perform many other functions.\nThe .NET Framework and .NET also provide a common infrastructure that applications written in a .NET language such as C# can use to run on various operating systems and hardware platforms. This infrastructure includes the Common Language Runtime, the .NET languages, and the compilers for those languages.\nThe Common Language Runtime (CLR) provides the services that are needed for executing any application that\u2019s developed with one of the .NET languages. This is possible because all the .NET languages compile to a common intermediate language. The CLR also provides the Common Type System that defines the data types that are used by all .NET languages. Because all the .NET applications are managed by the CLR, they are sometimes referred to as managed applications.\u00a0\nBuild apps with .NET\n.NET has support for building many kinds of apps, including client, cloud, and gaming.\n\nClient apps Desktop apps\nMobile\nGames Cloud apps .NET Aspire\nServerless functions\nWeb and microservices Other app types Console apps\nInternet of Things (IoT)\nMachine learning\nWindows services"
    },
    {
        "title": "Course Overview",
        "created_at": "2025-01-21T04:54:34Z",
        "url": "course-overview",
        "editing_roles": "teachers",
        "page_id": 4602791,
        "last_edited_by": {
            "id": 11931,
            "anonymous_id": "97f",
            "display_name": "Fang Wang",
            "avatar_image_url": "https://umsystem.instructure.com/images/thumbnails/4444024/6WLz9gjSK0P0wnU25UhI81x8yH9mpLHXsZCrl1fI",
            "html_url": "https://umsystem.instructure.com/courses/296958/users/11931",
            "pronouns": null
        },
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/course-overview",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-24T17:28:38Z",
        "locked_for_user": false,
        "body": "A Warm Welcome!\nI'm glad to see you've enrolled in the\u00a0InfoTC 4400 - C#/.NET Development\u00a0this semester.\u00a0Before you jump into the course content, I'd like to take you through a short orientation. It will help you acclimate to course organization, learn about the topics covered in this course, and understand (and set) your course expectations.\n\nCourse Description\nThis course focuses on developing Windows applications using C#\u00a0programming language.\u00a0 The following topics are covered:\n\nIntroduction to C#, Microsoft Visual Studio, and the .NET platform\nObject-Oriented Programming with C#\nAdvanced C# Programming\nDesktop application for Windows\n\n\u00a0\nCourse Schedules\nThe course officially starts on Tue Jan. 21, when your access to Canvas and the first week's modules are available.\u00a0 Each week you are provided with new modules on Sunday and the work needs to be completed by the following Friday.\u00a0 In general, there is\u00a0 one coding assignment and one quiz for each module.\nThere is no time limit in taking the quiz before the deadline. You can ask questions, look things up, then come back to continue. Your work should be auto-saved. You can only submit once though. So submit only after you are completely done. If you need help, please ask. Students are encouraged to start working on the module early in the week, and utilize the TA office hours during the week. Assistance during weekend is extremely limited.\n\u00a0Late assignments will receive a\u00a010% deduction of the assignment total score for the first day of being, and 20% per day for the 2nd and 3rd day.\u00a0 After 3 full days until Stop Day, you will see a total of 50% reduction of points on the late work, plus any lost points from the rubric. This late policy is only for coding challenges and assignments. Quizzes, exams, and/or any other assignment must be completed by the due date/time to be considered for credit.\n\u00a0\nContacts\nInstructor: Dr. Fang Wang\u00a0 Office: 2437H Lafferre Hall\u00a0 \u00a0 Phone: 884-8747\u00a0 \u00a0\u00a0Email: wangfan@missouri.edu \u00a0 \nTA:\u00a0\nAmith Nalmas (anr79@missouri.edu)Office hour: Mon/Wed/Fri 2-4pmZoom meeting:\u00a0https://umsystem.zoom.us/j/91603648117?pwd=MFpnbWpFTlN1dVg5NysvUlIrZ0pDQT09Links to an external site.\n\u00a0\nCaden Hicks (cjhbv4@missouri.edu)Office hour: Tuesday, Thursday at 10 am - 12 pm and Friday at 11 am - 1 pmZoom meeting:\u00a0https://umsystem.zoom.us/j/5240824097?pwd=bys0VHRWTGlnTDV2UC96OUhZMVNWUT09Links to an external site.\n\u00a0\nCourse Discord Server:\u00a0\u00a0https://discord.gg/9UZMuGKxMd\n\u00a0\nQuestion and Answers\nQ: Do I have to be on campus for anything?\nA: No. This course is entirely online.\n\u00a0\nQ: Are there any tests I actually have to be on campus for?\nA: No. Everything you need to do will be posted on Canvas. Work for all assignments and exams will be submitted on Canvas.\n\u00a0\nQ: Where to get software used for the course?\nA: There are multiple ways to do that.\u00a0\n\nVisual Studio Downloads\nLafferre Hall C1206 & C1205 computers have VS installed.\nCollege of Engineering RemoteApps servers allow students, faculty, and staff to utilize software remotely without installing the software physically on their machines. http://remoteapps.missouri.edu/ (you need to VPN to campus network if you are off campus)\nEngineering students and faculty are eligible to download free Microsoft software. For Microsoft software login to MS Azure Dev Tools for Teaching.\u00a0\nRider: Cross-Platform .NET IDE from JetBrains with Free Educational Licenses\n\n\u00a0\nQ: How do I get help if I need it?\nA: Zoom video conference during office hours. Email or use Discord to get in touch with instructor and TA anytime.\n\u00a0\nQ:\u00a0Is it OK to take code from online resources or other people and submit as my own work?\u00a0\nYou are encouraged to look for resources online and work together in an effort to comprehend the course material. For instance, you may discuss generalities with classmates or someone outside the class when trying to understand the assignments. However, you should work individually when working out the solutions. Never copy solutions of others or any solutions you find anywhere, including online. Moreover, on assignments, quizzes and exams, any person found to be cheating will receive a 0, and the full extent of the MU rules on academic dishonesty will be followed. No other warnings will be given or should be necessary.\n\u00a0\nIf you have feedback that could help us improve the course or the course experience while you are taking the course, please let us know.\nI hope you have a great semester!"
    },
    {
        "title": "M1  Roadmap & Objectives",
        "created_at": "2025-01-21T04:54:39Z",
        "url": "m1-roadmap-and-objectives",
        "editing_roles": "teachers",
        "page_id": 4602824,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/m1-roadmap-and-objectives",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:39Z",
        "locked_for_user": false,
        "body": "Our readings, materials, and discussion this week are aimed at helping us get started with Visual Studio IDE.\n Objectives\nAfter completing this week's work, you will be able to:\n\nLocate different components in Visual Studio IDE.\nDevelop computer programs using VS IDE.\nDefine the concepts of variables.\nDefine different Boolean operations.\nApply variables and Boolean operations in programming\n\n\u00a0\n M1 Activities\n\nWatch Video Lectures\nRead Programming Guide,\nRead\u00a0Assessment and Rubrics\nComplete M1 Quiz and Assignments"
    },
    {
        "title": "1.1 - Intro to Visual Studio",
        "created_at": "2025-01-21T04:54:29Z",
        "url": "1-dot-1-intro-to-visual-studio",
        "editing_roles": "teachers",
        "page_id": 4602744,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/1-dot-1-intro-to-visual-studio",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:29Z",
        "locked_for_user": false,
        "body": "For more information about installing the latest version of Visual Studio, see Install Visual Studio\u00a0(Links to an external site.).\n\u00a0\n\u00a0Video lectures:"
    },
    {
        "title": "Obtain Visual Studio Software",
        "created_at": "2025-01-21T04:54:43Z",
        "url": "obtain-visual-studio-software",
        "editing_roles": "teachers",
        "page_id": 4602859,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/obtain-visual-studio-software",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:43Z",
        "locked_for_user": false,
        "body": "Microsoft Developer Software & Visual Studio\nChoose one of the ways that fits your need best.\n1. For free Visual Studio Community version, go to Visual Studio 2022 Download. Visual Studio Community version is sufficient for this course.\n2. College of Engineering RemoteApps servers allow students, faculty, and staff to utilize software remotely without installing the software physically on their machines.\u00a0http://remoteapps.missouri.edu/\nTutorials on how to use RemoteApps: https://mailmissouri.sharepoint.com/sites/COEIT/SitePages/CENGR-IT-Support---Public.aspx?csf=1&web=1&e=OreXRN&cid=3a83ad74-d79b-4402-ba7b-c9ba4352f802\n\u00a0\n3. Lafferre Hall C1206 C1205 computers have VS2022 installed\n\u00a0\n4. For Visual Studio Enterprise version, follow the steps below.\nMicrosoft software is available through the Microsoft Azure Dev Tools for Teaching.\nAccording to the page at https://azureforeducation.microsoft.com/devtools:\n\nStudents\u2014you\u2019re almost there! The developer tools and learning resources that were previously part of your Imagine account are now available with Azure Dev Tools for Teaching. Sign in using the button below\u2014you\u2019ll be taken to a page requesting you to sign in using a Microsoft Account. Learn about Microsoft Accounts here.\nNote: Please use the email you provided for your previous Imagine subscription access when creating a new Microsoft Account.\n\nWhen you click the Sign In button you sign in using an existing Microsoft account or create a new account. The important thing is that you use your MU email address. Since your student email account is a Microsoft account, you may be able to directly log in. Or, if not, you will need to create an account using your email address.\nOnce you log in, a page like the following should be displayed. \u00a0\nOnce you leave the Education - Overview page by clicking on links in the menu in the Azure portal, I am not sure how to navigate back to it. If you leave the page and need to get back to it, just go to the URL to login again https://azureforeducation.microsoft.com/devtools.\nClick the Software link to view the Microsoft Software that is available. Visual Studio Enterprise is the first one in the list."
    },
    {
        "title": "Visual Studio IDE",
        "created_at": "2025-01-21T04:54:46Z",
        "url": "visual-studio-ide",
        "editing_roles": "teachers",
        "page_id": 4602879,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/visual-studio-ide",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:46Z",
        "locked_for_user": false,
        "body": "Welcome to the Visual Studio IDE\nAn\u00a0integrated development environment\u00a0(IDE) is a feature-rich program that supports many aspects of software development. The Visual Studio IDE is a creative launching pad that you can use to edit, debug, and build code, and then publish an app. Over and above the standard editor and debugger that most IDEs provide, Visual Studio includes compilers, code completion tools, graphical designers, and many more features to enhance the software development process. The preceding image shows Visual Studio with an open project that shows key windows and their functionality: In\u00a0Solution Explorer, at upper right, you can view, navigate, and manage your code files.\u00a0Solution Explorer\u00a0can help organize your code by grouping the files into\u00a0solutions and projects. The central\u00a0editor window, where you'll probably spend most of your time, displays file contents. In the editor window, you can edit code or design a user interface such as a window with buttons and text boxes. In\u00a0Git Changes\u00a0at lower right, you can track work items and share code with others by using version control technologies like\u00a0Git\u00a0and\u00a0GitHub. \u00a0\nIntelliSense in Visual Studio\nIntelliSense is a code-completion aid that includes a number of features: List Members, Parameter Info, Quick Info, and Complete Word. These features help you to learn more about the code you're using, keep track of the parameters you're typing, and add calls to properties and methods with only a few keystrokes.\n\u00a0\nVisual Studio Tutorial | C#"
    },
    {
        "title": "How to use GitHub with Visual Studio",
        "created_at": "2025-01-21T04:54:38Z",
        "url": "how-to-use-github-with-visual-studio",
        "editing_roles": "teachers",
        "page_id": 4602814,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/how-to-use-github-with-visual-studio",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:38Z",
        "locked_for_user": false,
        "body": "Visual Studio and GitHub\nVisual Studio version control docs\n\nCreate a Git repository from Visual Studio\nClone a Git repository in Visual Studio"
    },
    {
        "title": "1.2 - Variables",
        "created_at": "2025-01-21T04:54:29Z",
        "url": "1-dot-2-variables",
        "editing_roles": "teachers",
        "page_id": 4602745,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/1-dot-2-variables",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:29Z",
        "locked_for_user": false,
        "body": "Lecture Slides: M1_Variables.pdf\n\u00a0Video Lectures:\u00a0\nPart 1\n\n\u00a0\nPart 2"
    },
    {
        "title": "Variables Programming Guide",
        "created_at": "2025-01-21T04:54:46Z",
        "url": "variables-programming-guide",
        "editing_roles": "teachers",
        "page_id": 4602878,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/variables-programming-guide",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:46Z",
        "locked_for_user": false,
        "body": "Types and variables\nThere are two kinds of types in C#:\u00a0value types\u00a0and\u00a0reference types. Variables of value types directly contain their data whereas variables of reference types store references to their data, the latter being known as objects. With reference types, it is possible for two variables to reference the same object and thus possible for operations on one variable to affect the object referenced by the other variable. With value types, the variables each have their own copy of the data, and it is not possible for operations on one to affect the other (except in the case of\u00a0ref\u00a0and\u00a0out\u00a0parameter variables).\nC#\u2019s value types are further divided into\u00a0simple types,\u00a0enum types,\u00a0struct types, and\u00a0nullable value types. C#\u2019s reference types are further divided into\u00a0class types,\u00a0interface types,\u00a0array types, and\u00a0delegate types.\nThe following provides an overview of C#\u2019s type system.\n\nValue types\u00a0(Links to an external site.)\n\nSimple types\u00a0(Links to an external site.)\n\nSigned integral:\u00a0sbyte,\u00a0short,\u00a0int,\u00a0long\nUnsigned integral:\u00a0byte,\u00a0ushort,\u00a0uint,\u00a0ulong\nUnicode characters:\u00a0char\nIEEE binary floating-point:\u00a0float,\u00a0double\nHigh-precision decimal floating-point:\u00a0decimal\nBoolean:\u00a0bool Enum types\u00a0(Links to an external site.)\n\nUser-defined types of the form\u00a0enum E {...} Struct types\u00a0(Links to an external site.)\n\nUser-defined types of the form\u00a0struct S {...} Nullable value types\u00a0(Links to an external site.)\n\nExtensions of all other value types with a\u00a0null\u00a0value Reference types\u00a0(Links to an external site.)\n\nClass types\u00a0(Links to an external site.)\n\nUltimate base class of all other types:\u00a0object\nUnicode strings:\u00a0string\nUser-defined types of the form\u00a0class C {...} Interface types\u00a0(Links to an external site.)\n\nUser-defined types of the form\u00a0interface I {...} Array types\u00a0(Links to an external site.)\n\nSingle- and multi-dimensional, for example,\u00a0int[]\u00a0and\u00a0int[,] Delegate types\u00a0(Links to an external site.)\n\nUser-defined types of the form\u00a0delegate int D(...) For more information about numeric types, see\u00a0Integral types\u00a0(Links to an external site.)\u00a0and\u00a0Floating-point types table\u00a0(Links to an external site.).\nC#\u2019s\u00a0bool\u00a0type is used to represent Boolean values\u2014values that are either\u00a0true\u00a0or\u00a0false.\nCharacter and string processing in C# uses Unicode encoding. The\u00a0char\u00a0type represents a UTF-16 code unit, and the\u00a0string\u00a0type represents a sequence of UTF-16 code units.\nC# programs use\u00a0type declarations\u00a0to create new types. A type declaration specifies the name and the members of the new type. Five of C#\u2019s categories of types are user-definable: class types, struct types, interface types, enum types, and delegate types.\n\u00a0\nIdentifier names\nAn\u00a0identifier\u00a0is the name you assign to a type (class, interface, struct, delegate, or enum), member, variable, or namespace. Valid identifiers must follow these rules:\n\nIdentifiers must start with a letter, or\u00a0_.\nIdentifiers may contain Unicode letter characters, decimal digit characters, Unicode connecting characters, Unicode combining characters, or Unicode formatting characters. For more information on Unicode categories, see the\u00a0Unicode Category Database\u00a0(Links to an external site.). You can declare identifiers that match C# keywords by using the\u00a0@\u00a0prefix on the identifier. The\u00a0@\u00a0is not part of the identifier name. For example,\u00a0@if\u00a0declares an identifier named\u00a0if. These\u00a0verbatim identifiers\u00a0(Links to an external site.)\u00a0are primarily for interoperability with identifiers declared in other languages.\n\nFor a complete definition of valid identifiers, see the\u00a0Identifiers topic in the C# Language Specification\u00a0(Links to an external site.).\n\u00a0\nNaming conventions \nIn addition to the rules, there are a number of identifier\u00a0naming conventions\u00a0(Links to an external site.)\u00a0used throughout the .NET APIs. By convention, C# programs use\u00a0PascalCase\u00a0for type names, namespaces, and all public members. In addition, the following conventions are common:\n\nInterface names start with a capital\u00a0I.\nAttribute types end with the word\u00a0Attribute.\nEnum types use a singular noun for non-flags, and a plural noun for flags.\nIdentifiers should not contain two consecutive\u00a0_\u00a0characters. Those names are reserved for compiler generated identifiers."
    },
    {
        "title": "1.3 - Boonlean Operations",
        "created_at": "2025-01-21T04:54:29Z",
        "url": "1-dot-3-boonlean-operations",
        "editing_roles": "teachers",
        "page_id": 4602746,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/1-dot-3-boonlean-operations",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:29Z",
        "locked_for_user": false,
        "body": "Lecture Slides: M1_Boolean.pdf\n\u00a0Video Lectures:\u00a0\nBoonlean Operations and Comparison Operators\n\n\u00a0\nConditional Statements\n\n\u00a0\n\u00a0Recommended Online Resources:\n1. Channel 9 - The if Decision Statement\n2. Channel 9 -  Operators, Expressions, and Statements"
    },
    {
        "title": "Boolean Logic Operator Programming Guide",
        "created_at": "2025-01-21T04:54:34Z",
        "url": "boolean-logic-operator-programming-guide",
        "editing_roles": "teachers",
        "page_id": 4602786,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/boolean-logic-operator-programming-guide",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:33Z",
        "locked_for_user": false,
        "body": "Boolean logical operators\u00a0\nThe following operators perform logical operations with\u00a0bool\u00a0operands:\n\nUnary\u00a0!\u00a0(logical negation)\u00a0operator.\nBinary\u00a0&\u00a0(logical AND),\u00a0|\u00a0(logical OR), and\u00a0^\u00a0(logical exclusive OR)\u00a0operators. Those operators always evaluate both operands.\nBinary\u00a0&&\u00a0(conditional logical AND)\u00a0and\u00a0||\u00a0(conditional logical OR)\u00a0operators. Those operators evaluate the right-hand operand only if it's necessary.\n\nFor operands of the\u00a0integral numeric types, the\u00a0&,\u00a0|, and\u00a0^\u00a0operators perform bitwise logical operations. For more information, see\u00a0Bitwise and shift operators.\nLogical negation operator !\nThe unary prefix\u00a0!\u00a0operator computes logical negation of its operand. That is, it produces\u00a0true, if the operand evaluates to\u00a0false, and\u00a0false, if the operand evaluates to\u00a0true:\nC#\nbool passed = false;\nConsole.WriteLine(!passed);  // output: True\nConsole.WriteLine(!true);    // output: False\n\nBeginning with C# 8.0, the unary postfix\u00a0!\u00a0operator is the\u00a0null-forgiving operator.\nLogical AND operator &\nThe\u00a0&\u00a0operator computes the logical AND of its operands. The result of\u00a0x & y\u00a0is\u00a0true\u00a0if both\u00a0x\u00a0and\u00a0y\u00a0evaluate to\u00a0true. Otherwise, the result is\u00a0false.\nThe\u00a0&\u00a0operator evaluates both operands even if the left-hand operand evaluates to\u00a0false, so that the operation result is\u00a0false\u00a0regardless of the value of the right-hand operand.\nIn the following example, the right-hand operand of the\u00a0&\u00a0operator is a method call, which is performed regardless of the value of the left-hand operand:\nC#\nbool SecondOperand() \n{\n    Console.WriteLine(\"Second operand is evaluated.\");\n    return true;\n}\n\nbool a = false & SecondOperand();\nConsole.WriteLine(a);\n// Output:\n// Second operand is evaluated.\n// False\n\nbool b = true & SecondOperand();\nConsole.WriteLine(b);\n// Output:\n// Second operand is evaluated.\n// True\n\nThe\u00a0conditional logical AND operator\u00a0&&\u00a0also computes the logical AND of its operands, but doesn't evaluate the right-hand operand if the left-hand operand evaluates to\u00a0false.\nFor operands of the\u00a0integral numeric types, the\u00a0&\u00a0operator computes the\u00a0bitwise logical AND\u00a0of its operands. The unary\u00a0&\u00a0operator is the\u00a0address-of operator.\nLogical exclusive OR operator ^\nThe\u00a0^\u00a0operator computes the logical exclusive OR, also known as the logical XOR, of its operands. The result of\u00a0x ^ y\u00a0is\u00a0true\u00a0if\u00a0x\u00a0evaluates to\u00a0true\u00a0and\u00a0y\u00a0evaluates to\u00a0false, or\u00a0x\u00a0evaluates to\u00a0false\u00a0and\u00a0y\u00a0evaluates to\u00a0true. Otherwise, the result is\u00a0false. That is, for the\u00a0bool\u00a0operands, the\u00a0^\u00a0operator computes the same result as the\u00a0inequality operator\u00a0!=.\nC#\nConsole.WriteLine(true ^ true);    // output: False\nConsole.WriteLine(true ^ false);   // output: True\nConsole.WriteLine(false ^ true);   // output: True\nConsole.WriteLine(false ^ false);  // output: False\n\nFor operands of the\u00a0integral numeric types, the\u00a0^\u00a0operator computes the\u00a0bitwise logical exclusive OR\u00a0of its operands.\nLogical OR operator |\nThe\u00a0|\u00a0operator computes the logical OR of its operands. The result of\u00a0x | y\u00a0is\u00a0true\u00a0if either\u00a0x\u00a0or\u00a0y\u00a0evaluates to\u00a0true. Otherwise, the result is\u00a0false.\nThe\u00a0|\u00a0operator evaluates both operands even if the left-hand operand evaluates to\u00a0true, so that the operation result is\u00a0true\u00a0regardless of the value of the right-hand operand.\nIn the following example, the right-hand operand of the\u00a0|\u00a0operator is a method call, which is performed regardless of the value of the left-hand operand:\nC#\nbool SecondOperand() \n{\n    Console.WriteLine(\"Second operand is evaluated.\");\n    return true;\n}\n\nbool a = true | SecondOperand();\nConsole.WriteLine(a);\n// Output:\n// Second operand is evaluated.\n// True\n\nbool b = false | SecondOperand();\nConsole.WriteLine(b);\n// Output:\n// Second operand is evaluated.\n// True\n\nThe\u00a0conditional logical OR operator\u00a0||\u00a0also computes the logical OR of its operands, but doesn't evaluate the right-hand operand if the left-hand operand evaluates to\u00a0true.\nFor operands of the\u00a0integral numeric types, the\u00a0|\u00a0operator computes the\u00a0bitwise logical OR\u00a0of its operands.\nConditional logical AND operator &&\nThe conditional logical AND operator\u00a0&&, also known as the \"short-circuiting\" logical AND operator, computes the logical AND of its operands. The result of\u00a0x && y\u00a0is\u00a0true\u00a0if both\u00a0x\u00a0and\u00a0y\u00a0evaluate to\u00a0true. Otherwise, the result is\u00a0false. If\u00a0x\u00a0evaluates to\u00a0false,\u00a0y\u00a0is not evaluated.\nIn the following example, the right-hand operand of the\u00a0&&\u00a0operator is a method call, which isn't performed if the left-hand operand evaluates to\u00a0false:\nC#\nbool SecondOperand()\n{\n    Console.WriteLine(\"Second operand is evaluated.\");\n    return true;\n}\n\nbool a = false && SecondOperand();\nConsole.WriteLine(a);\n// Output:\n// False\n\nbool b = true && SecondOperand();\nConsole.WriteLine(b);\n// Output:\n// Second operand is evaluated.\n// True\n\nThe\u00a0logical AND operator\u00a0&\u00a0also computes the logical AND of its operands, but always evaluates both operands.\nConditional logical OR operator ||\nThe conditional logical OR operator\u00a0||, also known as the \"short-circuiting\" logical OR operator, computes the logical OR of its operands. The result of\u00a0x || y\u00a0is\u00a0true\u00a0if either\u00a0x\u00a0or\u00a0y\u00a0evaluates to\u00a0true. Otherwise, the result is\u00a0false. If\u00a0x\u00a0evaluates to\u00a0true,\u00a0y\u00a0is not evaluated.\nIn the following example, the right-hand operand of the\u00a0||\u00a0operator is a method call, which isn't performed if the left-hand operand evaluates to\u00a0true:\n\nbool SecondOperand()\n{\n    Console.WriteLine(\"Second operand is evaluated.\");\n    return true;\n}\n\nbool a = true || SecondOperand();\nConsole.WriteLine(a);\n// Output:\n// True\n\nbool b = false || SecondOperand();\nConsole.WriteLine(b);\n// Output:\n// Second operand is evaluated.\n// True\n\nThe\u00a0logical OR operator\u00a0|\u00a0also computes the logical OR of its operands, but always evaluates both operands.\nNullable Boolean logical operators\nFor\u00a0bool?\u00a0operands, the\u00a0&\u00a0and\u00a0|\u00a0operators support the three-valued logic. The semantics of these operators is defined by the following table: x\ny\nx&y\nx|y true\ntrue\ntrue\ntrue true\nfalse\nfalse\ntrue true\nnull\nnull\ntrue false\ntrue\nfalse\ntrue false\nfalse\nfalse\nfalse false\nnull\nfalse\nnull null\ntrue\nnull\ntrue null\nfalse\nfalse\nnull null\nnull\nnull\nnull The behavior of those operators differs from the typical operator behavior with nullable value types. Typically, an operator which is defined for operands of a value type can be also used with operands of the corresponding nullable value type. Such an operator produces\u00a0null\u00a0if any of its operands evaluates to\u00a0null. However, the\u00a0&\u00a0and\u00a0|\u00a0operators can produce non-null even if one of the operands evaluates to\u00a0null. For more information about the operator behavior with nullable value types, see the\u00a0Lifted operators\u00a0section of the\u00a0Nullable value types\u00a0article.\nYou can also use the\u00a0!\u00a0and\u00a0^\u00a0operators with\u00a0bool?\u00a0operands, as the following example shows:\nC#\nbool? test = null;\nDisplay(!test);         // output: null\nDisplay(test ^ false);  // output: null\nDisplay(test ^ null);   // output: null\nDisplay(true ^ null);   // output: null \n\nvoid Display(bool? b) => Console.WriteLine(b is null ? \"null\" : b.Value.ToString());\n\nThe conditional logical operators\u00a0&&\u00a0and\u00a0||\u00a0don't support\u00a0bool?\u00a0operands.\nCompound assignment<\nFor a binary operator\u00a0op, a compound assignment expression of the form\nC#\nx op= y\n\nis equivalent to\nC#\nx = x op y\n\nexcept that\u00a0x\u00a0is only evaluated once.\nThe\u00a0&,\u00a0|, and\u00a0^\u00a0operators support compound assignment, as the following example shows:\nC#\nbool test = true;\ntest &= false;\nConsole.WriteLine(test);  // output: False\n\ntest |= true;\nConsole.WriteLine(test);  // output: True\n\ntest ^= false;\nConsole.WriteLine(test);  // output: True\n\nThe conditional logical operators\u00a0&&\u00a0and\u00a0||\u00a0don't support compound assignment.\nOperator precedence\nThe following list orders logical operators starting from the highest precedence to the lowest:\n\nLogical negation operator\u00a0!\nLogical AND operator\u00a0&\nLogical exclusive OR operator\u00a0^\nLogical OR operator\u00a0|\nConditional logical AND operator\u00a0&&\nConditional logical OR operator\u00a0||\n\nUse parentheses,\u00a0(), to change the order of evaluation imposed by operator precedence:\nC#\nConsole.WriteLine(true | true & false);   // output: True\nConsole.WriteLine((true | true) & false); // output: False\n\nbool Operand(string name, bool value)\n{\n    Console.WriteLine($\"Operand {name} is evaluated.\");\n    return value;\n}\n\nvar byDefaultPrecedence = Operand(\"A\", true) || Operand(\"B\", true) && Operand(\"C\", false);\nConsole.WriteLine(byDefaultPrecedence);\n// Output:\n// Operand A is evaluated.\n// True\n\nvar changedOrder = (Operand(\"A\", true) || Operand(\"B\", true)) && Operand(\"C\", false);\nConsole.WriteLine(changedOrder);\n// Output:\n// Operand A is evaluated.\n// Operand C is evaluated.\n// False\n\nFor the complete list of C# operators ordered by precedence level, see the\u00a0Operator precedence\u00a0section of the\u00a0C# operators\u00a0article."
    },
    {
        "title": "1.4 - First C# Program ",
        "created_at": "2025-01-21T04:54:29Z",
        "url": "1-dot-4-first-c-number-program",
        "editing_roles": "teachers",
        "page_id": 4602747,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/1-dot-4-first-c-number-program",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:29Z",
        "locked_for_user": false,
        "body": "Lecture Slides: FirstWPF.pdf\n\u00a0Video Lectures:\u00a0\n\nRecommended Online Resources:\n\u00a01. WinUI 3 app, WPF, UWP, Windows Forms, or Cross-platform options: Get started with Windows: Selecting a development technology\n2. Channel 9 -  Creating Your First C# Program\u00a0\n3. Channel 9 -  Understanding Your First C# Program"
    },
    {
        "title": "Create a simple C# console app in Visual Studio",
        "created_at": "2025-01-21T04:54:34Z",
        "url": "create-a-simple-c-number-console-app-in-visual-studio",
        "editing_roles": "teachers",
        "page_id": 4602792,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/create-a-simple-c-number-console-app-in-visual-studio",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:34Z",
        "locked_for_user": false,
        "body": "Tutorial: Create a simple C# console app in Visual Studio"
    },
    {
        "title": "First WPF Program",
        "created_at": "2025-01-21T04:54:36Z",
        "url": "first-wpf-program",
        "editing_roles": "teachers",
        "page_id": 4602801,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/first-wpf-program",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:36Z",
        "locked_for_user": false,
        "body": "What is Windows Presentation Foundation - WPF .NET\nTutorial: Create a new WPF app with .NET"
    },
    {
        "title": "First UWP Program",
        "created_at": "2025-01-21T04:54:36Z",
        "url": "first-uwp-program",
        "editing_roles": "teachers",
        "page_id": 4602800,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/first-uwp-program",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:36Z",
        "locked_for_user": false,
        "body": "What's a Universal Windows Platform (UWP) app?\nTutorial: Create your first Universal Windows Platform application in Visual Studio with XAML and C#"
    },
    {
        "title": "Windows App SDK",
        "created_at": "2025-01-21T04:54:47Z",
        "url": "windows-app-sdk",
        "editing_roles": "teachers",
        "page_id": 4602882,
        "published": true,
        "hide_from_students": false,
        "front_page": false,
        "html_url": "https://umsystem.instructure.com/courses/296958/pages/windows-app-sdk",
        "todo_date": null,
        "publish_at": null,
        "updated_at": "2025-01-21T04:54:47Z",
        "locked_for_user": false,
        "body": "Developing for Windows with the Windows App SDK\nCreate your first WinUI 3 (Windows App SDK) project\nTutorial: Create a simple photo viewer with WinUI 3 (C#)"
    }
]