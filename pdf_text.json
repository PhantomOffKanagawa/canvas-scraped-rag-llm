[
  {
    "title": "FileStream.pdf",
    "url": "https://umsystem.instructure.com/courses/296958/files/32026263/download?verifier=4kVkNp1UFLO3XutBftW5T9s6cEA4KoDoGjvwsZsi&amp;wrap=1",
    "body": "File Stream\n\n\nUsing File for Data Storage\n• When a program needs to save data for later use, it writes the data in a file\n• There are always three steps:\n• Open the file: create a connection between the file and the program\n• Process the file: either write to or read from the file\n• Close the file: disconnect the file and the program\n• In general, there are two types of files:\n• Text file: contains data that has been encoded as test using scheme such as \nUnicode\n• Binary file: contains data that has not been converted to text. You cannot view \nthe contents of binary files with a text editor.\n• We work with text files for now\n\n\nFile Accessing\n• A file object is an object that is associated with a specific file and \nprovides a way for the program to work with that file\n• The .NET Framework provide two classes to create file objects \nthrough the System.IO namespace\n• StreamWriter: for writing data to a text file\n• StreamReader: for reading data from a text file\n• You need to write the following directives at the top of your program\nUsing System.IO;\n\n\nWriting Data to a File\n• Start with creating a StreamWriter object\nStreamWriter outputFile;\n• Use one of the File methods to open the file to which you will be writing data. \nSample File methods are:\n•File.CreateText\n•File.AppendText\n• Use the Write or WriteLine method to write items of data to the file\n• Close the connection.\n\n\nSample Code\nStreamWriter outputFile;\noutputFile = File.CreateText(“courses.txt”);\noutputFile.WriteLine(“Introduction to Computer Science”);\noutputFile.WriteLine(“English Composition”);\noutputFile.Write(“Calculus I”);\noutputFile.Close();\n•The WriteLine method writes an item of data to a file and then writes a \nnewline characters which specifies the end of a line\n•The Write method writes an item to a file without a newline character\n\n\nCreateText vs. AppendText\n• The previous code uses the File.CreateText method for the following reasons:\n• It creates a text file with the name specified by the argument. If the file already \nexists, its contents are erased\n• It creates a StreamWriter object in memory, associated with the file\n• It returns a reference to the StreamWriter object\n• When there is a need not to erase the contents of an existing file, use the \nAppendText method\nStreamWriter outputFile;\noutputFile = File.AppendText(“Names.txt”);\noutputFile.WriteLine(“Lynn”);\noutputFile.WriteLine(“Steve”);\noutputFile.Close();\n\n\nSpecifying the Location of an Output File\n• If you want to open a file in a different location, you can \nspecify a path as well as filename in the argument\n• Be sure to prefix the string with the @ character\nStreamWriter outputFile;\noutputFile = File.CreateText(@”C:\\Users\\chris\\Documents\\Names.txt”);\n\n\nReading Data from a File\n• Start with creating a StreamReader object\nStreamReader inputFile;\n• Use the File.OpenText method to open the file to which you will be writing data\ninputFile = File.OpenText(“students.txt”);\n• Use the Read or ReadLine method to write items of data to the file\n•StreamReader.ReadLine: Reads a line of characters from the current stream and returns the data \nas a string.\n•StreamReader.Read: Reads the next character or next set of characters from the input stream.\n• Close the connection\n\n\nReading a File with a Loop\n• StreamReader objects have a Boolean property named EndOfStream\nthat signals whether or not the end of file has been reached\n• You can write a loop to detect the end of the file. \nwhile (inputFile.EndOfStream == false) { }\n• Or \nwhile (!inputFile.EndOfStream) { }\n\n\nThe OpenFileDialog and SaveFileDialog\nControls\n• using System.Windows.Forms;\n• The OpenFileDialog and SaveDialog controls allow your application to \ndisplay standard Windows dialog boxes for opening and saving files\n• Unlike Label, Button, and TextBox, they are invisible controls\n• The OpenFileDialog control displays a standard Windows Open dialog box.\n• The SaveDialog control displays a standard Windows Save As dialog box \n\n\nDetecting the User’s Selection\n• The showDialog method returns a value that indicates which button \nthe user clicks to dismiss the dialog box\n• If the user clicked the Open button, the value DialogResult.OK is returned\n• If the user clicked the Cancel button, the value DialogResult.Cancel is returned\n• The following is an example that calls the ShowDialog method to determine \nthe user’s choice:\nif (openFile.ShowDialog() == DialogResult.OK) { }\nelse if (openFile.ShowDialog() == DialogResult.Cancel) { }\nelse { }\n\n\nThe Filename and Initial Directory Property\n• When the user selects a file with the Open dialog box, the file’s path and filename are stored in the \ncontrol’s Filename property\n• The following is an example of how to open the selected file:\nif (openFile.ShowDialog() == DialogResult.OK)\n{\ninputFile = File.OpenText(openFile.Filename);\n}\nelse { }\n• You can specify a directory to be initially displayed with the InitialDirectory property. For \nexample,\nopenFile.InitialDirectory = “C:\\Data”;\n\n\nDisplaying a Save As Dialog Box\n• Use the following to call the SaveFileDialog control’s ShowDialog method\nsaveFile.ShowDialog();\n• Use the following to detect the user’s choice\nif (saveFile.ShowDialog() == DialogResult.OK) { }\n• Use the following to open the selected file\nif (saveFile.ShowDialog() == DialogResult.OK) \n{\noutputFile = File.CreateText(openFile.Filename); \n}\n\n\n"
  },
  {
    "title": "Serialization.pdf",
    "url": "https://umsystem.instructure.com/courses/296958/files/32026266/download?verifier=XVd0GYE6449Wn12vSfyNcN9FMf0jeO7Ntj3ILetL&amp;wrap=1",
    "body": "Serialization\n\n\nSerialization\n• It is easy to write the individual fields of a record object to a file\n• For example, we can create a record that stores information about a \nPerson\n• Name\n• Age\n• Gender\n• ID number\n• etc\n• We can output each field of this record to a file (either text or binary) \n\n\nPersonInfo\nName\nAge\nGender\nID number\nRecord file\nstring int string int\n\n\nSerialization\n• In this example, any program that needs to read the file needs to know \nthe format of the data\n• 1 strings, an int, 1 string and then an int\n• Also whether each item is on a separate line\n• Object serialization allows complete objects to be read or written with \na single statement\n• A serialized object is an object represented as a sequence of bytes\n• Information is stored about the data types of the objects instance fields \nas well as their values\n• Allows the object to be reconstructed (de-serialized) from the file \n\n\nPersonInfo\nName\nAge\nGender\nID number\nRecord file\nPerson obj\n\n\nSerialization\n• To serialize an object, the object class needs to be marked with the \n[Serializable] attribute or needs to implement the ISerializable\ninterface\n• Requires the System.Runtime.Serialization namespace\n• Also we require a BinaryFormatter object to serialize/de-serialize the \nobject before  writing to or reading from file\n\n\nprivate void button1_Click(object sender, EventArgs e)\n{\nString name = textBox1.Text;\nString address = textBox2.Text;\nint id = Convert.ToInt32(textBox3.Text);\nString courseInfo = textBox4.Text;             \nStudentInfo s = new StudentInfo(name,address,courseInfo,id);\nFileStream filestream = new FileStream(fileName, FileMode.Create);\nBinaryFormatter bf = new BinaryFormatter();\nbf.Serialize(filestream, s);\nfilestream.Close();\nbutton1.Enabled = true;\n}\nprivate void button2_Click(object sender, EventArgs e)\n{\nFileStream filestream2 = new FileStream(fileName,FileMode.Open);\nBinaryFormatter bf2 = new BinaryFormatter();\nStudentInfo si= new StudentInfo();\nsi = (StudentInfo)bf2.Deserialize(filestream2);\ntextBox8.Text = si.Name;\ntextBox7.Text = si.Address;\ntextBox6.Text = \"\"+si.ID;\ntextBox5.Text = si.CourseInfo;\nfilestream2.Close();\n}\n\n\n"
  },
  {
    "title": "Delegates.pdf",
    "url": "https://umsystem.instructure.com/courses/296958/files/32026311/download?verifier=SMTSrF4t6wPDK3Xlwc7Ps3m6Aay5BDQ0IeJPUb4Z&amp;wrap=1",
    "body": "Delegates\n\n\nDelegates\n• A delegate is an object that knows how to call a method\n• Special reference type: reference to a method\n• Behaves like a C++ function pointer\n• C# delegates enable to add function “variables” \n\n\nWhy Delegates?\n• Necessary indirection\nDelegates provide a way for .NET components to call your code without the \n.NET components having to know anything about your code beyond the method \nsignature.\n• Synchronous and Asynchronous Method Invocation\n• Event Foundation\n\n\nDelegate Type\n• A delegate type defines the kind of method that delegate instance can \ncall. Assign methods to delegate with matching signatures\n•\nSame parameter types\n•\nSame order of parameters\n•\nSame return type\n\n\nExample\ndelegate int Transformer(int x); //defines a delegate type called Transformer\nclass Test\n{\nstatic void Main()\n{\nTransformer t = Square; // Create delegate instance\nint result = t(3); // Invoke delegate\nConsole.WriteLine (result); // 9\n}\nstatic int Square(int x) { return x * x; }\n}\n\n\n• The statement:\nTransformer t = Square;\nis shorthand for:\nTransformer t = new Transformer (Square);\nt references Square after its constructor has been invoked\n• The expression: t(3)   is shorthand for:  t.Invoke(3)\nt\nSquare\n\n\nWriting Plug-in Methods with Delegates\n• A delegate variable is assigned a method at runtime. This is useful for \nwriting plugin methods.\n• Lamda2 example\n\n\nMulticast Delegates\n• All delegate instances have multicast capability: a delegate instance\ncan reference not just a single target method, but also a list of target methods\nSomeDelegate d = SomeMethod1;\nd += SomeMethod2;\n• Invoking d will now call both SomeMethod1 and SomeMethod2. Delegates are \ninvoked in the order they are added.\n• Use GetInvocationList to Obtain an Invocation List as an Array of Delegate \nReferences \n• http://msdn.microsoft.com/en-us/library/ms173175.aspx\n• http://msdn.microsoft.com/en-us/library/ms173171.aspx\n\n\nLambda Expressions\n• A lambda expression has the form of : \n(parameters) => expression-or-statement-block\n• A lambda expression is an unnamed method written in place of a \ndelegate instance. The compiler immediately converts the lambda \nexpression to a delegate instance\ndelegate int Transformer (int i);\nTransformer sqr = x => x * x;\nConsole.WriteLine (sqr(3)); // 9\nhttp://msdn.microsoft.com/en-us/library/bb397687.aspx\n\n\n• x => x * x // A simple expression that returns the square of its parameter // \nThe type of parameter x is inferred from the context.\n• x => { return x * x ; } // Semantically the same as the preceding \nexpression, but using a C# statement block as a body rather than a simple \nexpression\n• (int x) => x / 2 // A simple expression that returns the value of the \nparameter divided by 2. The type of parameter x is stated explicitly.\n• () => folder.StopFolding(0) // Calling a method. The expression \ntakes no parameters. The expression might or might not return a value. \n• (x, y) => { x++; return x / y; } // Multiple parameters; the \ncompiler infers the parameter types. The parameter x is passed by value, so the \neffect of the ++ operation is local to the expression.\n\n\nLambda Expression\n• If a lambda expression takes parameters, you specify them in the parentheses to the left of \nthe => operator. You can omit the types of parameters, and the C# compiler will infer \ntheir types from the context of the lambda expression. \n• Lambda expressions can return values, but the return type must match that of the delegate \nthey are being added to.\n• The body of a lambda expression can be a simple expression or a block of C# code made \nup of multiple statements, method calls, variable definitions, and other code items.\n• Variables defined in a lambda expression method go out of scope when the method \nfinishes.\n• A lambda expression can access and modify all variables outside the lambda expression \nthat are in scope when the lambda expression is defined. Be very careful with this feature!\n\n\n"
  },
  {
    "title": "Events.pdf",
    "url": "https://umsystem.instructure.com/courses/296958/files/32026328/download?verifier=nq365HL3IBHTywn2pdKT9yZ9HynBg1oNn0HhHUR5&amp;wrap=1",
    "body": "Events\n\n\nEvents\n• Event typically means a change in state of an object; some activities \ntake place in an object or application\n• Events provide a way for a class or object to notify other classes or \nobjects when something of interest happens.\n• The class that sends (or raises) the event is called the publisher and \nthe classes that receive (or handle) the event are called subscribers.\n\n\nProperties of Events\n• The publisher determines when an event is raised; the subscribers determine what action is taken in \nresponse to the event.\n• An event can have multiple subscribers. A subscriber can handle multiple events from multiple publishers.\n• Events that have no subscribers are never called.\n•\nEvents are commonly used to signal user actions such as button clicks or menu selections in graphical user \ninterfaces.\n• When an event has multiple subscribers, the event handlers are invoked synchronously when an event is \nraised.\n•\nEvents can be used to synchronize threads.\n•\nIn the .NET Framework class library, events are based on the EventHandler delegate and the EventArgs\nbase class.\n\n\nDefining an Event\n1. Define a delegate that points to the method to be called when the \nevent is fired\npublic delegate void CarEventHandler(string msg);\n2. Declare events in terms of the related delegate\npublic event CarEventHandler Exploded;\n\n\nRaise an Event\n• Call the method (event handler) pointed by the event.\npublic void SpeedUp (int delta)\n{\n// If the car is dead, fire Exploded event.\nif (carIsDead)\n{\nif (Exploded != null)\nExploded(\"Sorry, this car is dead...\");\n}\n}\n\n\nRegister Event Handler\nCar.CarEventHandler d = new \nCar.CarEventHandler(CarExploded);\nc1.Exploded += d;\npublic static void CarExploded (string msg)\n{ Console.WriteLine(msg); }\n\n\nEvents: Protection\nWithout event, the subscribers could do the following to interfere with \neach other\n•Replace other subscribers by reassigning (instead of using the += \noperator\n• Clear all subscribers (by setting PriceChanged to null).\n• Broadcast to other subscribers by invoking the delegate\n\n\nCustom Event Handlers vs. Standard Event Handler\n• System.EventHandler delegate enforces \nthe of event handlers returning no value while accepting two parameters, \nthe first being an object-typed parameter (to hold a reference to the class \nraising the event) \nand a second parameter of type System.EventArgs or a subclass thereof (to \nhold any event data). System.EventArgs is presented later.\npublic delegate void EventHandler(object sender, EventArgs e);\n\n\nConventions\n• Event Name\nExamples — for events raised before state change:\nFileDownloading\nExamples — for events raised after state change:\nFileDownloadCompleted\n• System.EventArgs Subclass : The name of your EventArgs subclass \nshould be the name of the event, with 'EventArgs' appended \nPriceChangedEventArgs\n• Event Handler (delegate) Name\nbuilt-in System.EventHandler delegate \nPriceChangedHandler\n\n\nConventions\n• Event Handler (delegate) Signature\nThe delegate should always return void\nThe first parameter should be of the object type and should be named sender. \nThe second parameter should be named 'e' and should be of the System.EventArgs type or your custom \nsubclass of System.EventArgs\npublic delegate void PriceChangedHandler(object sender, \nPriceChangedEventArgs e);\n• Event Handling Method Name\nThe convention implemented by Visual Studio: the name of the object raising the event; followed by (2) an \nunderscore character; with (3) the event name appended.\nstock_PriceChanged\n\n\nWalkthrough – Prepare the Event Publisher\n• Delegate Declaration\npublic delegate void PriceChangedHandler(object sender, PriceChangedEventArgs e);\n• Event Declaration\npublic event PriceChangedHandler PriceChanged;\n• Custom EventArgs: \nPriceChangedEventArgs class extends System.EventArgs by adding two fields LastPrice and NewPrice. When the PriceChanged\nevent is raised, the subscribers learn LastPrice and NewPrice\nclass PriceChangedEventArgs: EventArgs\n\n\nWalkthrough – Prepare the Event Publisher\n• Event-Raising Method\nprotected virtual void OnPriceChanged(PriceChangedEventArgs e)\n{\nif (PriceChanged != null) PriceChanged(this, e);\n}\n• Raise the event: Prior to raising the event you will need to have an instance of your EventArgs subclass \npopulated with event-specific data. \nOnPriceChanged(new PriceChangedEventArgs(oldPrice, price));\n\n\nWalkthrough – Prepare the Event Subscriber\n• Write the Event Handling Method\nstatic void stock_PriceChanged(object sender, PriceChangedEventArgs e)\n{\nif ((e.NewPrice - e.LastPrice) / e.LastPrice > 0.1M)\nConsole.WriteLine(\"Alert, 10% stock price increase!\");\n}\n• Instantiate the Event Publisher.\nStock stock = new Stock(\"CompanyA\");\nstock.Price = 27.10M;\n• Register the subscriber (event handling method) with the event\nstock.PriceChanged += stock_PriceChanged;\n\n\nEvents and Delegates\n• Events in .NET programming are based on delegates. \n• An event can be understood as providing a conceptual wrapper around a \nparticular delegate. \n• The event then controls access to that underlying delegate. \nWhen a client subscribes to an event, the event ultimately registers the subscribing method \nwith the underlying delegate. Then, when the event is raised, the underlying delegate \ninvokes each method that is registered with it. In the context of events, then, delegates act as \nintermediaries between the code that raises events and the code that executes in response —\nthereby decoupling event publishers from their subscribers.\n\n\n"
  },
  {
    "title": "IntroWPF.pdf",
    "url": "https://umsystem.instructure.com/courses/296958/files/32026367/download?verifier=svk5NXPWfuuK4a8GAObQxgqBqf8KSI2lsgKIwqyY&amp;wrap=1",
    "body": "Introduction to WPF\n\n\nXAML\n• XAML: eXtensible Application Markup Language\n• Basic concepts and features around XAML\n• Create a simple WPF (Windows Presentation Foundation) application\n\n\nAn Initial Window \n<Window x:Class=\"FirstWPFApplication.MainWindow\"\nxmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\nxmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\nTitle=\"MainWindow\" Height=\"350\" Width=\"525\">\n<Grid>\n</Grid>\n</Window>\nLet’s take a look at a WPF Initial Window:\n\n\nXAML\n• XAML is XML \nIf you need an overview of XML, you can go here: \nhttp://www.w3schools.com/xml/default.asp\n• XAML Elements are .NET Classes\nboth “<Window>” and “<Grid>” are .NET Classes.\n• XAML Namespaces\nxmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\nxmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n\n\nXAML Code Behind\n<Window x:Class=\"FirstWPFApplication.MainWindow\"\nx:Class attribute references the code behind for this XAML window. \n“x:” means the class attribute come from the XAML namespace noted above. \nThe value of the attribute references the MainWindow class in the \n“FirstWPFApplication” namespace. \nTitle=\"MainWindow\" Height=\"350\" Width=\"525\">\nSimply properties of the Window class\n\n\nThe Grid Element\nFor now, note that the Window element only allows for a single child. \nThis means that if we want to include more than one Control in our \nWindow, we will want to wrap them in some sort of layout control that \nallows multiple children. The Grid is just that sort of control.\n\n\nAttached Properties\nAdd a Button, and a Label under the Grid as:\n<Button Content=\"Button\" HorizontalAlignment=\"Left\" Margin=\"214,59,0,0\"\nVerticalAlignment=\"Top\" Width=\"75\" Click=\"Button_Click_1\"/>\n<Label x:Name=\"theLabel\" Content=\"\" HorizontalAlignment=\"Left\"\nMargin=\"120,142,0,0\" VerticalAlignment=\"Top\" Width=\"261\" Background=\"#FFB3E0F9\" />\n• Button, Label is nested inside the Grid markup \n• Most of the attributes are simply properties of the Label class\n\n\nEvent Handler\n• Specifying an Event Handler in XAML is just the same as setting any \nother Property as an attribute. For our button, we want to hook into the \n“Click” event. \n• Visual Studio IntelliSense helps us out here. Inside the Button tag, \ntype “Click=” and Visual Studio will give you an option to create a \n“New EventHandler”. If you select this, then Visual Studio will \nautomatically create the event handler in the code behind, give it a \nname, and hook it up in the XAML. \n\n\nComments\n• Comments in XAML are marked like XML & HTML comments, with \nthe “   <!-- -->  ” tag.\n\n\nWPF Documentation on MSDN\n• https://msdn.microsoft.com/en-us/library/ms754130(v=vs.110).aspx\n\n\n"
  },
  {
    "title": "LayoutChildren.pdf",
    "url": "https://umsystem.instructure.com/courses/296958/files/32026265/download?verifier=8epXr8azqE6jgW2mshavzqyIIuUTgmW5NUYYvoZU&amp;wrap=1",
    "body": "Sizing, Positioning and \nTranforming Elements\n\n\nWPF Layout\n• Layout – the sizing and positioning of controls (and other elements) is called layout.\nWPF contains a lot of infrastructure to provide a feature-rich layout system.\n• Layout in WPF boils down to interactions between parent elements and their child \nelements. \n• Parent elements that support the arrangement of multiple children are known \nas panels, and they derive from the abstract System.Windows.Controls.Panel class. \n• All the elements involved in the layout process (both parents and children) derive \nfrom System.Windows.UIElement.\n\n\nMain Child Layout Properties\n\n\nControlling Size – Height and Width\n• All FrameworkElements have simple Height and Width properties (type double), \nand MinHeight, MaxHeight, MinWidth, and MaxWidth properties that can be used \nto specify a range of acceptable values. When used together, Height and Width \ntake precedence as long as they are in the range from Min to Max. \n• **Avoid setting explicit sizes! Giving controls explicit sizes, especially \nContentControls such as Button and Label, opens up the risk of cutting off text \nwhen users change system font settings Therefore, you should avoid setting \nexplicit sizes unless absolutely necessary.\n• The default value of MinHeight and MinWidth is 0, and the default value of \nMaxHeight and MaxWidth is Double.PositiveInfinity. \n\n\nControlling Size – Margin\n• Margin controls how much extra space gets placed around the outside \nedges of the element\n\n\nControlling Size – Padding\n• Padding controls how much extra space gets placed around the inside \nedges of the element. \n\n\nControlling Position - Alignment\n• The HorizontalAlignment and VerticalAlignment properties \nenable an element to control what it does with any extra \nspace that its parent panel gives it. Each property has a \ncorresponding enumeration as :\nHorizontalAlignment — Left, Center, Right, and Stretch\nVerticalAlignment — Top, Center, Bottom, and Stretch\n\n\nControlling Position - Alignment\n\n\nControlling Position – Content Alignment\nThe HorizontalContentAlignment and VerticalContentAlignment\nproperties determine how a control’s content fills the space within the \ncontrol.\n\n\nApplying Transforms\n• Built-in 2D transforms, all in the System.Windows.Media namespace:\nRotateTransform\nScaleTransform\nSkewTransform\nTranslateTransform\nMatrixTransform\n\n\nApplying Transforms - RotateTransform\n• RotateTransform, demonstrated in the preceding section, rotates an element \naccording to the values of three double properties:\nAngle—Angle of rotation, specified in degrees (default value = 0)\nCenterX—Horizontal center of rotation (default value = 0)\nCenterY—Vertical center of rotation (default value = 0)\n• The default (CenterX,CenterY) point of (0,0) represents the top-left corner. \n\n\nApplying Transforms - ScaleTransform\n• ScaleTransform enlarges or shrinks an element horizontally, vertically, or in both \ndirections. This transform has four straightforward double properties:\nScaleX—Multiplier for the element’s width (default value = 1)\nScaleY—Multiplier for the element’s height (default value = 1)\nCenterX—Origin for horizontal scaling (default value = 0)\nCenterY—Origin for vertical scaling (default value = 0)\n\n\nApplying Transforms - SkewTransform\n• SkewTransform slants an element according to the values of four double properties:\nAngleX—Amount of horizontal skew (default value = 0)\nAngleY—Amount of vertical skew (default value = 0)\nCenterX—Origin for horizontal skew (default value = 0)\nCenterY—Origin for vertical skew (default value = 0)\n\n\nApplying Transforms - TranslateTransform\n• TranslateTransform simply moves an element according to two double properties:\nX—Amount to move horizontally (default value = 0)\nY—Amount to move vertically (default value = 0)\n\n\nApplying Transforms - TransformGroup\n• TransformGroup is to combine child Transform objects\n\n\n"
  },
  {
    "title": "LayoutPanels.pdf",
    "url": "https://umsystem.instructure.com/courses/296958/files/32026320/download?verifier=GDRxFcFcW61Xg6vdZgb1AaIGKOgUSyXbbeulX7Xb&amp;wrap=1",
    "body": "WPF Panels\n\n\nWPF Panels\nParent elements that support the arrangement of multiple children are \nknown as panels. Here are the commonly used Panels:\n• Grid\n• Canvas\n• StackPanel\n• DockPanel\n\n\nGrid\n• Grid is the most versatile panel. It enables you to arrange its children in a \nmultirow and multicolumn fashion\n\n\nGrid\n• RowSpan and ColumnSpan are set to 1 by default and can be set to any number \ngreater than 1 to make an element span that many rows or columns. \n• adding this to the last GroupBox :   Grid.RowSpan=\"3\"\n• adding this to the Label :  Grid.ColumnSpan=\"2\"\n\n\nGrid - Sizing the Rows and Columns\nAbsolute sizing — Setting Height or Width to a numeric value representing \ndevice-independent pixels (like all other Height and Width values in WPF). Unlike \nthe other types of sizing, an absolute-sized row or column does not grow or shrink \nas the size of the Grid or size of the elements changes.\nAutosizing — Setting Height or Width to Auto, which gives child elements the \nspace they need and no more. For a row, this is the height of the tallest element, \nand for a column, this is the width of the widest element. This is a better choice \nthan absolute sizing whenever text is involved to be sure it doesn’t get cut off \nbecause of different font settings or localization.\nProportional sizing (also called star sizing) —Setting Height or Width to special \nsyntax to divide available space into equal-sized regions or regions based on fixed \nratios. A proportional-sized row or column grows and shrinks as the Grid is \nresized.\n\n\nGrid - Sizing the Rows and Columns\nAutosizing —making the first row and first column size to their content. This \nautosizing can be done by setting the appropriate RowDefinition’s Height and \nColumnDefinition’s Width to the case-insensitive string Auto.\n\n\nGrid - Sizing the Rows and Columns\nProportional sizing —It is done with star syntax that works as follows:\nWhen a row’s height or column’s width is set to *, it occupies all the remaining space.\nWhen multiple rows or columns use *, the remaining space is divided equally between them. \nThe “remaining space” is the height or width of the Grid minus any rows or columns that use \nabsolute sizing or autosizing. \nRows and columns can place a coefficient in front of the asterisk (like 2* ) to take \nproportionately more space than other columns using the asterisk notation. A column with \nwidth 2* is always twice the width of a column with width * (which is shorthand for 1*) in the \nsame Grid.\n\n\nCanvas\n• Canvas is a very basic panel. Only supports the “classic” notion of positioning elements with explicit \ncoordinates. \n• Position elements in a Canvas by using its attached properties: Left, Top, Right, and Bottom. In essence, \nyou choose the corner in which to “dock” each element, and the attached property values serve as margins \n(to which the element’s own Margin values are added). If an element doesn’t use any of these attached \nproperties (leaving them with their default value of Double.NaN), it is placed in the top-left corner of the \nCanvas (the equivalent of setting Left and Top to 0). \n\n\nStackPanel\n• StackPanel is a popular panel because of its simplicity and usefulness. As its name suggests, it \nsimply stacks its children sequentially. \n• With no attached properties for arranging children, only one way to customize the behavior of \nStackPanel—setting its Orientation property to Horizontal or Vertical. Vertical is the default \nOrientation. \n• Example here shows simple Buttons, with no properties set other than Background and Content, in \ntwo StackPanels with only their Orientation set.\n\n\nDockPanel\n• DockPanel enables easy docking of elements to an entire side of the panel, stretching it to fill the entire \nwidth or height. (unlike Canvas, which enables you to dock elements to a corner only.) DockPanel also \nenables a single element to fill all the remaining space unused by the docked elements.\n• DockPanel has a Dock attached, so children can control their docking with one of four possible values: \nLeft (the default when Dock isn’t applied), Top, Right, and Bottom. The last child added to a DockPanel\nfills the remaining space unless DockPanel’s LastChildFill property is set to false. \n\n\n"
  },
  {
    "title": "Controls.pdf",
    "url": "https://umsystem.instructure.com/courses/296958/files/32026373/download?verifier=QpcCEUCfxDhPtd3UiA1um0xyTqYqhGPshNh0Q76r&amp;wrap=1",
    "body": "WPF Controls\n\n\nOverview\nSome commonly used WPF controls include: \n• Buttons\n• CheckBox\n• RadioButton\n• Menu\n• Text\n• TextBox\n• RichTextBox\n• PasswordBox\n• Image\n\n\nButtons\n• The Button class inherits directly from the \nSystem.Windows.Controls.Primitives.ButtonBase class\n• Click Event: \nThe ButtonBase class contains the Click event and the logic that defines what it means \nto be clicked. As with typical Windows buttons, a click can occur from a mouse’s left \nbutton being pressed down and then let up or from the keyboard with Enter or spacebar, \nif the button has focus.\n•\nIts ClickMode property can be set to a value of a ClickMode enumeration \nof Release (the default), Press, and Hover\n\n\nButtons Example\nThree buttons respond to \nclicks in three different ways.\n•Hover: the first button changes \ncolors when the user hovers with \nthe mouse over the button.\n•Press: the second button \nrequires that the mouse be \npressed while the mouse pointer \nis over the button.\n•Release: the third does not reset \nthe background color of the \nbuttons until the mouse is \npressed and released on the \nbutton.\n\n\nCheckbox\n•\nIt has a notion of being clicked by mouse or keyboard.\n•\nIt retains a state of being checked or unchecked when clicked.\n•\nIt supports a three-state mode, where the state toggles from checked to \nindeterminate to unchecked.\n\n\nCheckbox Example\nA CheckBox and handles \nthe Checked, Unchecked, \nand Indeterminate events.\n\n\nRadio Button\n•\nA RadioButton has two states: true or false. The RadioButton is a control that is \nusually used as an item in a group of RadioButton controls. However, it is possible \nto create a single RadioButton. Whether a RadioButton is selected is determined \nby the state of its IsChecked property.\n•\nWhen a RadioButton is selected, it cannot be cleared by clicking it. \n•\nWhen RadioButton elements are grouped, the buttons are mutually exclusive. \nA user can select only one item at a time within a RadioButton group. You can group RadioButton\ncontrols by placing them inside a parent or by setting the GroupName property on each RadioButton.\n\n\nRadio Button Example\nCreate RadioButton controls, group them inside a container, and handle the Checked event..\n\n\nMenu\nMenu Class doc: https://msdn.microsoft.com/en-us/library/system.windows.controls.menu(v=vs.110).aspx\n\n\nTextBox\n•\nEnables users to type one or more lines of text. TextBox stores it in a string property called Text.\n• Defines TextChanged and SelectionChanged events.\n• To enable spell checking in a TextBox (or RichTextBox), you set the attached SpellCheck.IsEnabled\nproperty to true\n• Make the text wrap to form additional lines by setting its TextWrapping property to Wrap or \nWrapWithOverflow.\n• RichTextBox - a more advanced TextBox that can contain formatted text and arbitrary objects \nembedded in the text\n• PasswordBox - a simpler TextBox designed for the entry of a password\n\n\nImage\n• System.Windows.Controls.Image enables images (.BMP, .PNG, .GIF, \n.JPG, and so on) to be rendered in a WPF user interface. \n\n\n"
  },
  {
    "title": "Enum_Struct.pdf",
    "url": "https://umsystem.instructure.com/courses/296958/files/32026325/download?verifier=FJ39y4vVc15qoMjFX0Zpw5LNj223ac6hiCtc4ngC&amp;wrap=1",
    "body": "Enumeration and Structure \nType\n\n\nEnums\n• An enumeration is a set of named integer constants. \n• An enumerated type is declared using the enum keyword.\n• Creates a list of compile-time constants\n• Strongly typed\n• Example:\n• Doc -\nhttps://msdn.microsoft.com/en-us/library/system.enum(v=vs.110).aspx\npublic enum Color\n{\nRed,\nGreen,\nBlue\n}\n\n\nDeclaring enum Types\n• Declares a new type - derived from System.Enum, derived from ValueType\n• Every enum type has a corresponding integral underlying-type\n• default underlying type is int\n• underlying type cannot be char\n• enums of different types require an explicit cast to convert between instances, even if the \nunderlying type is the same\n• Declaring an enum with a different underlying type:\npublic enum Color : ulong\n{\nRed,\nGreen,\nBlue\n}\n\n\nEnum members\n• Each member must be named uniquely\n• Each member has a value of the underlying type\n• You may set values for the enum members\n• Different members may have the same value\n• If you do not assign values, default values are assigned as follows:\n• If the first enum member has no assigned value, it defaults to 0\n• enum members after the first are assigned 1 + the value of the preceding member\npublic enum Color\n{\nRed, // is assigned 0\nGreen = 10,\nBlue // is assigned 11\n}\n\n\nEnum Members in an Enum\n• You may refer to an enum member inside the enum declaration:\n• But, the reference may not result in a circular reference:\npublic enum Color\n{\nRed, \nGreen = 10,\nBlue,\nMax = Blue\n}\npublic enum Circular\n{\nA = B, // this won’t work\nB\n}\n\n\nUsing an enum Instance\nenum Color\n{\nRed,\nBlue,\nGreen\n}\nclass MyClass\n{\nprivate Color color = Color.Red;\nprivate int GetIntFromColor()\n{\nreturn (int)color;\n}\nprivate string GetColorName()\n{\nreturn color.ToString();\n}\n}\n\n\nSystem.Enum\n• Instance functions:\n• string ToString()\n• int GetHashCode()\n• Static functions:\n• string GetName(Type enumtype, object value)\n• string[] GetNames(Type enumtype)\n• Type GetUnderlyingType(Type enumtype)\n• Array GetValues(Type enumtype)\n• bool IsDefined(Type enumtype, object value)\n• object Parse(Type enumtype, string value)\nHandy in helping convert the string to enumerated constants\n\n\nStruct\n• In case the Class contains so little data, it is better to define the type as \na structure.\n• A structure is a value type. \n• Because structures are stored on the stack, as long as the structure is \nreasonably small, the memory management overhead is often reduced.\n• Struct can have fields, methods and constructors\n• The primitive numeric types (int, float etc) use struct.\n• Doc - https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/using-structs\n\n\nPrimitive Types Using Struct and Class\n\n\nDeclaring a struct\nstruct Date\n{\nprivate int year;\nprivate Month month;\nprivate int day;\npublic Date(int ccyy, Month mm, int dd)\n{\nthis.year = ccyy - 1900;\nthis.month = mm;\nthis.day = dd - 1;\n}\npublic override string ToString()\n{\nstring data = $\"{this.month} {this.day + 1} {this.year + 1900}\";\nreturn data;\n}\npublic void AdvanceMonth()\n{\nthis.month++;\nif(this.month == Month.December + 1)\n{\nthis.month = Month.January;\nthis.year++;\n}\n}\n}\n\n\nDifferences between Structures and Classes\n• Struct can’t declare a default constructor\n• In a class, you can initialize instance fields at their point of declaration. \nIn a structure, you cannot. \nYou can initialize struct members only by using a parameterized constructor or by accessing the\nmembers individually after the struct is declared. Any private or otherwise inaccessible\nmembers can be initialized only in a constructor.\n\n\nDifferences between Structures and Classes\n\n\nSome Struct Rules\nStructs share most of the same syntax as classes, although structs are more \nlimited than classes:\n• Within a struct declaration, fields cannot be initialized unless they are declared as const or static.\n• A struct cannot declare a default constructor (a constructor without parameters).\n• Structs are copied on assignment. When a struct is assigned to a new variable, all the data is \ncopied, and any modification to the new copy does not change the data for the original copy\n• Structs are value types and classes are reference types.\n• Unlike classes, structs can be instantiated without using a new operator.\n• Structs can declare constructors that have parameters.\n• A struct cannot inherit from another struct or class, and it cannot be the base of a class. All structs\ninherit\n• directly from System.ValueType , which inherits from System.Object .\n• A struct can implement interfaces.\n• A struct can be used as a nullable type and can be assigned a null value.\n\n\n"
  },
  {
    "title": "ValueRefType.pdf",
    "url": "https://umsystem.instructure.com/courses/296958/files/32026262/download?verifier=jYBGrWwoxrquF16EmE6rSsNUWRafsyLBFOnw89WL&amp;wrap=1",
    "body": "Value and Reference Types\n\n\nValue Types and Reference Types\n• The data types in C# and the .NET Framework fall into two \ncategories: values types and reference types\n• A variable that is used to hold a value, such as 23, 15.87, “Hello”, etc. \nis a value type of variable\n• They actually hold data\n• A variable that is used to reference an object is commonly called a \nreference variable \n• Reference variables can be used only to reference objects. They do \nnot hold data.\n\n\nHow a Value Type Works\n• When you declare a value type variable, the compiler allocates a \nchunk of memory that is big enough for the variable \n• The memory that is allocated for a value type variable is the actual \nlocation that will hold the value assigned to the variable\n• When you are working with a value type, you are using a variable that \nholds a piece of data\n• Value type of variable actually holds the data\n\n\nHow a Reference Type Works\n• When you work with a reference type, you use two things:\n• An object that is created in memory\n• A variable that references the object\n• The object that is created in memory holds data. You need a way to refer to it.\n• A variable is then created to hold a value called reference\n• A reference variable does not hold an actual piece of data, it simply refers to \nthe data\n• A reference type links the variable that holds actual data to the object\n• If a kite is the object, then the spool of string that holds the site is the reference\n\n\nCreating a Reference Type\n• Two steps are typically required:\n• Declare a reference variable\n• Create an object and associate it with the reference variable\n• An example is the Random class\nRandom rand = new Random();\n• The “Random rand” part declares a variable named “rand”\n• The “new Random()” part creates an object and returns a reference to the object\n• The = operator assigns the reference that was returned from the new operator to the rand\nvariable\nRandom \nobject\nrand\n\n\n"
  },
  {
    "title": "String.pdf",
    "url": "https://umsystem.instructure.com/courses/296958/files/32026319/download?verifier=IDxTYbt7iQT36ct2JcLURYbbE1AepB6S7lWazyn6&amp;wrap=1",
    "body": "Strings\n\n\nString Concatenation\nstring a = \"Hello\";\nstring b = a + \" World\"; // Hello World\na += \" World\";           // Hello World\n\n\nSpecial Characters\nCharacter Meaning\nCharacter Meaning\n\\n\nnewline\n\\f\nform feed\n\\t\nhorizontal tab\n\\a\nalert sound\n\\v\nvertical tab\n\\’\nsingle quote\n\\b\nbackspace\n\\”\ndouble quote\n\\r\ncarriage return\n\\\\\nbackslash\n\\0\nnull character\n\\uFFFF\nUnicode character (4-digit hex number)\nBackslash notation is used to write special characters\nstring e = \"c:\\\\Windows\\\\System32\\\\cmd.exe\";\nstring f = @\"c:\\Windows\\System32\\cmd.exe\";\n\n\nStrings \nstring a = \"String\";\nstring b = a.Replace(\"i\", \"o\"); // Strong\nb = a.Insert(0, \"My \");  // My String\nb = a.Remove(0, 3);      // ing\nb = a.Substring(0, 3);   // Str\nb = a.ToUpper();         // STRING\nint i = a.Length;            // 6\n*Note: there are no methods for changing a string. Methods that appear to modify a string \nactually always return a completely new string. This is because the string class is immutable. \nThe content of a string variable cannot be changed, unless the whole string is replaced.\n\n\nStringBuilder Class\nSystem.Text.StringBuilder sb = new System.Text.StringBuilder(\"Hello\");\nsb.Append(\" World\");   // Hello World\nsb.Remove(0, 5);       // World\nsb.Insert(0, \"Bye\");   // Bye World\nstring s = sb.ToString(); // Bye World\n• StringBuilder is a mutable string class. Because of the performance cost associated \nwith replacing a string, the StringBuilder class is a better alternative when a string \nneeds to be modified many times.\n\n\nComposite Formatting\n• Each format item takes the following form and consists of the \nfollowing components:\n{ index[,alignment][:formatString]}\nstring myName = \"Fred\"; \nString.Format(\"Name = {0}, hours = {1:hh}\", myName, DateTime.Now);\n• Doc - http://msdn.microsoft.com/en-us/library/txafckwd(v=vs.110).aspx\n\n\nCustom DateTime Formatting\n• Code Example: ILoveDatesandTimes.zip\n• There are following custom format specifiers y (year), M (month), d \n(day), h (hour 12), H (hour 24), m (minute), s (second), f (second \nfraction), F (second fraction, trailing zeroes are trimmed), t (P.M or \nA.M) and z (time zone).\n• You can use also date separator / (slash) and time sepatator : (colon). \nThese characters will be rewritten to characters defined in the current \nDateTimeFormatInfo.DateSeparator and DateTimeForma-\ntInfo.TimeSeparator.\n\n\nStandard DateTime Formatting\nSpecifier\nDateTimeFormatInfo property\nPattern value (for en-US culture)\nt\nShortTimePattern\nh:mm tt\nd\nShortDatePattern\nM/d/yyyy\nT\nLongTimePattern\nh:mm:ss tt\nD\nLongDatePattern\ndddd, MMMM dd, yyyy\nf\n(combination of D and t)\ndddd, MMMM dd, yyyy h:mm tt\nF\nFullDateTimePattern\ndddd, MMMM dd, yyyy h:mm:ss \ntt\ng\n(combination of d and t)\nM/d/yyyy h:mm tt\nG\n(combination of d and T)\nM/d/yyyy h:mm:ss tt\nm, M\nMonthDayPattern\nMMMM dd\ny, Y\nYearMonthPattern\nMMMM, yyyy\nr, R\nRFC1123Pattern\nddd, dd MMM yyyy HH':'mm':'ss \n'GMT' (*)\ns\nSortableDateTimePattern\nyyyy'-'MM'-'dd'T'HH':'mm':'ss (*)\nu\nUniversalSortableDateTimePat-\ntern\nyyyy'-'MM'-'dd HH':'mm':'ss'Z' (*)\n(*) = culture independent\n\n\n"
  },
  {
    "title": "Exceptions.pdf",
    "url": "https://umsystem.instructure.com/courses/296958/files/32026327/download?verifier=c3Y7qmQv513hi0yTIly9TGs1I8gUOj5CqDEXdIiF&amp;wrap=1",
    "body": "Exceptions\n\n\nIntroduction\n• An exception is an indication of a problem that occurred during a \nprogram’s execution.\n• Exception handling enables you to create apps that can handle \nexceptions—in many cases allowing a program to continue executing \nas if no problems were encountered. \n• Exception handling enables you to write clear, robust and more fault-\ntolerant programs.\n\n\nExceptions \n• Some circumstances are beyond programmer’s control \n• You have assumed nothing unusual would occur \n• Have probably experienced unhandled exceptions being thrown\n• Unless provisions are made for handling exceptions, your program \nmay crash or produce erroneous results\n• Unhandled exception\n\n\nRaising an Exception \n• Error encountered – no recovery \n• Raise or throw an exception \n• Execution halts in the current method and the Common Language Runtime \n(CLR) attempts to locate an exception handler \n• Exception handler: block of code to be executed when a certain type of \nerror occurs \n• If no exception handler is found in current method, exception is thrown back \nto the calling method \n\n\nException-Handling Techniques\n• If event creates a problem frequently, best to use conditional \nexpressions to catch and fix problem\n• Execution is slowed down when CLR has to halt a method and find an \nappropriate event handler\n• Exception-handling techniques are for serious errors that occur \ninfrequently \n• Exceptions classes integrated within the Framework Class Library \n• Used with the try…catch…finally program constructs \n\n\nTry…Catch…Finally Blocks\n• Code that may create a problem is placed in the try block \n• Code to deal with the problem (the exception handler) is placed in \ncatch blocks \n• Catch clause\n• Code to be executed whether an exception is thrown or not is placed in \nthe finally block \n\n\ntry\n{\n// Statements \n}\ncatch [ (ExceptionClassName exceptionIdentifier) ]\n{\n// Exception handler statements \n}\n:    // [additional catch clauses]\n[ finally\n{\n// Statements\n} ]\nNotice square \nbrackets indicate \noptional entry\nOne catch \nclause \nrequired\nfinally clause \noptional\n\n\nTry…Catch…Finally Blocks \n• Generic catch clause\n• Omit argument list with the catch\n• Any exception thrown is handled by executing code within that catch block \n• Control is never returned into the try block after an exception is \nthrown \n• Using a try…catch block can keep the program from terminating \nabnormally \n\n\nfinally Block\n• Programs frequently request and release resources dynamically.\n• Operating systems typically prevent more than one program from \nmanipulating a file.\n• Therefore, the program should close the file\n(i.e., release the resource) so other programs can use it.\n• If the file is not closed, a resource leak occurs.\n\n\nfinally Block\nMoving Resource-Release Code to a finally Block\n•Exceptions often occur when an app processes resources that require explicit \nrelease.\n•Regardless of whether a program experiences exceptions, the program \nshould close the file when it is no longer needed.\n•C# provides the finally block, which is guaranteed to execute regardless of \nwhether an exception occurs.\n•This makes the finally block ideal to release resources from the \ncorresponding try block.\n• Local variables in a try block cannot be accessed in the corresponding \nfinally block, so variables that must be accessed in both should be declared \nbefore the try block. \n\n\nBuilt-in Exceptions\n\n\n\n\nFiltering Multiple Exceptions \n• Can include multiple catch clauses \n• Enables writing code specific to thrown exception\n• Should be placed from most specific to the most generic  \n\n\n"
  },
  {
    "title": "Classes.pdf",
    "url": "https://umsystem.instructure.com/courses/296958/files/32026337/download?verifier=rf5D03dYKWlyt4bkHipLZa65mpZM9Zutlnw2q5Df&amp;wrap=1",
    "body": "Classes and Objects\n\n\nPillars of OOP\n• Encapsulation\nEncapsulate the inner details of implementation\nProtect data\n• Inheritance\nBuild new class based on existing class definitions\nEmbody the is-a relationship between types\n• Polymorphism\nTreat the related objects in the same way\n\n\nIntroduction to Classes\n• A class is a group of related methods and variables. \n• A class is the blueprint for an object. \n• It describes a particular type of object, yet it is not an object.\n• It specifies the fields and methods a particular type of object can have.\n• One or more object can be created from the class.\n• Each object created from a class is called an instance of the class.\n\n\nCreating a Class\n• You can create a class by writing a class declaration. A generic form is:\nclass ClassName\n// class header\n{\nMember declaration(s)…\n}\n• Class headers starts with the keyword class, followed by the name of the class.\n• Member declarations are statements that define the class’s fields, properties, and/or methods.\n• A class may contains a constructor, which is special method automatically executed when an \nobject is created.\n\n\nSample\nclass Coin\n{\nprivate string sideUp; // field\npublic Coin() // constructor\n{\nsideUp = “Heads”;\n}\npublic void Toss() // a void method\n{\nMessageBox.Show(sideUp);\n}\npublic string GetSideUp() // a value-returning method\n{\nreturn sideUp;\n}\n}\n\n\nCreating an Object\n• Given a class named Coin, you can create a Coin object use:\nCoin myCoin = new Coin();\n• where,\n•myCoin is a variable that references an object of the Coin class;\n•the new keyword creates an instance of the Coin class; and\n•the = operator assigns the reference that was returned from the new operator to the myCoin\nvariable.\n• Once a Coin object is created, you can access members of the class with it. E.g.\nmyCoin.Toss();\n\n\nWhere to Write Class Declarations\n\n\nPassing an Object to a Method\n• Objects of a class can be used as parameter of a method. E.g.\nprivate void ShowCoinStatus(Coin coin)\n{\nMessageBox.Show(“Side is “ + coin.GetSideUp());\n}\n• In this example, a method named ShowCoinStatus accepts a Coin object as an \nargument.\n• To create a Coin object and pass it as an argument to the ShowCoinStatus method, \nuse:\nCoin myCoin = new Coin();\nShowCoinStatus(myCoin);\n\n\nProperties\n• A property is a class member that holds a \npiece of data about an object.\n• Properties can be implemented as special \nmethods that set and get the value of \ncorresponding fields.\n• Both set and get methods are known \nas accessors.\n• In the code, there is a private field (_name)\nwhich is a known as field and is\nused to hold any data assigned to the\nName property.\n• The value parameter of set accessor is \nautomatically created by the compiler.\nclass Pet\n{\nprivate string _name; // field\npublic Pet() \n{\n_name = “”;\n}\npublic string Name\n{\nget\n{\nreturn _name;\n}\nset\n{\n_name = value;\n}\n}\n}\n\n\nField\n• The private field is a variable that stores a value assigned to the \nproperty which the backing fields is associated with.\n• It is declared to be private to protect it from accidental corruption.\n• If a field is public, it can then be accessible directly by code outside \nthe class without the need for accessors. \n\n\nget vs set Accessors\n• The get accessor, if not empty, is a method that returns the property’s \nvalue because it has a return statement.\n• It is executed whenever the property is read.\n• The set accessor, if not empty, gets the value and assigns the value to \nthe property\n• It has an implicit parameter named value.\n• It is executed whenever a value is assigned to the property.\n\n\nRead-Only Properties\n• A read-only property can be read, but it cannot be modified.\n• To set a read-only property, simply do no write a set accessor for the property. E.g.\n// read and write\npublic double Diameter\n{\nget { return _diameter; }\nset { _diameter = value; }\n}\n// read \npublic double Diameter\n{\nget { return _diameter; }\n}\n\n\nParameterized Constructor & Overloading\n• A constructor that accepts arguments is known as parameterized constructor. E.g.\npublic BankAccount(decimal startingBalance) { }\n• A class can have multiple versions of the same method known as overloaded methods.\n• How does the compiler know which method to call?\n• Binding relies on the signature of a method which consists of the method’s name, the data \ntype, and argument kind of the method’s parameter. E.g.\npublic BankAccount(decimal startingBalance) { }\npublic BankAccount(double startingBalance) { }\n•\nThe process of matching a method call with the correct method is known as binding.\n\n\nRecall: Overloading Methods\n• When a method is overloaded, it means that multiple methods in the same class \nhave the same name but use different types of parameters.\npublic void Deposit(decimal amount) { }\npublic void Deposit(double amount) { } // overloaded\npublic void Deposit(int numbers) { } // overloaded\npublic void Deposit(string names) { } // overloaded\n\n\nOverloading Constructors\n• Constructors are special type of methods. They can also be overloaded.\npublic BankAccount() { } // parameterless constructor\npublic BankAccount(decimal startingBalance) { } // overloaded\npublic BankAccount(double startingBalance) { } // overloaded\n• The parameterless constructor is the default constructor\n• Compiler will find the matching constructors automatically. E.g.\nBankAccount account = new BankAccount();\nBankAccount account = new BankAccount(500m);\n\n\nDefault Values of the Fields \n• When an object is created all of the fields are initialized with their respective default values in \n.NET, if they are not explicitly initialized with some other value. \nType of the Field \nDefault Value \nbool\nfalse \nbyte \n0 \nchar \n'\\0' \ndecimal \n0.0M \ndouble \n0.0D \nfloat \n0.0F \nint\n0 \nobject reference \nnull \n• Unlike fields, local variables are not initialized with default values when they are declared. \n\n\nField - constants\n• The fields, declared as const or readonly are called constants. \npublic class ConstAndReadOnlyExample\n{ \npublic const double PI = 3.1415926535897932385; \npublic readonly double Size; \npublic ConstAndReadOnlyExample(int size) \n{ \nthis.Size = size; // Cannot be further modified! \n} \n…\n}\nConsole.WriteLine(ConstAndReadOnlyExample.PI); \nConstAndReadOnlyExample instance = new ConstAndReadOnlyExample(5); \nConsole.WriteLine(instance.Size); \n\n\nReusing Constructors \n• Syntax\n[<modifiers>] <class_name>([<parameters_list_1>]) \n: this([<parameters_list_2>]) \npublic class Person\n{\npublic Person()\n{\n}\npublic Person(String name)\n: this(name, 0, 0)\n{\n}\npublic Person(String name, int age)\n: this(name, age, 0)\n{\n}\npublic Person(String name, int age, float salary)\n{\nthis.Name = name;\nthis.Age = age;\nthis.Salary = salary;\n}\npublic String Name { get; set; }\npublic int Age { get; set; }\npublic float Salary { get; set; }\n}\n\n\nStatic Members \n• Static elements of the class can be used without creating an object of \nthe given class. \n• What are they used for, i.e.\n- Math method\n- Instance counter\n\n\nNaming and Accessibility\n• The following recommendations are reasonably common; however, \nC# does not enforce these rules:\n• Identifiers that are public should start with a capital letter. This system \nis known as the PascalCase naming scheme (because it was first used \nin the Pascal language).\n• Identifiers that are not public (which include local variables) should \nstart with a lowercase letter. This system is known as the camelCase\nnaming scheme.\n*Some organizations use camelCase only for methods and adopt the convention that private fields are \nnamed starting with an initial underscore character, such as _radius. \n* one exception to this rule: class names should start with a capital letter, and constructors must \nmatch the name of their class exactly; therefore, a private constructor must start with a capital letter.\n\n\n"
  },
  {
    "title": "Loops.pdf",
    "url": "https://umsystem.instructure.com/courses/296958/files/32026355/download?verifier=IuH6q4ABZv09TZTScTC4Uu5Nsm5TlI6H9Q6H2Z98&amp;wrap=1",
    "body": "C# Basics\nLoops\n\n\nTopics\n• Four Types of Loops\n– while\n– do…while\n– for\n– foreach\n• Jump Statements in Loops\n– break\n– continue\n3\n\n\nFour Types of Loops\n• while\n– The most basic loop\n– Checks a condition before each loop; loops if it's true\n• do…while\n– Checks a condition after each loop; loops if it's true\n• for\n– Most common loop structure\n– A loop structure that contains three separate statements\n• foreach\n– Automatic for loop for enumerable collections\n4\n\n\nFour Types of Loops\nwhile\n– The most basic loop\n– Checks a condition before each loop; loops if it's true\nwhile (true) {         \nprint( \"Loop\" );   \n}                      \n– This will cause an infinite loop!!!\n– \"Loop\" will never appear in the Console pane because the entire Unity process will be frozen\n– This would necessitate force quitting Unity\n– On old, single-threaded computers, this would require turning the computer off!\n5\n\n\nFour Types of Loops\n• while – A better while loop\n– while loops need an exit condition\n• A condition that will cause the condition to evaluate to false\n– Checks a condition before each loop; loops if it's true\nint i=0;\nwhile ( i<3 ) {\nprint( \"Loop: \"+i );\ni++;      // Increment operator\n}                     \n– i++ will increment i on every pass through the loop\n– When i reaches 3, the conditional clause will evaluate to false, and the loop will exit\n6\n\n\nFour Types of Loops\n• do…while\n– Like a while loop, but checks after the loop has run\n• This allows a guarantee that the loop will run at least once\n– Checks a condition after each loop; loops if it's true\nint i=5;\ndo {\nprint( \"Loop: \"+i );\ni++;      // Increment operator\n} while (i<3);                    \n– When execute the loop once before checking the conditional clause and then exiting\n– Note the semicolon after the while clause\n7\n\n\nFour Types of Loops\nfor\n– A for loop contains three separate clauses\nfor (int i=0; i<3; i++) {\nprint( \"Loop: \"+i );\n}\n– Initialization clause:\nint i=0;\n– Condition clause:\ni<3;\n– Iteration clause:\ni++\n– The i variable only exists within the for loop\n• It is scoped to the for loop\n– The iteration clause doesn't have to be ++\n• i-- is another common option for counting down instead of up\n8\n\n\nJump Statements Within Loops\nJump statements change the execution of a loop\n– break\n• Breaks out of the loop entirely\n– continue\n• Breaks out of this iteration of the loop and moves on to the next\n9\n\n\nJump Statements Within Loops\nbreak\n– Breaks out of the loop completely\nstring str = \"Hello\";\nforeach (char chr in str) {\nif (chr == 'l') {\nbreak;\n}\nprint( chr );\n}\n– This will print:\nH\ne\n– Once chr becomes 'l', it will break out of the loop\n– Can be used on any kind of loop\n10\n\n\nJump Statements Within Loops\ncontinue\n– Breaks out of the loop completely\nstring str = \"Hello\";\nforeach (char chr in str) {\nif (chr == 'l') {\ncontinue;\n}\nprint( chr );\n}\n– This will print:\nH\ne\no\n– When chr is 'l', the loop continues without printing\n11\n\n\n"
  },
  {
    "title": "Method.pdf",
    "url": "https://umsystem.instructure.com/courses/296958/files/32026340/download?verifier=beI976j7zPuef8AJ8iBNLg3I9vbvOIODE880pCEr&amp;wrap=1",
    "body": "C# Basics\nMethods\n\n\nIntroduction to Methods\n• Methods can be used to break a complex program into small, \nmanageable pieces\n• This approach is known as divide and conquer\n• In general terms, breaking down a program to smaller units of \ncode, such as methods, is known as modularization\n• Two types of methods are:\n• A void method simply executes a group of statements and then \nterminates\n• A value-returning method returns a value to the statement that \ncalled it\n\n\nThe Method Header\n• A method header has the following parts :\n• Access modifier: keywords that defines the access control\n• private: a private method can be called only by code inside the same class \nas the method\n• public: a public method can be called by code that is outside the class.\n• Return type: specifies whether or not a method returns a value\n• Method name: the identifier of the method; must be unique in a given \nprogram. Use Pascal case \n• Parentheses: A method’s name is always followed by a pair of parentheses\nprivate void DisplayMessage()\n{\nMessageBox.Show(“This is the DisplayMessage method.”);\n}\nAccess \nmodifier\nReturn\ntype\nMethod\nname\nParentheses\n\n\nCalling a Method\n• A method executes when it is called\n• Event handlers are called when specific events take place. Yet, methods are \nexecuted by method call statements.\n• A method call statement is the name of the method followed by a pair of \nparentheses. For example,\n• DisplayMessage();\nprivate void goButton_Click(object sender, EventArgs e)\n{\nMessageBox.Show(“This is the goButton_Click method.”);\nDisplayMessage();\n}\nprivate DisplayMessage()\n{\nMessageBox.Show(“This is the DisplayMessage method.”);\n}\n\n\nPassing Arguments to Methods\n• An argument is any piece of data that is passed into a method when the method is \ncalled\n• In the following, the statement calls the MessageBox.Show method and passes the string “Hello” as \nan argument:\nMessageBox.Show(“Hello”);\n• A parameter is a variable that receives an argument that is passed into a method \n• In the following, value is an int parameter:\nprivate void DisplayValue(int value)\n{\nMessageBox.Show(value.ToString());\n}\n• An argument’s data type must be assignment compatible with the receiving \nparameter’s data type\n\n\nMethods Parameters\n• Some functions have no parameters\npublic void CountUpdates() { … }\n• Others can have several parameters\n– e.g., float f0 and float f1 below\npublic void PrintSum( float f0, float f1 ) {\nprint( f0 + f1 );\n}\n• Parameters define the type and number of arguments that must be \npassed in when the function is called\nPrintSum( 4f, 10.5f );\n// Prints: \"14.5\"\n10\n\n\nThe params Keyword\nparams can be used to accept a variable number of similarly-typed \nparameters or an array of parameters\npublic float Sum( params float[] nums ) {\nfloat total = 0;\nforeach (float f in nums) {\ntotal += f;\n}\nreturn( total );\n}\nvoid Awake() {\nprint( Sum( 1f ) );\n// Prints: \"1f\"\nprint( Sum( 1f, 2f ) );\n// Prints: \"3f\"\nprint( Sum( 1f, 2f, 3f ) );\n// Prints: \"6f\"\nprint( Sum( 1f, 2f, 3f, 4f ) );\n// Prints: \"10f\"\n}\n– An array can also be passed into a params parameter\nprint( Sum( new float[] { 1f, 3.14f } ) );\n// Prints: \"4.14f\"\n12\n\n\nNamed Arguments\n• C# allows you to specify which parameter an argument should be passed into. The syntax is:\nparameterName : value\n• An argument that is written using this syntax is known as a named argument\nprivate void showButton_Click(object sender, EventArgs e)\n{\nshowName(lastName : “Smith”, firstName : “Suzanne”);\n}\nprivate void ShowName(string firstName, string lastName)\n{\nMessageBox.Show(firstName + “ “ + lastNmae);\n}\n• Notice that you get the same result if the call statement is:\nshowName(“Suzanne”, “Smith”);\n\n\nDefault Arguments\n• C# allows you to provide a default argument for a method parameter\nprivate void ShowTax(decimal price, decimal taxRate = 0.07m) \n{ \ndecimal tax = price * taxRate;\n}\n• The value of taxRate is defaulted to 0.07m. You can simply call the method by passing \nonly the price. Parameters are optional when a default value is specified as part of a \ndeclaration.\nshowTax(100.0m);\n• You can also override the default argument\nshowTax(100.0m, 0.08m);\n\n\nNamed Arguments and Optional Parameters\n\n\nPassing Arguments by Reference\n• A reference parameter is a special type of parameter that does not receive a copy of the \nargument’s value\n• It becomes a reference to the argument that was passed into it\n• When an argument is passed by reference to a method, the method can change the value of the \nargument in the calling part of the program\n• In C#, you declare a reference parameter by writing the ref keyword before the parameter \nvariable’s data type\nprivate void SetToZero(ref int number)\n{\nnumber =0;\n}\n• To call a method that has a reference parameter, you also use the keyword ref before the argument\nint myVar = 99;\nSetToZero(ref myVar);\n\n\nThe Return Statement\n• There must be a return statement inside the method which is usually \nthe last statement of the method. This return statement is used to return \na value to the statement that called the method. For example,\nprivate int sum(int num1, int num2)\n{\nreturn num1 + num2;\n}\n• Notice that the returned value and the method’s type must match\n•In the above example, the method is an int method, so it can only return int value\n\n\nReturning Values\n• Many methods return void\nvoid Update() { … }\npublic void CountUpdates() { … }\n• It's possible to return a single value from a method\n– The type of that value is the type of the method\npublic float Sum( float f0, float f1 ) {\nfloat f01 = f0 + f1;\nreturn( f01 );\n// Returns the float f01\n}\nvoid Update() {\nfloat s = Sum( 3f, 0.14159f );\nprint( s );\n// Prints: \"3.14159\"\n}\n• A method can be declared with any return type!\npublic GameObject FindTheGameObject() { … }\n18\n\n\nReturning Values\nSometimes, you want to use return even when the return type is void\npublic List<GameObject> reallyLongList; // A List of many GObjs\npublic void MoveByName( string name, Vector3 loc ) {\nforeach (GameObject go in reallyLongList) {\nif (go.name == name) {\ngo.transform.position = loc;\nreturn;  // Returns to avoid looping over the whole List\n}\n}\n}\nvoid Awake() {\nMoveByName( \"Archon\", Vector3.zero );\n}\n– If \"Phil\" is the first GameObject in the List, returning could save lots of time!\n19\n\n\nMethod Overloading\nThe same function name can be defined several times with different \nparameters\nThis is called function overloading\npublic float Sum( float f0, float f1 ) {\nreturn( f0 + f1 );\n}\npublic Vector3 Sum( Vector3 v0, Vector3 v1 ) {\nreturn( v0 + v1 );\n}\npublic Color Sum( Color c0, Color c1 ) {\nfloat r, g, b;\nr = Mathf.Min( c0.r + c1.r, 1f ); // Limits r to less than 1\ng = Mathf.Min( c0.g + c1.g, 1f );\nb = Mathf.Min( c0.b + c1.b, 1f ); // Because Color values\na = Mathf.Min( c0.a + c1.a, 1f ); //   are between 0f and 1f\nreturn( new Color( r, g, b, a ) );\n}\n20\n\n\nMethods Overloading \n• Method signature: name and parameter types, number, and order (not the \nname, return type)\nint DoSomething (int a, int b) {}\nThe signature is DoSomthing(int, int)\n• Overloading methods: have multiple methods with the same name, as long \nas the signatures are different\nvoid Foo (int x) {...}\nvoid Foo (double x) {...}\nvoid Foo (int x, float y) {...}\nvoid Foo (float x, int y) {...}\nfloat Foo (int x) {…}  // error\n\n\nNaming Conventions\n• Functions should always be named with CamelCaps\n• Function names should always start with a capital letter\nvoid Awake() { … }\nvoid Start() { … }\npublic void PrintSum( float f0, float f1 ) { … }\npublic float Sum( float f0, float f1 ) { … }\npublic void MoveByName( string name, Vector3 loc ) { … }\n• Declaring Method Inside a Class - Methods usually belong to a class\n22\n\n\n"
  },
  {
    "title": "ArrayList.pdf",
    "url": "https://umsystem.instructure.com/courses/296958/files/32026336/download?verifier=1bKJVckTf5sJ5mOPWPyeXbapZDMC862FQQ3AoAqP&amp;wrap=1",
    "body": "C# Basics\nArray & List\n\n\nValue Types and Reference Types\n• The data types in C# and the .NET Framework fall into two \ncategories: values types and reference types\n• A variable that is used to hold a value, such as 23, 15.87, “Hello”, etc. \nis a value type of variable\n• They actually hold data\n• A variable that is used to reference an object is commonly called a \nreference variable \n• Reference variables can be used only to reference objects. They do \nnot hold data.\n\n\nHow a Value Type Works\n• When you declare a value type variable, the compiler allocates a \nchunk of memory that is big enough for the variable \n• The memory that is allocated for a value type variable is the actual \nlocation that will hold the value assigned to the variable\n• When you are working with a value type, you are using a variable that \nholds a piece of data\n• Value type of variable actually holds the data\n\n\nHow a Reference Type Works\n• When you work with a reference type, you use two things:\n• An object that is created in memory\n• A variable that references the object\n• The object that is created in memory holds data. You need a way to refer to it.\n• A variable is then created to hold a value called reference\n• A reference variable does not hold an actual piece of data, it simply refers to \nthe data\n• A reference type links the variable that holds actual data to the object\n• If a kite is the object, then the spool of string that holds the site is the reference\n\n\nCreating a Reference Type\n• Two steps are typically required:\n• Declare a reference variable\n• Create an object and associate it with the reference variable\n• An example is the Random class\nRandom rand = new Random();\n• The “Random rand” part declares a variable named “rand”\n• The “new Random()” part creates an object and returns a reference to the object\n• The = operator assigns the reference that was returned from the new operator to the rand\nvariable\nRandom \nobject\nrand\n\n\nArray Basics\n• An array allows you to store a group of items of the same data type together in \nmemory\n• Processing a large number of items in an array is usually easier than processing a \nlarge number of items stored in separated variables\n• This is because each variable can only hold one data: \nint number1 = 99;\nint number2 = 100;\n• Each variable is a separated item that must be declared and individually processed\n• Variables are not ideal for storing and processing lists of data\n\n\nArray Basics \n• Arrays are reference type objects\n• To create an array, you need to:\n• declare a reference type object\n• create the object and associate it with the reference variable\n• In C#, the generic format to declare a reference variable for an array is:\nDataType[] arrayName;\n• For example, int[] numbersArray;\n• The generic format to create the array object and associate it with the variable is:\narrayName = new DataType[ArraySize];\n• The new keyword creates an object in memory; it also returns a reference to that array. For Example, \nnumbersArray = new int[6];\n\n\nArray Basics\n• In the previous example, there are two statements:\nint[] numbersArray;\nnumbersArray = new int[6];\n• There two statements can be combined into one statement:\nint[] numbersArray = new int[6];\n• You can create arrays of any data type\ndouble[] temperatures = new double[100];\ndecimal[] prices = new decimal[50];\nstring[] nameArray = new string[1200];\n• An array’s size declarator must be a positive integer and can be a literal value\nconst int SIZE = 6;\nint[] numbersArray = new int[SIZE];\n\n\nArray Elements\n• The storage locations in an array are known as elements\n• In memory, an array’s elements are located in consecutive memory locations\n• Each element in an array is assigned a unique number known as a subscript\n• Subscripts are used to identify specific elements in an array Subscripts start \nwith 0. The element has subscript 0, the nth has n-1.\n0\n0\n0\n0\n0\nnumbersArray\nvariable\nsubscript   0       1      2       3       4 \nWhen you create a numeric array in C#,\nits elements are set to the value of 0 by \ndefault\n\n\nWorking with Array Elements\n• Given the following code, you can access each individual element by using their \nsubscript\nconst int SIZE = 5;\nint numbersArray = new int[5];\nnumbersArray[0] = 20;\nnumbersArray[1] = 20;\nnumbersArray[2] = 20;\nnumbersArray[3] = 20;\nnumbersArray[4] = 20;\n• To get the value of the 3rd element, for example, use:\nnumbersArray[2]\n\n\nArray Initialization\n• When you create an array, you can optionally initialize it with a group of values\nconst int SIZE = 5;\nint[] numbersArray = new int[SIZE] { 10, 20, 30, 40, 50 };\n• Or simply,\nint[] numbersArray = new int[] { 10, 20, 30, 40, 50 };\n• And even,\nint[] numbersArray = { 10, 20, 30, 40, 50 };\n• All three produce the same results\n\n\nUsing a Loop to Step Through an Array\n• Arrays commonly use int as subscript. You can then create a loop to step through the array. For \nexample,\nconst int SIZE = 3;\nint[] myValues = new int[SIZE];\nfor (int index = 0; index < SIZE; index++)\n{\nmyValues[index] = 99;\n}\n• This example assigns 99 to each element as value\n• Notice that the number of iterations cannot exceed the array size; otherwise, an exception will be \nthrown at runtime\nfor (int index = 0; index <= SIZE; index++) // will cause exception\n{ … }\n\n\nThe Length Property\n• In C#, all arrays have a Length property that is set to the number of elements in \nthe array\ndouble[] temperatures = new double[25];\n• The output of the following is 25\nMessageBox.Show(temperatures.Length.ToString());\n• The Length property can be useful when processing the entire array\nfor (int index =0; index < temperatures.Length; index++) \n{\nMessageBox.Show(temperatures.Length.ToString());\n}\n\n\nUsing the foreach Loop with Arrays\n• C# provides a special loop called foreach to simplify array processing\n• The foreach loop is designed to work a temporary, read-only variable known as iteration variable. \nA generic format is:\nforeach (Type VariableName in ArrayName) \n{\nstatement(s);\n}\n• Type is the data type of the array\n• VariableName is the name of the temporary iteration variable\n• in is a keyword that must appear\n• ArrayName is the name of array to process\nint[] numbers = { 3, 6, 9 };\nforeach (int val in numbers)\n{\nMessageBox.Show(val.ToString());\n}\n\n\nThe List Collection\n• The C# List is a class in the .NET Framework that is similar to an array with the \nfollowing advantages:\n• A List object does not require size declaration\n• Its size is automatically adjusted\n• You can add or remove items \n• Syntax to create a List is:\nList<DataType> ListName = new List<DataType>();\n• For example,\nList<string> names = new List<string>();   // a List that holds strings\nList<int> numbers = new List<int>();          // a List that holds integers\n\n\nAdd or Remove Items\n• To add items, use the Add method\nList<string> nameList = new List<string>();\nnameList.Add(“Chris”);\nnameList.Add(“Bill”);\n• To insert an item, use the Insert method to insert an item at a specific index\nnameList.Insert(“Joanne”, 0);\n• To remove items, use:\n•Remove method: remove an item by its value\nnameList.Remove(“Bill”);\n•RemoveAt method: remove an item at a specific index in a List\nnameList.RemoveAt(0);\n\n\nInitializing a List Implicitly\n• To initialize a List implicitly, simply defines its items when you declare it\nList<int> numberList = new List<int>() { 1, 2, 3 };\nList<string>nameList = new List<string>() { “Christ”, “Kathryn”, “Bill” }\n• The Count property holds the number of items stored in the List\n• Useful in accessing all items in a List\nfor (int index = 0; index < nameList.Count; index++)\n{\nMessageBox.Show(nameList[index]);\n}\n\n\n"
  },
  {
    "title": "M1_Variables.pdf",
    "url": "https://umsystem.instructure.com/courses/296958/files/32026318/download?verifier=4mZ8CrTiKIStCoGHC6JsglYXqmdYDYNkUc8bZ0Nz&amp;wrap=1",
    "body": "C# Basics\nVariables\n\n\nUsing identifiers\n• Identifiers are the names that you use to identify the elements in your \nprograms, such as namespaces, classes, methods, and variables. In C#, \nyou must adhere to the following syntax rules when choosing \nidentifiers:\n• You can use only letters (uppercase and lowercase), digits, and underscore \ncharacters.\n• An identifier must start with a letter or an underscore.\nFor example, result, _score, footballTeam, and plan9 are all valid identifiers, whereas \nresult%, footballTeam$, and 9plan are not.\n• C# is a case-sensitive language: footballTeam and FootballTeam are \ntwo different identifiers.\n\n\nReserved Keyword\n• The C# language reserves certain identifiers for its own use, and you cannot reuse these identifiers \nfor your own purposes.\n\n\nKeyword\n• C# also uses the following identifiers. These identifiers are not reserved by C#, which means that \nyou can use these names as identifiers for your own methods, variables, and classes, but you \nshould avoid doing so if at all possible.\n\n\nImportant C# Variable Types\nCore C# variable types start with a lowercase character\n–bool\n–int\n–float\n–char\n–string\n–class\nC# Built-In Primitive Data Types\n\n\nImportant C# Variable Types\n• bool – A 1-bit True or False Value\n– Short for Boolean\n– Named after George Boole (an English mathematician)\n– bools in C# actually use more than 1-bit of space\n• The smallest addressable memory chunk on a 32-bit system is 32 bits.\n• The smallest on a 64-bit system is 64 bits.\n– Literal examples:\ntrue     false     \n– bool verified = true;\n\n\nImportant C# Variable Types\n• int – A 32-bit Integer\n– Stores a single integer number\n• Integers are numbers with no fractional or decimal element\n– int math is very fast and accurate\n– Can store numbers between –2,147,483,648 and 2,147,483,647\n– 31 bits used for number and 1 bit used for sign\n– Literal examples:\n1     34567     -48198\n– int nonFractionalNumber = 12345;\n\n\nImportant C# Variable Types\n• float – A 32-bit Decimal Number\n– Stores a floating-point number with a decimal element\n• A floating-point number is stored in something like scientific notation\n• Scientific notation is numbers in the format a*10b:  300 is 3*102\n– Floating-point numbers are stored in the format a*2b\n• 23 bits are used for the significand (the a part)\n• 8 bits are used for the exponent (the b part)\n• 1 bit determines whether the number is positive or negative\n– Floats are inaccurate for large numbers and for numbers between -1 and 1\n• There is no accurate float representation for 1 / 3\n– Literal examples:\n3.14f     123f     123.456f\n– float notPreciselyOneThird = 1.0f / 3.0f;\n\n\nImportant C# Variable Types\n• char – A 16-bit Character\n– Single character represented by 16 bits of information\n– Uses Unicode values for the characters\n• Unicode represents 110,000 different characters from over 100 different character sets and \nlanguages\n– Floats are inaccurate for large numbers and for numbers between -1 and 1\n• There is no accurate float representation for 1 / 3\n– Uppercase and lowercase letters are different values!\n– char literals are surrounded by single quotes\n– Literal examples:\n'A'     'a'     '\\t'\n– char theLetterA = 'A';\n\n\nImportant C# Variable Types\n• string – A Series of 16-bit Characters\n– Stores from no characters (\"\") to an entire novel\n• Max length is 2 billion chars; 12,000 times the length of Hamlet\n– string literals are surrounded by double quotes\n– Literal examples:\n\"Hello\"     \"\"     \"\\tTab\"\n– string theFirstLineOfHamlet = \"Who's there?\";\n– You can access individual characters via bracket access\n•char theCharW = theFirstLineOfHamlet[0];\n•char questionMark = theFirstLineOfHamlet[11];\n– The length of a string is accessed via .Length\n•int len = theFirstLineOfHamlet.Length;\n– Sets len to 12\n\n\nImportant C# Variable Types\n• class – A Collection of Functions and Data\n– A class creates a new variable type\n– Covered extensively in later Modules\n– Already used in the HelloWorld project\nEverything between the braces { } is part of the class\n\n\n"
  },
  {
    "title": "M1_Boolean.pdf",
    "url": "https://umsystem.instructure.com/courses/296958/files/32026286/download?verifier=MD2R8m7RtcaKUhpx3LVcdUCXrv5XiA2G7EjfuIDm&amp;wrap=1",
    "body": "C# Basics\nBoolean Operations\n\n\nBoolean Operations\nOperations that combine and compare bools\n– !\nThe NOT Operator\n– &&\nThe AND Operator\n– ||\nThe OR Operator\n3\n\n\nBoolean Operations\n!\nThe NOT Operator\n– Pronounced either \"not\" or \"bang\"\n– Reverses value of the bool\nConsole.WriteLine ( !true );    // Outputs: false\nConsole.WriteLine ( !false );   // Outputs: true\nConsole.WriteLine ( !(!true) ); // Outputs: true (the double negative of true)\n– Also called the \"logical negation operator\"\n• This differentiates it from ~, the bitwise not operator\n4\n\n\nBoolean Operations\n&& The AND Operator\n– Returns true only if both operands are true\nConsole.WriteLine ( false && false );    // false\nConsole.WriteLine ( false && true  );    // false\nConsole.WriteLine ( true  && false );    // false\nConsole.WriteLine ( true  && true  );    // true \n5\n\n\nBoolean Operations\n||\nThe OR Operator\n– Returns true if either operand is true\nConsole.WriteLine ( false && false );    // false\nConsole.WriteLine ( false && true  );    // true\nConsole.WriteLine ( true  && false );    // true\nConsole.WriteLine ( true  && true  );    // true \n– | (the pipe) is Shift-Backslash\n• Just above the return or enter key on a US keyboard\n6\n\n\nComparison Operators\nAllow the comparison of two values\nReturn a bool (either true or false)\n== Is Equal To\n!= Not Equal To\n>\nGreater Than\n<\nLess Than\n>= Greater Than or Equal To\n<= Less Than or Equal To\n7\n\n\nCOMPARISON BY VALUE OR REFERENCE\nSimple variables are compared by value\n– bool, int, float, char, string\nMore complex variables are compared by reference\n– When variables are compared by reference, the comparison is not of \ntheir internal values but of whether they point to the same location in \nmemory\n– C# classes you write\n– Detailed discussion will be in the future modules\n8\n\n\nComparison Operators\n• ==\nIs Equal To\n– Returns true if the values or references compared are equivalent\nConsole.WriteLine ( 10 == 10 );          // Outputs: True\nConsole.WriteLine ( 20 == 10 );          // Outputs: False\nConsole.WriteLine ( 1.23f == 3.14f );    // Outputs: False\nConsole.WriteLine ( 1.23f == 1.23f );    // Outputs: True\nConsole.WriteLine ( 3.14f == Math.PI ); // Outputs: False\n// Math.PI has more decimal places than 3.14f\n– Do NOT confuse == and =\n==\nThe comparison operator\n=\nThe assignment operator\n9\n\n\nComparison Operators\n!=\nNot Equal To\n– Returns true if the values or references compared are \nNOT equivalent\nConsole.WriteLine ( 10 != 10 );          // Outputs: False\nConsole.WriteLine ( 20 != 10 );          // Outputs: True\nConsole.WriteLine ( 1.23f != 3.14f );    // Outputs: True\nConsole.WriteLine ( 1.23f != 1.23f );    // Outputs: False\nConsole.WriteLine ( 3.14f != Math.PI ); // Outputs: True\n10\n\n\nComparison Operators\n>\nGreater Than\n– Returns true if the first operand is greater than the second\nConsole.WriteLine ( 10 > 10 );          // Outputs: False\nConsole.WriteLine ( 20 > 10 );          // Outputs: True\nConsole.WriteLine ( 1.23f > 3.14f );    // Outputs: False\nConsole.WriteLine ( 1.23f > 1.23f );    // Outputs: False\nConsole.WriteLine ( 3.14f > 1.23f );    // Outputs: True\n<\nLess Than\n– Returns true if the first operand is less than the second\nConsole.WriteLine ( 10 < 10 );          // Outputs: True\nConsole.WriteLine ( 20 < 10 );          // Outputs: False\nConsole.WriteLine ( 1.23f < 3.14f );    // Outputs: True\nConsole.WriteLine ( 1.23f < 1.23f );    // Outputs: True\nConsole.WriteLine ( 3.14f < 1.23f );    // Outputs: False\n11\n\n\nComparison Operators\n>=\nGreater Than or Equal To\n– True if the 1st operand is greater than or equal to the 2nd\nConsole.WriteLine ( 10 >= 10 );          // Outputs: True\nConsole.WriteLine ( 20 >= 10 );          // Outputs: True\nConsole.WriteLine ( 1.23f >= 3.14f );    // Outputs: False\nConsole.WriteLine ( 1.23f >= 1.23f );    // Outputs: True\nConsole.WriteLine ( 3.14f >= 1.23f );    // Outputs: True\n<=\nLess Than or Equal To\n– True if the 1st operand is less than or equal to the 2nd\nConsole.WriteLine ( 10 <= 10 );          // Outputs: True\nConsole.WriteLine ( 20 <= 10 );          // Outputs: False\nConsole.WriteLine ( 1.23f <= 3.14f );    // Outputs: True\nConsole.WriteLine ( 1.23f <= 1.23f );    // Outputs: True\nConsole.WriteLine ( 3.14f <= 1.23f );    // Outputs: False\n12\n\n\nConditional Statements\nControl Flow Within Your Programs\nif\nif / else\nif / else if / else\nswitch\nCan be combined with Boolean operations\nMake use of braces { }\n13\n\n\nConditional Statements\nIf - Performs code within braces if the argument within parentheses is \ntrue \nif (true) {\nprint( \"This line will print.\" );\n}\nif (false) {\nprint( \"This line will NOT print.\" );\n}\n// The output of this code will be:\n//    This line will print.\nAll the code within the braces of the if statement executes\n14\n\n\nConditional Statements\n• Combining if statements with boolean operations\nbool night = true;\nbool fullMoon = false;\nif (night) {\nConsole.WriteLine ( \"It's night.\" );\n}\nif (!fullMoon) {\nConsole.WriteLine t( \"The moon is not full.\" );\n}\nif (night && fullMoon) {\nConsole.WriteLine ( \"Beware werewolves!!!\" );\n}\nif (night && !fullMoon) {\nConsole.WriteLine ( \"No werewolves tonight. (Whew!)\" );\n}\n// The output of this code will be:\n//     It's night.\n//     The moon is not full.\n//     No werewolves tonight. (Whew!)\n15\n\n\nConditional Statements\n• Combining if statements with comparison operators\nif (10 == 10 ) {\nConsole.WriteLine( \"10 is equal to 10.\" );\n}\nif ( 10 > 20 ) {\nConsole.WriteLine( \"10 is greater than 20.\" );\n}\nif ( 1.23f <= 3.14f ) {\nConsole.WriteLine( \"1.23 is less than or equal to 3.14.\" );\n}\nif ( 1.23f >= 1.23f ) {\nConsole.WriteLine( \"1.23 is greater than or equal to 1.23.\" );\n}\nif ( 3.14f != Math.PI ) {\nConsole.WriteLine( \"3.14 is not equal to \"+Math.PI+\".\" );\n// + can be used to concatenate strings with other data types.\n// When this happens, the other data is converted to a string.\n}\n• Don't accidentally use   =   in an if statement!!!\n16\n\n\nConditional Statements\nif / else\n– Performs one action if true, and another if false\nbool night = false;\nif (night) {\nprint( \"It's night.\" );\n} else {\nprint( \"What are you worried about?\" );\n}\n// The output of this code will be:\n//     What are you worried about?\n17\n\n\nConditional Statements\n• if / else if / else\n– Possible to chain several else if clauses\nbool night = true;\nbool fullMoon = true;\nif (!night) {              // Condition 1 (false)\nConsole.WriteLine(\"It’s daytime. What are you worried about?\");\n} else if (fullMoon) {     // Condition 2 (true)\nConsole.WriteLine( \"Beware werewolves!!!\" );\n} else {                   // Condition 3 (not checked)\nConsole.WriteLine( \"It's night, but the moon is not full.\" );\n}\n// The output of this code will be:\n//     Beware werewolves!!!\n18\n\n\nConditional Statements\n• Nested if statements\nbool night = true;\nbool fullMoon = false;\nif (!night) { \nConsole.WriteLine( \"It’s daytime. Why are you worried about?\" );\n} else {\nif (fullMoon) { \nConsole.WriteLine( \"Beware werewolves!!!\" );\n} else {\nConsole.WriteLine( \"It's night, but the moon isn't full.\" );\n}\n}\n// The output of this code will be:\n//     It's night, but the moon isn't full.\n19\n\n\nConditional Statements\n• Switch: alternative to several if statements\n– Can only compare for equality\n– Can only compare against a single variable against literals \nint num = 3;\nswitch (num) {  // The variable in parentheses is being compared\ncase (0):  // Each case is a literal that is compared against num\nConsole.WriteLine( \"The number is zero.\" );\nbreak;  // Each case must end with a break statement.\ncase (1):\nConsole.WriteLine( \"The number is one.\" );\nbreak; \ncase (2):\nConsole.WriteLine( \"The number is two.\" );\nbreak; \ndefault:  // If none of the other cases are true, default will happen\nConsole.WriteLine( \"The number is more than a couple.\" );\nbreak;\n}  // The switch statement ends with a closing brace.\n// The output of this code is: The number is more than a couple.\n20\n\n\nConditional Statements\n• Switch can \"fall through\" to other cases\nint num = 3;\nswitch (num) {\ncase (0):\nprint( \"The number is zero.\" );\nbreak;\ncase (1):\nprint( \"The number is one.\" );\nbreak; \ncase (2):\nprint( \"The number is a couple.\" );\nbreak;\ncase (3):                         // case (3) falls through to case (4)\ncase (4):                         // case (4) falls through to case (5)\ncase (5):\nprint( \"The number is a few.\" );\nbreak;\ndefault:\nprint( \"The number is more than a few.\" );\nbreak;\n}\n// The output of this code is: The number is a few.\n21\n\n\n"
  },
  {
    "title": "FirstWPF.pdf",
    "url": "https://umsystem.instructure.com/courses/296958/files/32026322/download?verifier=B4u9k1OX1qgAY6kFNRYFxWsa6UkauLlMG5VFwvom&amp;wrap=1",
    "body": "Create your first WPF application in Visual \nStudio 2019 \nThis tutorial shows you how to develop your first Windows Presentation Foundation (WPF) \ndesktop application that includes the elements that are common to most WPF applications: \nExtensible Application Markup Language (XAML) markup, code-behind, application \ndefinitions, controls, layout. To develop the application, you'll use Visual Studio. \nYou learn how to: \n \nCreate a WPF project. \n \nUse XAML to design the appearance of the application's user interface (UI). \n \nWrite code to build the application's behavior. \n \nAdd controls and create the layout to compose the application UI. \nPrerequisites \n \nVisual Studio 2019 with the .NET desktop development workload installed. \nFor more information about installing the latest version of Visual Studio, see Install \nVisual Studio. \nCreate the application project \nThe first step is to create the application infrastructure, which includes an application definition, \ntwo pages, and an image. \n1. Create a new WPF Application project in Visual C# named FirstWPF: \na. Open Visual Studio and select Create a new project under the Get \nstarted menu. \nThe Create a new project dialog opens. \nb. In the Language dropdown, select C# . \nc. Select the WPF App (.NET Framework) template and then select Next. \n\n\n \nThe Configure your new project dialog opens. \nd. Enter the project name FirstWPF and then select Create.  \n \nVisual Studio creates the project and opens the designer for the default application \nwindow named MainWindow.xaml.  \n\n\n \n2. Open App.xaml . \nThis XAML file defines a WPF application and any application resources. You also use this \nfile to specify the UI, in this case MainWindow.xaml, that automatically shows when the \napplication starts. \n<Application x:Class=\"FirstWPF.App\" \n             xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" \n             xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" \n             xmlns:local=\"clr-namespace:FirstWPF\" \n             StartupUri=\"MainWindow.xaml\"> \n    <Application.Resources> \n          \n    </Application.Resources> \n</Application> \n3. Open MainWindow.xaml. \nThis XAML file is the main window of your application and displays content created in \npages. The Window class defines the properties of a window, such as its title, size, or icon, \nand handles events, such as closing or hiding. \n<Window x:Class=\"FirstWPF.MainWindow\" \n        xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" \n        xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" \n        xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\" \n        xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" \n        xmlns:local=\"clr-namespace:FirstWPF\" \n        mc:Ignorable=\"d\" \n        Title=\"MainWindow\" Height=\"450\" Width=\"800\"> \n    <Grid> \n\n\n4. Add controls  \nControls are UI objects that allow users to interact with your application. For more \ninformation, see Controls. \nThe WPF Designer shows a design view and a XAML view of MainWindow.xaml in a \nsplit view.  \n \na. Use the Toolbox to drag and drop UI elements into the design view. Add TextBox, \nTextBlock, RadioButton and Button into the design view.  \nAdd Names to the two RadioButton and Button.  \nb. Subscribing to Events \nYou can subscribe to a control's event by using either XAML or code, but you can only \nhandle an event in code. The following example shows how to subscribe to \nthe Click event of a Button. \nXAML \n<Button Grid.Row=\"2\" Grid.ColumnSpan=\"2\" Name=\"submitName\" \nClick=\"submit_Click\" \n  Background=\"Green\">View message</Button> \n \n\n\nThe following example handles the Click event of a Button. \nC# \nvoid submit_Click(object sender, RoutedEventArgs e) \n{ \n    MessageBox.Show(\"Hello, \" + firstName.Text + \" \" + lastName.Text); \n} \nThe following illustration shows when control names (RadioButton, Button) and events \n(Button) are added. \n \n5. Add code behind \nNow we can work on the code behind. In Solution Explorer, open up \nMainWindow.xaml.cs, which is nested under MainWindow.xaml. Type in the following \ncode. \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n\nnamespace FirstWPF \n{ \n    /// <summary> \n    /// Interaction logic for MainWindow.xaml \n    /// </summary> \n    public partial class MainWindow : Window \n    { \n        public MainWindow() \n        { \n            InitializeComponent(); \n        } \n \n        private void Button_Click(object sender, RoutedEventArgs e) \n        { \n            if (HelloRB.IsChecked == true) \n            { \n                MessageBox.Show(\"Hello\"); \n            } \n            else \n            { \n                ByeRB.IsChecked = true; \n                MessageBox.Show(\"Good Bye!\"); \n            } \n        } \n    } \n} \n6. To build and run the application, press Ctrl + F5 or select Start Without Debugging from \nthe Debug menu. Test with the Button and RadionButtons. The following illustration \nshows a sample test result. \n \n\n\n"
  }
]